-- Copyright 2007-2013 Till Tantau
-- Copyright 2022 Augusto Stoffel, Jens Schneider
-- SPDX-License-Identifier: GFDL-1.2-or-later or LPPL-1.3c+
--
-- Adapted from the PGF manual, version 3.1.9a, which can be found at
-- https://ctan.org/pkg/pgf.
ctan_package = "tikz"
documentation = {{summary = "PGF Manual", uri = "texmf:doc/generic/pgf/pgfmanual.pdf"}}
commands = {
  afterdecoration = {
    arguments = {{meta = "after code"}},
    details = [[
Defines ⟨after code⟩ as commands to be executed after the decoration has
been applied to the current segment. This command can be omitted.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/afterdecoration"
  },
  anchor = {
    arguments = {{meta = "name"}, {meta = "code"}},
    details = [[
This command declares an anchor named ⟨name⟩. Unlike for saved anchors,
the ⟨code⟩ will not be executed each time a node is declared. Rather,
the ⟨code⟩ is only executed when the anchor is specifically requested;
either for anchoring the node during its creation or as a position in
the shape referenced later on.

The ⟨name⟩ is a quite arbitrary string that is not "passed down" to the
system level. Thus, names like `south` or `1` or `::` would all be fine.

A saved anchor is not automatically also a normal anchor. If you wish to
give the users access to a saved anchor you must declare a normal anchor
that just returns the position of the saved anchor.

When the ⟨code⟩ is executed, all saved anchor macros will be defined.
Thus, you can reference them in your ⟨code⟩. The effect of the ⟨code⟩
should be to set the values of `\pgf@x` and `\pgf@y` to the coordinates
of the anchor.

Let us consider some example for the `simple rectangle` shape. First, we
would like to make the upper right corner publicly available, for
example as `north east`:

    \anchor{north east}{\upperrightcorner}

The `\upperrightcorner` macro will set `\pgf@x` and `\pgf@y` to the
coordinates of the upper right corner. Thus, `\pgf@x` and `\pgf@y` will
have exactly the right values at the end of the anchor's code.

Next, let us define a `north west` anchor. For this anchor, we can
negate the `\pgf@x` variable:

    \anchor{north west}{
      \upperrightcorner
      \pgf@x=-\pgf@x
    }

Finally, it is a good idea to always define a `center` anchor, which
will be the default location for a shape.

    \anchor{center}{\pgfpointorigin}

You might wonder whether we should not take into consideration that the
node is not placed at the origin, but has been shifted somewhere.
However, the anchor positions are always specified in the shape's
"private" coordinate system. The "outer" transformation that has been
applied to the shape upon its creation is applied automatically to the
coordinates returned by the anchor's ⟨code⟩.

Our `simple rectangle` only has one text label (node part) called
`text`. This is the default situation, so we do not need to do anything.
For the `text` node part we must set up a `text` anchor. Upon creation
of a node, this anchor will be made to coincide with the left endpoint
of the baseline of the text label (within the private coordinate system
of the shape). By default, the `text` anchor is at the origin, but you
may change this. For example, we would say

    \anchor{text}{%
      \upperrightcorner%
      \pgf@x=-\pgf@x%
      \pgf@y=-\pgf@y%
    }

to center the text label on the origin in the shape coordinate space.
Note that we could *not* have written the following:

    \anchor{text}{\pgfpoint{-.5\wd\pgfnodeparttextbox}{-.5\ht\pgfnodeparttextbox}}

Do you see why this is wrong? The problem is that the box
`\pgfnodeparttextbox` will most likely not have the correct size when
the anchor is computed. After all, the anchor position might be
recomputed at a time when several other nodes have been created.

If a shape has several node parts, we would have to define an anchor for
each part.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/anchor"
  },
  anchorborder = {
    arguments = {{meta = "code"}},
    details = [[
A *border anchor* is an anchor point on the border of the shape. What
exactly is considered as the "border" of the shape depends on the shape.

When the user requests a point on the border of the shape using the
`\pgfpointshapeborder` command, the ⟨code⟩ will be executed to discern
this point. When the execution of the ⟨code⟩ starts, the dimensions
`\pgf@x` and `\pgf@y` will have been set to a location $p$ in the
shape's coordinate system, and relative to the anchor `center`. Note
that `\pgfpointshapeborder` will produce an error if the shape does not
contain the `center` anchor.

It is now the job of the ⟨code⟩ to set up `\pgf@x` and `\pgf@y` such
that they specify the point on the shape's border that lies on a
straight line from the shape's center to the point $p$. Usually, this is
a somewhat complicated computation, involving many case distinctions and
some basic math. Note that the output coordinates must be returned in
the shape's coordinate system, *no longer* relative to the `center`
anchor. While these different points of reference are only noticeable if
the `center` anchor is not at the origin of the shape's coordinate
system, it implies that "doing nothing" as a border anchor, i.e.,
returning the point that was fed to `\pgfpointshapeborder` requires
adding the `center` anchor to the input coordinates.

For our `simple rectangle` we must compute a point on the border of a
rectangle whose one corner is the origin (ignoring the depth for
simplicity) and whose other corner is `\upperrightcorner`. The following
code might be used:

    \anchorborder{%
      % Call a function that computes a border point. Since this
      % function will modify dimensions like \pgf@x, we must move them to
      % other dimensions.
      \@tempdima=\pgf@x
      \@tempdimb=\pgf@y
      \pgfpointborderrectangle{\pgfpoint{\@tempdima}{\@tempdimb}}{\upperrightcorner}
    }
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/anchorborder"
  },
  arrow = {
    arguments = {
      {
        delimiters = {"[", "]"},
        keys = "$ref:tikz#/keys/tikz",
        meta = "options",
        optional = true
      },
      {meta = "arrow end tip"}
    },
    details = [[
This command simply draws the ⟨arrow end tip⟩ at the origin, pointing
right. This is exactly what you need when you want to draw an arrow tip
as a marking.

The ⟨options⟩ can only be given when TikZ is used. In this case, they
are executed in a scope that contains the arrow tip.

    \begin{tikzpicture}[decoration={
        markings,% switch on markings
        mark=at position 1cm  with {\node[red]{1cm};},
        mark=at position .75  with {\arrow[blue,line width=2mm]{>}},
        mark=at position -1cm with {\arrowreversed[black]{stealth}}}
        ]
      \draw [help lines] grid (3,2);
      \draw [postaction={decorate}] (0,0) -- (3,1) arc (0:180:1.5 and 1);
    \end{tikzpicture}

Here is a more useful example:

    \begin{tikzpicture}[decoration={
        markings,% switch on markings
        mark=between positions 0 and .75 step 4mm with {\arrow{stealth}},
        mark=between positions .75 and 1 step 4mm with {\arrowreversed{stealth}}}
        ]
      \draw [help lines] grid (3,2);
      \draw [postaction={decorate}] (0,0) -- (3,1) arc (0:180:1.5 and 1);
    \end{tikzpicture}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/arrow"
  },
  arrowreversed = {
    arguments = {
      {
        delimiters = {"[", "]"},
        keys = "$ref:tikz#/keys/tikz",
        meta = "options",
        optional = true
      },
      {meta = "arrow end tip"}
    },
    details = [[
As above, only the arrow end tip is flipped and points in the other
direction.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/arrowreversed"
  },
  attribute = {
    arguments = {
      {meta = "attribute name"},
      {literal = "="},
      {meta = "initial value"},
      {literal = ";"}
    },
    details = [[
This command can only be given inside the body of an `\pgfooclass`
command. It declares the attribute named ⟨attribute name⟩. This name,
like method or class names, can be quite arbitrary, but should not
contain periods. Valid names are `an_ attribute?` or `my attribute`.

You can optionally specify an ⟨initial value⟩ for the attribute; if none
is given, the empty string is used automatically. The initial value is
the value that the attribute will have just after the object has been
created and before the constructor is called.

    \pgfooclass{stamp}{
      % This is the class stamp

      \attribute text;
      \attribute rotation angle = 20;

      \method stamp(#1) {
        \pgfooset{text}{#1} % Set the text
      }

      \method apply(#1,#2) {
        \pgfoothis.shift origin(#1,#2)

        % Draw the stamp:
        \node [rotate=\pgfoovalueof{rotation angle},font=\huge]
          {\pgfoovalueof{text}};
      }

      \method shift origin(#1,#2) { ... }

      \method set rotation (#1) {
        \pgfooset{rotation angle}{#1}
      }
    }
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/attribute"
  },
  backgroundpath = {
    arguments = {{meta = "code"}},
    details = [[
This command specifies the path that "makes up" the background of the
shape. Note that the shape cannot prescribe what is going to happen with
the path: It might be drawn, shaded, filled, or even thrown away. If you
want to specify that something should "always" happen when this shape is
drawn (for example, if the shape is a stop-sign, we *always* want it to
be filled with a red color), you can use commands like
`\beforebackgroundpath`, explained below.

When the ⟨code⟩ is executed, all saved anchors will be in effect. The
⟨code⟩ should contain path construction commands.

For our `simple rectangle`, the following code might be used:

    \backgroundpath{
      \pgfpathrectanglecorners
        {\upperrightcorner}
        {\pgfpointscale{-1}{\upperrightcorner}}
    }

As the name suggests, the background path is used "behind" the text
labels. Thus, this path is used first, then the text labels are drawn,
possibly obscuring part of the path.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/backgroundpath"
  },
  beforebackgroundpath = {
    arguments = {{meta = "code"}},
    details = [[
This command works like `\behindbackgroundpath`, only the ⟨code⟩ is
executed after the background path has been used, but before the texts
label are drawn.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/beforebackgroundpath"
  },
  beforedecoration = {
    arguments = {{meta = "before code"}},
    details = [[
Defines ⟨before code⟩ as (typically) PGF commands to be executed before
the decoration is applied to the current segment. This command can be
omitted. If you wish to set up some decoration specific parameters such
as segment length, or segment amplitude, then they can be set in ⟨before
code⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/beforedecoration"
  },
  beforeforegroundpath = {
    arguments = {{meta = "code"}},
    details = [[
This ⟨code⟩ is executed at the very end.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/beforeforegroundpath"
  },
  behindbackgroundpath = {
    arguments = {{meta = "code"}},
    details = [[
Unlike the previous two commands, ⟨code⟩ should not only construct a
path, it should also use this path in whatever way is appropriate. For
example, the ⟨code⟩ might fill some area with a uniform color.

Whatever the ⟨code⟩ does, it does it first. This means that any drawing
done by ⟨code⟩ will be even behind the background path.

Note that the ⟨code⟩ is protected with a `{pgfscope}`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/behindbackgroundpath"
  },
  behindforegroundpath = {
    arguments = {{meta = "code"}},
    details = [[
The ⟨code⟩ is executed after the text labels have been drawn, but before
the foreground path is used.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/behindforegroundpath"
  },
  breakforeach = {
    details = [[
If this command is given inside a `\foreach` command, no further
executions of the ⟨commands⟩ will occur. However, the current execution
of the ⟨commands⟩ is continued normally, so it is probably best to use
this command only at the end of a `\foreach` command.

    \begin{tikzpicture}
      \foreach \x in {1,...,4}
        \foreach \y in {1,...,4}
        {
          \fill[red!50] (\x,\y) ellipse (3pt and 6pt);

          \ifnum \x<\y
            \breakforeach
          \fi
        }
    \end{tikzpicture}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/breakforeach"
  },
  calendar = {
    arguments = {{meta = "calendar specification"}, {literal = ";"}},
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/calendar"
  },
  chainin = {
    arguments = {
      {delimiters = {"(", ")"}, meta = "existing name"},
      {
        delimiters = {"[", "]"},
        keys = "$ref:tikz#/keys/tikz",
        meta = "options",
        optional = true
      }
    },
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/chainin"
  },
  clip = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
This option causes all subsequent drawings to be clipped against the
current path and the size of subsequent paths will not be important for
the picture size. If you clip against a self-intersecting path, the
even-odd rule or the nonzero winding number rule is used to determine
whether a point is inside or outside the clipping region.

The clipping path is a graphic state parameter, so it will be reset at
the end of the current scope. Multiple clippings accumulate, that is,
clipping is always done against the intersection of all clipping areas
that have been specified inside the current scopes. The only way of
enlarging the clipping area is to end a `{scope}`.

    \begin{tikzpicture}
      \draw[clip] (0,0) circle (1cm);
      \fill[red] (1,0) circle (1cm);
    \end{tikzpicture}

It is usually a *very* good idea to apply the `clip` option only to the
first path command in a scope.

If you "only wish to clip" and do not wish to draw anything, you can use
the `\clip` command, which is a shorthand for `\path[clip]`.

    \begin{tikzpicture}
      \clip (0,0) circle (1cm);
      \fill[red] (1,0) circle (1cm);
    \end{tikzpicture}

To keep clipping local, use `{scope}` environments as in the following
example:

    \begin{tikzpicture}
      \draw (0,0) -- ( 0:1cm);
      \draw (0,0) -- (10:1cm);
      \draw (0,0) -- (20:1cm);
      \draw (0,0) -- (30:1cm);
      \begin{scope}[fill=red]
        \fill[clip] (0.2,0.2) rectangle (0.5,0.5);

        \draw (0,0) -- (40:1cm);
        \draw (0,0) -- (50:1cm);
        \draw (0,0) -- (60:1cm);
      \end{scope}
      \draw (0,0) -- (70:1cm);
      \draw (0,0) -- (80:1cm);
      \draw (0,0) -- (90:1cm);
    \end{tikzpicture}

There is a slightly annoying catch: You cannot specify certain graphic
options for the command used for clipping. For example, in the above
code we could not have moved the `fill=red` to the `\fill` command. The
reasons for this have to do with the internals of the PDF specification.
You do not want to know the details. It is best simply not to specify
any options for these commands.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/clip",
    summary = "Inside `{tikzpicture}` this is an abbreviation for `\\path[clip]`."
  },
  colorcurrentmixin = {
    details = [[
Expands to the current accumulated mix-in. Each nesting of a
`colormixin` adds a mix-in to this list.

    \begin{minipage}{\linewidth-6pt}\raggedright
    \begin{colormixin}{75!white}
      \colorcurrentmixin\ should be ``!75!white''\par
      \begin{colormixin}{75!black}
        \colorcurrentmixin\ should be ``!75!black!75!white''\par
        \begin{colormixin}{50!white}
          \colorcurrentmixin\ should be ``!50!white!75!black!75!white''\par
        \end{colormixin}
      \end{colormixin}
    \end{colormixin}
    \end{minipage}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/colorcurrentmixin"
  },
  coordinate = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
Inside `{tikzpicture}` this is an abbreviation for `\path coordinate`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/coordinate"
  },
  datavisualization = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
This command is available only inside a `{tikzpicture}` environment.

The ⟨data visualization options⟩ are used to configure the data
visualization, that is, how the data is to be depicted. The options are
executed with the path prefix `/tikz/data visualization`. This means
that normal TikZ options like `thin` or `red` cannot be used here.
Rather, a large number of options specific to data visualizations are
available.

As a minimum, you should specify at least two options: First, you should
use an option that selects an axis system that is appropriate for your
plot. Typical possible keys are `school book axes` or `scientific axes`,
detailed information on them can be found in Section ??.

Second, you use an option to select *how* the data should be visualized.
This is done using a key like `visualize as line` which will, as the
name suggests, visualize the data by connecting data points in the plane
using a line. Similarly, `visualize as smooth cycle` will try to fit a
smooth cycle through the data points. Detailed information on possible
visualizers can be found in Section ??.

Following these options, the ⟨data specification⟩ is used to provide the
actual to-be-visualized data. The syntax is somewhat similar to commands
like `\path`: The ⟨data specification⟩ is a sequence of keywords
followed by local options and parameters, terminated with a semicolon.
(Indeed, like for the `\path` command, the ⟨data visualizers options⟩
need not be specified at the beginning, but additional option surrounded
by square brackets may be given anywhere inside the ⟨data
specification⟩.)

The different possible keywords inside the ⟨data specification⟩ are
explained in the following.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/datavisualization"
  },
  decoration = {
    arguments = {{meta = "name"}},
    details = [[
This sets the decoration for the current state to ⟨name⟩. If this
command is omitted, the `moveto` decoration will be used.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/decoration"
  },
  deferredanchor = {
    arguments = {{meta = "name"}, {meta = "code"}},
    details = [[
This command declares an anchor named ⟨name⟩. It works like `\anchor`.
However, unlike for anchors declared by `\anchor`, ⟨name⟩ will *not* be
expanded during the shape declaration (i.e. not during
`\pgfdeclareshape`). Rather, the ⟨name⟩ is expanded when the *node* is
actually used (with `\pgfnode` or more likely with `\node`). This may be
useful if the anchor name is context dependent (depending, for example,
on the value of a key).

    \makeatletter
    \def\foo{foo}
    \pgfdeclareshape{simple shape}{%
      \savedanchor{\center}{%
        \pgfpointorigin}
      \anchor{center}{\center}
      \savedanchor{\anchorfoo}{%
        \pgf@x=1cm
        \pgf@y=0cm}
      \deferredanchor{anchor \foo}{\anchorfoo}}

    \begin{tikzpicture}
      \node[simple shape] (Test1) at (0,0) {};
      \fill (Test1.anchor foo) circle (2pt) node[below] {anchor foo anchor};
      %
      \def\foo{bar}
      \node[simple shape] (Test2) at (2,2) {};
      \fill (Test2.anchor bar) circle (2pt) node[below] {anchor bar anchor};
    \end{tikzpicture}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/deferredanchor"
  },
  draw = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
Causes the path to be drawn. "Drawing" (also known as "stroking") can be
thought of as picking up a pen and moving it along the path, thereby
leaving "ink" on the canvas.

There are numerous parameters that influence how a line is drawn, like
the thickness or the dash pattern. These options are explained below.

If the optional ⟨color⟩ argument is given, drawing is done using the
given ⟨color⟩. This color can be different from the current filling
color, which allows you to draw and fill a path with different colors.
If no ⟨color⟩ argument is given, the last usage of the `color=` option
is used.

If the special color name `none` is given, this option causes drawing to
be "switched off". This is useful if a style has previously switched on
drawing and you locally wish to undo this effect.

Although this option is normally used on paths to indicate that the path
should be drawn, it also makes sense to use the option with a `{scope}`
or `{tikzpicture}` environment. However, this will *not* cause all paths
to be drawn. Instead, this just sets the ⟨color⟩ to be used for drawing
paths inside the environment.

    \begin{tikzpicture}
      \path[draw=red] (0,0) -- (1,1) -- (2,1) circle (10pt);
    \end{tikzpicture}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/draw",
    summary = "Inside `{tikzpicture}` this is an abbreviation for `\\path[draw]`."
  },
  fill = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
This option causes the path to be filled. All unclosed parts of the path
are first closed, if necessary. Then, the area enclosed by the path is
filled with the current filling color, which is either the last color
set using the general `color=` option or the optional color ⟨color⟩. For
self-intersection paths and for paths consisting of several closed
areas, the "enclosed area" is somewhat complicated to define and two
different definitions exist, namely the nonzero winding number rule and
the even odd rule, see the explanation of these options, below.

Just as for the `draw` option, setting ⟨color⟩ to `none` disables
filling locally.

    \begin{tikzpicture}
      \fill (0,0) -- (1,1) -- (2,1);
      \fill (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
      \fill[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
      \fill (8,0) -- (9,1) -- (10,0) circle (.5cm);
    \end{tikzpicture}

If the `fill` option is used together with the `draw` option (either
because both are given as options or because a `\filldraw` command is
used), the path is filled *first*, then the path is drawn *second*. This
is especially useful if different colors are selected for drawing and
for filling. Even if the same color is used, there is a difference
between this command and a plain `fill`: A "filldrawn" area will be
slightly larger than a filled area because of the thickness of the
"pen".

    \begin{tikzpicture}[fill=yellow!80!black,line width=5pt]
      \filldraw (0,0) -- (1,1) -- (2,1);
      \filldraw (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
      \filldraw[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
      \filldraw (8,0) -- (9,1) -- (10,0) circle (.5cm);
    \end{tikzpicture}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/fill",
    summary = "Inside `{tikzpicture}` this is an abbreviation for `\\path[fill]`."
  },
  filldraw = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
Inside `{tikzpicture}` this is an abbreviation for `\path[fill,draw]`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/filldraw"
  },
  foreach = {
    arguments = {{literal = " "}, {meta = "variables"}, {literal = " "}},
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/foreach"
  },
  foregroundpath = {
    arguments = {{meta = "code"}},
    details = [[
This command works like `\backgroundpath`, only it is invoked after the
text labels have been drawn. This means that this path can possibly
obscure (part of) the text labels.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/foregroundpath"
  },
  graph = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
Inside a `{tikzpicture}` this is an abbreviation for `\path graph`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/graph"
  },
  ifdate = {
    arguments = {{meta = "tests"}, {meta = "code"}, {meta = "else code"}},
    details = [[
\[ifdate\] This command has the same effect as calling
`\pgfcalendarifdate` for the current date.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/ifdate"
  },
  inheritanchor = {
    arguments = {
      {literal = "[from="},
      {meta = "another shape name"},
      {literal = "]"},
      {meta = "name"}
    },
    details = [[
Inherits the code of one specific anchor named ⟨name⟩ from ⟨another
shape name⟩. Thus, unlike saved anchors, which must be inherited
collectively, normal anchors can and must be inherited individually.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/inheritanchor"
  },
  inheritanchorborder = {
    arguments = {
      {literal = "[from="},
      {meta = "another shape name"},
      {literal = "]"}
    },
    details = [[
Inherits the border anchor code from ⟨another shape name⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/inheritanchorborder"
  },
  inheritbackgroundpath = {
    arguments = {
      {literal = "[from="},
      {meta = "another shape name"},
      {literal = "]"}
    },
    details = [[
Inherits the background path code from ⟨another shape name⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/inheritbackgroundpath"
  },
  inheritbeforebackgroundpath = {
    arguments = {
      {literal = "[from="},
      {meta = "another shape name"},
      {literal = "]"}
    },
    details = [[
Inherits the before background path code from ⟨another shape name⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/inheritbeforebackgroundpath"
  },
  inheritbeforeforegroundpath = {
    arguments = {
      {literal = "[from="},
      {meta = "another shape name"},
      {literal = "]"}
    },
    details = [[
Inherits the before foreground path code from ⟨another shape name⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/inheritbeforeforegroundpath"
  },
  inheritbehindbackgroundpath = {
    arguments = {
      {literal = "[from="},
      {meta = "another shape name"},
      {literal = "]"}
    },
    details = [[
This command can be used to inherit the code used for the drawings
behind the background path from ⟨another shape name⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/inheritbehindbackgroundpath"
  },
  inheritbehindforegroundpath = {
    arguments = {
      {literal = "[from="},
      {meta = "another shape name"},
      {literal = "]"}
    },
    details = [[
Inherits the behind foreground path code from ⟨another shape name⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/inheritbehindforegroundpath"
  },
  inheritforegroundpath = {
    arguments = {
      {literal = "[from="},
      {meta = "another shape name"},
      {literal = "]"}
    },
    details = [[
Inherits the foreground path code from ⟨another shape name⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/inheritforegroundpath"
  },
  inheritsavedanchors = {
    arguments = {
      {literal = "[from="},
      {meta = "another shape name"},
      {literal = "]"}
    },
    details = [[
This command allows you to inherit the code for saved anchors from
⟨another shape name⟩. The idea is that if you wish to create a new shape
that is just a small modification of a another shape, you can recycle
the code used for ⟨another shape name⟩.

The effect of this command is the same as if you had called
`\savedanchor` and `\saveddimen` for each saved anchor or saved
dimension declared in ⟨another shape name⟩. Thus, it is not possible to
"selectively" inherit only some saved anchors, you always have to
inherit all saved anchors from another shape. However, you can inherit
the saved anchors of more than one shape by calling this command several
times.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/inheritsavedanchors"
  },
  jobname = {
    details = [[
The value of `\jobname` is one of `\tikzexternalrealjob` or
`\pgfactualjobname`, depending on the configuration. In short: if
auxiliary file support (`\label` and `\ref`) is activated,
`\jobname=\tikzexternalrealjob` (since that's the base file name of
auxiliary files).
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/jobname"
  },
  matrix = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
This option can be passed to a `node` path command. It signals that the
node will contain a matrix.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (4,2);
      \node [matrix,fill=red!20,draw=blue,very thick] (my matrix) at (2,1)
      {
        \draw (0,0)   circle (4mm); & \node[rotate=10] {Hello};        \\
        \draw (0.2,0) circle (2mm); & \fill[red]   (0,0) circle (3mm); \\
      };

      \draw [very thick,->] (0,0) |- (my matrix.west);
    \end{tikzpicture}

The exact syntax of the matrix is explained in the course of this
section.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/matrix",
    summary = "Inside `{tikzpicture}` this is an abbreviation for `\\path node[matrix]`."
  },
  method = {
    arguments = {
      {meta = "method name"},
      {delimiters = {"(", ")"}, meta = "parameter list"},
      {meta = "method body"}
    },
    details = [[
This macro, which is only defined inside a class definition, defines a
new method named ⟨method name⟩. Just like class names, method names can
contain spaces and other characters, so ⟨method names⟩ like
`put_ stamp_ here` or `put stamp here` are both legal.

Three method names are special: First, a method having either the same
name as the class or having the name `init` is called the *constructor*
of the class. There are (currently) no destructors; objects simply
become "undefined" at the end of the scope in which they have been
created. The other two methods are called `get id` and `get handle`,
which are always automatically defined and which you cannot redefine.
They are discussed in Section ??.

Overloading of methods by differing numbers of parameters is not
possible, that is, it is illegal to have two methods inside a single
class with the same name (despite possibly different parameter lists).
However, two different classes may contain a method with the same name,
that is, classes form namespaces for methods. Also, a class can
(re)implement a method from a superclass.

The ⟨method name⟩ must be followed by a ⟨parameter list⟩ in parentheses,
which must be present even when the ⟨parameter list⟩ is empty. The
⟨parameter list⟩ is actually a normal TeX parameter list that will be
matched against the parameters inside the parentheses upon method
invocation and, thus, could be something like `# 1# 2 foo # 3 bar.`, but
a list like `# 1,# 2,# 3` is more customary. By setting the parameter
list to just `# 1` and then calling, say, `\pgfkeys{# 1}` at the
beginning of a method, you can implement Objective-C-like named
parameters.

When a method is called, the ⟨body⟩ of the method will be executed. The
main difference to a normal macro is that while the ⟨body⟩ is executed,
a special macro called `\pgfoothis` is set up in such a way that it
references the object for which the method is executed.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/method"
  },
  n = {
    arguments = {{meta = "number register"}},
    details = [[
When this macro is used on the left-hand side of an `=`-sign in a let
operation, it has no effect and is just there for readability. When the
macro is used on the right-hand side of an `=`-sign or in the body of
the let operation, then it expands to the value stored in the ⟨number
register⟩. This will either be a dimensionless number like `2.0` or a
dimension like `5.6pt`.

For instance, if we say `let \n1={1pt+2pt}, \n2={1+2} in ...`, then
inside the `...` part the macro `\n1` will expand to `3pt` and `\n2`
expands to `3`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/n"
  },
  node = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
Inside `{tikzpicture}` this is an abbreviation for `\path node`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/node"
  },
  nodepart = {
    arguments = {
      {literal = "["},
      {keys = "$ref:tikz#/keys/tikz", meta = "options"},
      {literal = "]"},
      {meta = "part name"}
    },
    details = [[
This command can only be used inside the ⟨text⟩ argument of a `node`
path operation. It works a little bit like a `\part` command in LaTeX.
It will stop the typesetting of whatever node part was typeset until now
and then start putting all following text into the node part named ⟨part
name⟩ -- until another `\partname` is encountered or until the node
⟨text⟩ ends. The ⟨options⟩ will be local to this part.

    \begin{tikzpicture}
      \node [circle split,draw,double,fill=red!20]
      {
        % No \nodepart has been used, yet. So, the following is put in the
        % ``text'' node part by default.
        $q_1$
        \nodepart{lower} % Ok, end ``text'' part, start ``output'' part
        $00$
      }; % output part ended.
    \end{tikzpicture}

You will have to lookup which parts are defined by a shape.

The following styles influences node parts:
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/nodepart"
  },
  nodeparts = {
    arguments = {{meta = "list of node parts"}},
    details = [[
This command declares which parts make up nodes of this shape. A *node
part* is a (possibly empty) text label that is drawn when a node of the
shape is created.

By default, a shape has just one node part called `text`. However, there
can be several node parts. For example, the `circle split` shape has two
parts: the `text` part, which shows that the upper text, and a `lower`
part, which shows the lower text. For the `circle split` shape the
`\nodeparts` command was called with the argument `{text,lower}`.

When a multipart node is created, the text labels are drawn in the
sequences listed in the ⟨list of node parts⟩. For each node part, you
must have declared one anchor and the TeX-box of the part is placed at
this anchor. For a node part called `XYZ` the TeX-box
`\pgfnodepartXYZbox` is placed at anchor `XYZ`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/nodeparts"
  },
  p = {
    arguments = {{meta = "point register"}},
    details = [[
When this macro is used on the left-hand side of an `=`-sign in a let
operation, it has no effect and is just there for readability. When the
macro is used on the right-hand side of an `=`-sign or in the body of
the let operation, then it expands to the $x$-part (measured in
TeX points) of the coordinate stored in the ⟨register⟩, followed, by a
comma, followed by the $y$-part.

For instance, if we say `let \p1=(1pt,1pt+2pt) in ...`, then inside the
`...` part the macro `\p1` will expand to exactly the seven characters
"1pt,3pt". This means that you when you write `(\p1)`, this expands to
`(1pt,3pt)`, which is presumably exactly what you intended.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/p"
  },
  path = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
This command is available only inside a `{tikzpicture}` environment.

The ⟨specification⟩ is a long stream of *path operations*. Most of these
path operations tell TikZ how the path is built. For example, when you
write `–(0,0)`, you use a *line-to operation* and it means "continue the
path from wherever you are to the origin".

At any point where TikZ expects a path operation, you can also give some
graphic options, which is a list of options in brackets, such as
`[rounded corners]`. These options can have different effects:

1.  Some options take "immediate" effect and apply to all subsequent
    path operations on the path. For example, the `rounded corners`
    option will round all following corners, but not the corners
    "before" and if the `sharp corners` is given later on the path (in a
    new set of brackets), the rounding effect will end.

        \tikz \draw (0,0) -- (1,1)
                   [rounded corners] -- (2,0) -- (3,1)
                   [sharp corners] -- (3,0) -- (2,1);

    Another example are the transformation options, which also apply
    only to subsequent coordinates.

2.  The options that have immediate effect can be "scoped" by putting
    part of a path in curly braces. For example, the above example could
    also be written as follows:

        \tikz \draw (0,0) -- (1,1)
                   {[rounded corners] -- (2,0) -- (3,1)}
                   -- (3,0) -- (2,1);

3.  Some options only apply to the path as a whole. For example, the
    `color=` option for determining the color used for, say, drawing the
    path always applies to all parts of the path. If several different
    colors are given for different parts of the path, only the last one
    (on the outermost scope) "wins":

        \tikz \draw (0,0) -- (1,1)
                   [color=red] -- (2,0) -- (3,1)
                   [color=blue] -- (3,0) -- (2,1);

    Most options are of this type. In the above example, we would have
    had to "split up" the path into several `\path` commands:

        \tikz{\draw (0,0) -- (1,1);
              \draw [color=red] (1,1) -- (2,0) -- (3,1);
              \draw [color=blue] (3,1) -- (3,0) -- (2,1);}

By default, the `\path` command does "nothing" with the path, it just
"throws it away". Thus, if you write `\path(0,0)–(1,1);`, nothing is
drawn in your picture. The only effect is that the area occupied by the
picture is (possibly) enlarged so that the path fits inside the area. To
actually "do" something with the path, an option like `draw` or `fill`
must be given somewhere on the path. Commands like `\draw` do this
implicitly.

Finally, it is also possible to give *node specifications* on a path.
Such specifications can come at different locations, but they are always
allowed when a normal path operation could follow. A node specification
starts with `node`. Basically, the effect is to typeset the node's text
as normal TeX text and to place it at the "current location" on the
path. The details are explained in Section ??.

Note, however, that the nodes are *not* part of the path in any way.
Rather, after everything has been done with the path what is specified
by the path options (like filling and drawing the path due to a `fill`
and a `draw` option somewhere in the ⟨specification⟩), the nodes are
added in a post-processing step.

*Note:* When scanning for path operations TikZ expands tokens looking
for valid path operations. This however implies that these tokens has to
be fully expandable up to the point where it results in a valid path
operation.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/path"
  },
  pattern = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
This option causes the path to be filled with a pattern. If the ⟨name⟩
is given, this pattern is used, otherwise the pattern set in the
enclosing scope is used. As for the `draw` and `fill` options, setting
⟨name⟩ to `none` disables filling locally.

The pattern works like a fill color. In particular, setting a new fill
color will fill the path with a solid color once more.

Strangely, no ⟨name⟩s are permissible by default. You need to load for
instance the `patterns` library, see Section ??, to install predefined
patterns.

    \begin{tikzpicture}
      \draw[pattern=dots] (0,0) circle (1cm);
      \draw[pattern=fivepointed stars] (0,0) rectangle (3,1);
    \end{tikzpicture}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/pattern",
    summary = "Inside `{tikzpicture}` this is an abbreviation for `\\path[pattern]`."
  },
  pic = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
Inside `{tikzpicture}` this is an abbreviation for `\path pic`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/pic"
  },
  rule = {
    arguments = {{literal = "{"}, {meta = "head"}},
    details = [[
Declare a rule. ⟨head⟩ should consist of a single symbol, which need not
have been declared using `\symbol` or exist as a default symbol (in
fact, the more interesting L-systems depend on using symbols with no
corresponding code, to control the "growth" of the system). ⟨body⟩
consists of a string of symbols, which again need not necessarily have
any code associated with them.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/rule"
  },
  savedanchor = {
    arguments = {{meta = "command"}, {meta = "code"}},
    details = [[
This command declares a saved anchor. The argument ⟨command⟩ should be a
TeX macro name like `\centerpoint`.

The ⟨code⟩ will be executed each time `\pgfnode` (or
`\pgfmultipartnode`) is called to create a node of the shape ⟨shape
name⟩. When the ⟨code⟩ is executed, the TeX-boxes of the node parts will
contain the text labels of the node. Possibly, these box are void. For
example, if there is just a `text` part, the node `\pgfnodeparttextbox`
will be set up when the ⟨code⟩ is executed.

The ⟨code⟩ can use the width, height, and depth of the box(es) to
compute the location of the saved anchor. In addition, the ⟨code⟩ can
take into account the values of dimensions like `\pgfshapeminwidth` or
`\pgfshapeinnerxsep`. Furthermore, the ⟨code⟩ can take into
consideration the values of any further shape-specific variables that
are set at the moment when `\pgfnode` is called.

The net effect of the ⟨code⟩ should be to set the two TeX dimensions
`\pgf@x` and `\pgf@y`. One way to achieve this is to say `\pgfpoint{`⟨x
value⟩`}{`⟨y value⟩`}` at the end of the ⟨code⟩, but you can also just
set these variables. The values that `\pgf@x` and `\pgf@y` have after
the code has been executed, let us call them $x$ and $y$, will be
recorded and stored together with the node that is created by the
command `\pgfnode`.

The macro ⟨command⟩ is defined to be `\pgfpoint{`$x$`}{`$y$`}`. However,
the ⟨command⟩ is only locally defined while anchor positions are being
computed. Thus, it is possible to use very simple names for ⟨command⟩,
like `\center` or `\a`, without causing a name-clash. (To be precise,
very simple ⟨command⟩ names will clash with existing names, but only
locally inside the computation of anchor positions; and we do not need
the normal `\center` command during these computations.)

For our `simple rectangle` shape, we will need only one saved anchor:
The upper right corner. The lower left corner could either be the origin
or the "mirrored" upper right corner, depending on whether we want the
text label to have its lower left corner at the origin or whether the
text label should be centered on the origin. Either will be fine, for
the final shape this will make no difference since the shape will be
shifted anyway. So, let us assume that the text label is centered on the
origin (this will be specified later on using the `text` anchor). We get
the following code for the upper right corner:

    \savedanchor{\upperrightcorner}{
      \pgf@y=.5\ht\pgfnodeparttextbox % height of the box, ignoring the depth
      \pgf@x=.5\wd\pgfnodeparttextbox % width of the box
    }

If we wanted to take, say, the `\pgfshapeminwidth` into account, we
could use the following code:

    \savedanchor{\upperrightcorner}{
      \pgf@y=.\ht\pgfnodeparttextbox % height of the box
      \pgf@x=.\wd\pgfnodeparttextbox % width of the box
      \setlength{\pgf@xa}{\pgfshapeminwidth}
      \ifdim\pgf@x<.5\pgf@xa
        \pgf@x=.5\pgf@xa
      \fi
    }

Note that we could not have written `.5\pgfshapeminwidth` since the
minimum width is stored in a "plain text macro", not as a real
dimension. So if `\pgfshapeminwidth` depth were 2cm, writing
`.5\pgfshapeminwidth` would yield the same as `.52cm`.

In the "real" `rectangle` shape the code is somewhat more complex, but
you get the basic idea.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/savedanchor"
  },
  saveddimen = {
    arguments = {{meta = "command"}, {meta = "code"}},
    details = [[
This command is similar to `\savedanchor`, only instead of setting
⟨command⟩ to `\pgfpoint{`$x$`}{`$y$`}`, the ⟨command⟩ is set just to
(the value of) $x$.

In the `simple rectangle` shape we might use a saved dimension to store
the depth of the shape box.

    \saveddimen{\depth}{
      \pgf@x=\dp\pgfnodeparttextbox
    }
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/saveddimen"
  },
  savedmacro = {
    arguments = {{meta = "command"}, {meta = "code"}},
    details = [[
This command is similar to `\saveddimen`, only at some point in ⟨code⟩,
⟨command⟩ should be defined appropriately, (this could be a value, or
some text).

In the `regular polygon` shape, a saved macro is used to store the
number of sides of the polygon.

    \savedmacro{\sides}{\let\sides\pgfpolygonsides}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/savedmacro"
  },
  scoped = {
    arguments = {
      {meta = "animations spec"},
      {
        delimiters = {"[", "]"},
        keys = "$ref:tikz#/keys/tikz",
        meta = "options",
        optional = true
      },
      {meta = "path command"}
    },
    details = [[
This command works like `\tikz`, only you can use it inside a
`{tikzpicture}`. It will take the following ⟨path command⟩ and put it
inside a `{scope}` with the ⟨options⟩ set. The ⟨path command⟩ may either
be a single command ended by a semicolon or it may contain multiple
commands, but then they must be surrounded by curly braces.

    \begin{tikzpicture}
      \node [fill=white] at (1,1) {Hello world};
      \scoped [on background layer]
        \draw (0,0) grid (3,2);
    \end{tikzpicture}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/scoped"
  },
  shade = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
Causes the path to be shaded using the currently selected shading (more
on this later). If this option is used together with the `draw` option,
then the path is first shaded, then drawn.

It is not an error to use this option together with the `fill` option,
but it makes no sense.

    \tikz \shade (0,0) circle (1ex);

    \tikz \shadedraw (0,0) circle (1ex);
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/shade",
    summary = "Inside `{tikzpicture}` this is an abbreviation for `\\path[shade]`."
  },
  shadedraw = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
Inside `{tikzpicture}` this is an abbreviation for `\path[shade,draw]`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/shadedraw"
  },
  spy = {
    arguments = {
      {
        delimiters = {"[", "]"},
        keys = "$ref:tikz#/keys/tikz",
        meta = "options",
        optional = true
      },
      {literal = "on"},
      {meta = "coordinate"}
    },
    details = [[
This command can only be used inside a `spy scope`. Let us start with
the syntax:

-   The `\spy` command is not a special case of `\path`. Rather, it has
    a small parser of its own.

-   Following the optional ⟨options⟩, you must write `on`, followed by a
    coordinate. This coordinate will be the center of the area that is
    to be magnified.

-   Following the ⟨coordinate⟩, you must write `in node` followed by
    some ⟨node options⟩. The syntax for these options is the same as for
    a normal `node` path command, such as `[left]` or
    `(foo) [red] at (bar)`. *However*, ⟨node options⟩ are *not* followed
    by a curly brace. Rather, the ⟨node options⟩ must directly be
    followed by a semicolon.

The effect of this command is the following: The ⟨options⟩,
⟨coordinate⟩, and ⟨node options⟩ are stored internally till the end of
the current `spy scope`. This means that, in particular, you can
reference any node inside the `spy scope`, even if it is not yet defined
when the `\spy` command is given. At the end of the current `spy scope`,
two nodes are created, called the *spy-in node* and the *spy-on node*.

-   The *spy-in node* is the node that contains a magnified part of the
    picture (the node *in* which we see on what we spy). This node is,
    indeed, a normal TikZ node, so you can use all standard options to
    style this node. In particular, you can specify a shape or a border
    color or a drop shadow or whatever. The only thing that is special
    about this node is that instead of containing some normal text, its
    "text" is the magnified picture.

    To be precise, the picture of the `spy scope` is scaled by a certain
    factor, specified by the `lens` or `magnification` options discussed
    below, and is shifted in such a way that the ⟨coordinate⟩ lies at
    the center of the spy-on node.

-   The *spy-on node* is a node that is centered on the ⟨coordinate⟩ and
    whose size reflects exactly the area shown inside the spy-in node
    (the node containing *on* what we spy).

Let us now go over what happens in detail when the two nodes are
created:

1.  A scope is started. Two sets of options are used with this scope:
    First, the options passed to the enclosing `spy scope` and then the
    ⟨options⟩ (which will, thus, overrule the options of the
    `spy scope`).

2.  Then, the spy-on node is created. However, we will first discuss the
    spy-in node.

3.  The spy-in node is created after the spy-on node (and, hence, will
    cover the spy-on node in case they overlap). When this node is
    created, the ⟨node options⟩ are used in addition to the effect
    caused by the ⟨options⟩ and the options of the `{spy scope}`.
    Additionally, the following style is used:

    The position of the node (the `at` option) is set to the
    ⟨coordinate⟩ by default, so that it will cover the to-be-magnified
    area. You can change this by providing the `at` option yourself:

        \begin{tikzpicture}
          [spy using outlines={circle, magnification=3, size=1cm}]

          \draw [decoration=Koch curve type 1]
            decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

          \spy [red]  on (1.6,0.3) in node;
          \spy [blue] on (1,1)     in node at (1,-1);
        \end{tikzpicture}

    No "text" can be specified for the node. Rather, the "text" shown
    inside this node is the picture of the current `spy scope`, but
    canvas-transformed according to the following key:

    Since the most common transformation is undoubtedly a simple
    scaling, there is a special style for this:

    Now, usually the size of a node is determined in such a way that it
    "fits" around the text of the node. For a spy-on node this is not a
    good approach since the "text" of this node would contain "the whole
    picture". Because of this, TikZ acts as if the "text" of the node
    has zero size. You must then use keys like `minimum size` to cause
    the node to have a certain size. Note that the key `size` is an
    abbreviation for `minimum size` inside a spy scope.

    You can name the spy-on node in the usual ways. Additionally, the
    node is (also) always named `tikzspyinnode`. Following the spy
    scope, you can use this node like any other node:

        \begin{tikzpicture}
          \begin{scope}
            [spy using outlines={circle, magnification=3, size=2cm, connect spies}]

            \draw [decoration=Koch curve type 1]
              decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

            \spy [red] on (1.6,0.3) in node (a) [left] at (3.5,-1.25);

            \spy [blue, size=1cm] on (1,1) in node (b) [right] at (0,-1.25);
          \end{scope}
          \draw [ultra thick, green!50!black] (b) -- (a.north west);
        \end{tikzpicture}

4.  Once both nodes have been created, the current value of the
    following key is used to connect them:

Returning to the creation of the spy-in node: This node is centered on
⟨coordinate⟩ (more precisely, its anchor is set to `center` and the `at`
option is set to ⟨coordinate⟩). Its size and shape are initially
determined in the same way as the size and shape of the spy-on node
(unless, of course, you explicitly provide a different shape for, say,
the spy-on node locally, which is not really a good idea). Then,
additionally, the *inverted* transformation done by the `lens` option is
applied, resulting in a node whose size and shape exactly corresponds to
the area in the picture that is shown in the spy-on node.

    \begin{tikzpicture}
      [spy using outlines={lens={scale=3,rotate=20}, size=2cm, connect spies}]

      \draw [decoration=Koch curve type 1]
        decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

      \spy [red] on (1.6,0.3) in node at (2.5,-1.25);
    \end{tikzpicture}

Like for the spy-in node, a style can be used to format the spy-on node:

The spy-on node is named `tikzspyonnode` (but, as always, this node is
only available after the spy scope). If you have multiple spy-on nodes
and you would like to access all of them, you need to use the `name` key
inside the `every spy on node` style.

The `inner sep` and `outer sep` of both spy-in and spy-on nodes are set
to `0pt`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/spy"
  },
  state = {
    arguments = {
      {meta = "name"},
      {
        delimiters = {"[", "]"},
        keys = "$ref:tikz#/keys/tikz",
        meta = "options",
        optional = true
      },
      {meta = "code"}
    },
    details = [[
Declares the state ⟨name⟩ inside the current meta-decoration automaton.
Unlike decorations, states in meta-decorations are not executed within a
group, which makes the persistent computation options superfluous.
Consider using an initial state with `width=0pt` to do precalculations
that could speed the execution of the meta-decoration.

The ⟨options⟩ are executed with the key path set to
`/pgf/meta-decorations automaton/`, and the following keys are defined
for this path:

The code in ⟨code⟩ is quite different from the code in a decoration
state. In almost all cases only the following three macros will be
required:

There are some macros that may be useful when creating meta-decorations
(note that they are all macros):
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/state"
  },
  symbol = {
    arguments = {{meta = "name"}, {meta = "code"}},
    details = [[
This defines a symbol called ⟨name⟩ for a specific L-system, and
associates it with ⟨code⟩.

A symbol should consist of a single alpha-numeric character (i.e.,
`A`-`Z`, `a`-`z` or `0`-`9`). The symbols `F`, `f`, `+`, `-`, `[` and
`]` are available by default so do not need to be defined for each
L-system. However, if you are feeling adventurous, they can be redefined
for specific L-systems if required. The L-system treats the default
symbols as follows (the commands they execute are described below):

-   `F` move forward a certain distance, drawing a line. Uses
    `\pgflsystemdrawforward`.

-   `f` move forward a certain distance, without drawing a line. Uses
    `\pgflsystemmoveforward`.

-   `+` turn left by some angle. Uses `\pgflsystemturnleft`.

-   `-` turn right by some angle. Uses `\pgflsystemturnright`.

-   `[` save the current state (i.e., the position and direction). Uses
    `\pgflsystemsavestate`.

-   `]` restore the last saved state. Uses `\pgflsystemrestorestate`.

The symbols `[` and `]` act like a stack: `[` pushes the state of the
L-system on to the stack, and `]` pops a state off the stack.

When ⟨code⟩ is executed, the transformation matrix is set up so that the
origin is at the current position and the positive x-axis "points
forward", so `\pgfpathlineto{\pgfpoint{1cm}{0cm}}` draws a line 1cm
forward.

The following keys can alter the production of an L-system. However,
they do not store values in themselves.

For speed and convenience, when the code for a symbol is executed, the
following commands are available.

The following commands may be useful if you wish to define your own
symbols.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/symbol"
  },
  tikz = {
    arguments = {
      {meta = "animations spec"},
      {
        delimiters = {"[", "]"},
        keys = "$ref:tikz#/keys/tikz",
        meta = "options",
        optional = true
      },
      {meta = "path commands"}
    },
    details = [[
This command places the ⟨path commands⟩ inside a `{tikzpicture}`
environment. The ⟨path commands⟩ may contain paragraphs and fragile
material (like verbatim text).

If there is only one path command, it need not be surrounded by curly
braces, if there are several, you need to add them (this is similar to
the `\foreach` statement and also to the rules in programming languages
like Java or C concerning the placement of curly braces).

`\tikz{\draw (0,0) rectangle (2ex,1ex);}` yields \[PICTURE\]

`\tikz \draw (0,0) rectangle (2ex,1ex);` yields \[PICTURE\]
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikz"
  },
  tikzaliascoordinatesystem = {
    arguments = {{meta = "new name"}, {meta = "old name"}},
    details = [[
Creates an alias of ⟨old name⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzaliascoordinatesystem"
  },
  tikzappendtofigurename = {
    arguments = {{meta = "suffix"}},
    details = [[
Appends ⟨suffix⟩ to the actual value of `figure name`.

It is a shortcut for
`\tikzset{external/figure name/.add={}``{suffix}``}` (a shortcut which
is also supported if TikZ is not installed, see below).
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzappendtofigurename"
  },
  tikzdeclarecoordinatesystem = {
    arguments = {{meta = "name"}, {meta = "code"}},
    details = [[
This command declares a new coordinate system named ⟨name⟩ that can
later on be used by writing `(`⟨name⟩` cs:`⟨arguments⟩`)`. When
TikZ encounters a coordinate specified in this way, the ⟨arguments⟩ are
passed to ⟨code⟩ as argument `# 1`.

It is now the job of ⟨code⟩ to make sense of the ⟨arguments⟩. At the end
of ⟨code⟩, the two TeX dimensions `\pgf@x` and `\pgf@y` should be have
the $x$- and $y$-canvas coordinate of the coordinate.

It is not necessary, but customary, to parse ⟨arguments⟩ using the
key--value syntax. However, you can also parse it in any way you like.

In the following example, a coordinate system `cylindrical` is defined.

    \makeatletter
    \define@key{cylindricalkeys}{angle}{\def\myangle{#1}}
    \define@key{cylindricalkeys}{radius}{\def\myradius{#1}}
    \define@key{cylindricalkeys}{z}{\def\myz{#1}}
    \tikzdeclarecoordinatesystem{cylindrical}%
    {%
      \setkeys{cylindricalkeys}{#1}%
      \pgfpointadd{\pgfpointxyz{0}{0}{\myz}}{\pgfpointpolarxy{\myangle}{\myradius}}
    }
    \begin{tikzpicture}[z=0.2pt]
      \draw [->] (0,0,0) -- (0,0,350);
      \foreach \num in {0,10,...,350}
        \fill (cylindrical cs:angle=\num,radius=1,z=\num) circle (1pt);
    \end{tikzpicture}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzdeclarecoordinatesystem"
  },
  tikzdeclarepattern = {
    arguments = {{meta = "config"}},
    details = [[
A pattern declared with `\pgfdeclarepattern` can only execute PGF code.
This command extends the functionality to also allow TikZ code. All the
same keys of `\pgfdeclarepattern` are valid, but some of them have been
overloaded to give a more natural TikZ syntax.

In addition to the overloaded keys, some new keys have been added.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzdeclarepattern"
  },
  tikzdvdeclarestylesheetcolorseries = {
    arguments = {
      {meta = "name"},
      {meta = "color model"},
      {meta = "initial color"},
      {meta = "step"}
    },
    details = [[
This command creates a new style sheet using `\pgfdvdeclarestylesheet`.
This style sheet will only have a default style setup that maps numbers
to the color in the color series starting with ⟨initial color⟩ and
having a stepping of ⟨step⟩. Note that when the value of the attribute
is `1`, which it is the first data set, the *second* color in the color
series is used (since counting starts at `0` for color series). Thus, in
general, you need to start the ⟨initial color⟩ "one early".

        data point [x=2, y=2,       set=normal]
        data point [x=0, y=1,       set=heated]
        data point [x=2, y=1,       set=heated]
        data point [x=0.5, y=1.5,   set=critical]
        data point [x=2.25, y=1.75, set=critical]
    };},
    ]
    \tikzdvdeclarestylesheetcolorseries{greens}{hsb}{0.3,1.3,0.8}{0,-.4,-.1}
    \tikz \datavisualization [
      school book axes,
      visualize as line=normal,
      visualize as line=heated,
      visualize as line=critical,
      style sheet=greens]
    data group {lines};
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzdvdeclarestylesheetcolorseries"
  },
  tikzexternaldisable = {
    details = [[
Allows to disable the complete externalization. While `export next` will
still collect the contents of picture environments, this command
uninstalls the hooks for the `external` library completely. Thus, nested
picture environments or environments where `\end{tikzpicture}` is not
directly reachable won't produce compilation failures -- although it is
not possible to externalize them automatically.

The externalization remains disabled until the end of the next TeX group
(or environment) or until the next call to `\tikzexternalenable`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzexternaldisable"
  },
  tikzexternalenable = {
    details = [[
Re-enables a previously running externalization after
`\tikzexternaldisable`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzexternalenable"
  },
  tikzexternalfiledependsonfile = {
    arguments = {{meta = "external graphics"}, {meta = "file name"}},
    details = [[
A variant of `\tikzpicturedependsonfile` which adds a dependency for an
⟨external graphics⟩. The argument ⟨external graphics⟩ must be the path
as it would have been generated by the `external` library, i.e. without
file extension but including any prefixes.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzexternalfiledependsonfile"
  },
  tikzexternalize = {
    arguments = {
      {
        delimiters = {"[", "]"},
        meta = "optional arguments",
        optional = true
      }
    },
    details = [[
This command activates the externalization. It installs commands to
replace every TikZ-picture. It needs to be called before
`\begin{document}` because it may need to install its separate shipout
routine.

The ⟨optional arguments⟩ can be any of the keys described below.

Note that the generation/modification of auxiliary files like `.aux`,
`.toc` etc. is usually suppressed while a single image is externalized
(details for `\label` support follow).

It is also possible to write `\tikzexternalize``{main job name}` if the
argument is delimited by curly braces. This case is mainly for backwards
compatibility and is no longer necessary. Since it might be useful in
rare circumstances, it is documented in section ??.

A detailed description about the process of externalization is provided
in section ??.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzexternalize"
  },
  tikzexternalrealjob = {
    details = [[
After the library is loaded, this macro will *always* contain the
correct main job's name (in the example above, it is `main`). It is to
be used instead of `\jobname` when the externalization is in effect.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzexternalrealjob"
  },
  tikzfading = {
    arguments = {
      {
        delimiters = {"[", "]"},
        keys = "$ref:tikz#/keys/tikz",
        meta = "options",
        optional = true
      }
    },
    details = [[
This command is used to define a fading similarly to the way a shading
is defined. In the ⟨options⟩ you should

1.  use the `name=`⟨name⟩ option to set a name for the fading,

2.  use the `shading` option to set the name of the shading that you
    wish to use,

3.  extra options for setting the colors of the shading (typically you
    will set them to the color `transparent!`⟨percentage⟩).

Then, a new fading named ⟨name⟩ will be created based on the shading.

    \tikzfading[name=fade right,
                left color=transparent!0,
                right color=transparent!100]

    % Now we use the fading in another picture:
    \begin{tikzpicture}
      % Background
      \fill [black!20] (-1.2,-1.2) rectangle (1.2,1.2);
      \path [pattern=checkerboard,pattern color=black!30]
                       (-1.2,-1.2) rectangle (1.2,1.2);

      \fill [red,path fading=fade right] (-1,-1) rectangle (1,1);
    \end{tikzpicture}

    \tikzfading[name=fade out,
                inner color=transparent!0,
                outer color=transparent!100]

    % Now we use the fading in another picture:
    \begin{tikzpicture}
      % Background
      \fill [black!20] (-1.2,-1.2) rectangle (1.2,1.2);
      \path [pattern=checkerboard,pattern color=black!30]
                       (-1.2,-1.2) rectangle (1.2,1.2);

      \fill [blue,path fading=fade out] (-1,-1) rectangle (1,1);
    \end{tikzpicture}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzfading"
  },
  tikzgraphforeachcolorednode = {
    arguments = {{meta = "color name"}, {meta = "macro"}},
    details = [[
When this command is called inside ⟨code⟩, the following will happen:
TikZ will iterate over all nodes inside the just-specified group that
have the color ⟨color name⟩. The order in which they are iterated over
is the order in which they appear inside the group specification (if a
node is encountered several times inside the specification, only the
first occurrence counts). Then, for each node the ⟨macro⟩ is executed
with the node's name as the only argument.

In the following example we use an operator to connect every node
colored `all` inside the subgroup to he node `root`.

    \def\myconnect#1{\tikzset{graphs/new ->={root}{#1}{}{}}}

    \begin{tikzpicture}
      \node (root) at (-1,-1) {root};

      \graph {
        x,
        {
          [operator=\tikzgraphforeachcolorednode{all}{\myconnect}]
          a, b, c
        }
      };
    \end{tikzpicture}
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzgraphforeachcolorednode"
  },
  tikzgraphnodefullname = {
    details = [[
This macro contains the concatenation of the above two.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzgraphnodefullname"
  },
  tikzgraphnodename = {
    details = [[
This macro expands to the name of the current node without the path.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzgraphnodename"
  },
  tikzgraphnodepath = {
    details = [[
This macro expands to the current path of the node. These paths result
from the use of the `name` key as described above.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzgraphnodepath"
  },
  tikzgraphnodetext = {
    details = [[
This macro expands to the ⟨text⟩ to the right of the double underscore
or slash in a direct node specification or, if there is no slash, to the
⟨node name⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzgraphnodetext"
  },
  tikzgraphpreparecolor = {
    arguments = {{meta = "color name"}, {meta = "counter"}, {meta = "prefix"}},
    details = [[
This command is used to "prepare" the nodes of a certain color for
random access. The effect is the following: It is counted how many nodes
there are having color ⟨color name⟩ in the current group and the result
is stored in ⟨counter⟩. Next, macros named ⟨prefix⟩`1`, ⟨prefix⟩`2`, and
so on are defined, that store the names of the first, second, third, and
so on node having the color ⟨color name⟩.

The net effect is that after you have prepared a color, you can quickly
iterate over them. This is especially useful when you iterate over
several color at the same time.

As an example, let us create an operator then adds a zig-zag path
between two color classes:

    \newcount\leftshorecount   \newcount\rightshorecount
    \newcount\mycount          \newcount\myothercount
    \def\zigzag{
      \tikzgraphpreparecolor{left shore}\leftshorecount{left shore prefix}
      \tikzgraphpreparecolor{right shore}\rightshorecount{right shore prefix}
      \mycount=0\relax
      \loop
        \advance\mycount by 1\relax%
        % Add the "forward" edge
        \tikzgraphsset{new ->=
          {\csname left shore prefix\the\mycount\endcsname}
          {\csname right shore prefix\the\mycount\endcsname}{}{}}
        \myothercount=\mycount\relax%
        \advance\myothercount by1\relax%
        \tikzgraphsset{new <-=
          {\csname left shore prefix\the\myothercount\endcsname}
          {\csname right shore prefix\the\mycount\endcsname}{}{}}
      \ifnum\myothercount<\leftshorecount\relax
      \repeat
    }
    \begin{tikzpicture}
      \graph [color class=left shore, color class=right shore]
      { [operator=\zigzag]
        { [left shore, Cartesian placement]                      a, b, c },
        { [right shore, Cartesian placement, nodes={xshift=1cm}] d, e, f }
      };
    \end{tikzpicture}

Naturally, in order to turn the above code into a usable operator, some
more code would be needed (like default values and taking care of shores
of different sizes).
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzgraphpreparecolor"
  },
  tikzgraphsset = {
    arguments = {{keys = "$ref:tikz#/keys/tikz", meta = "options"}},
    details = [[
Executes the ⟨options⟩ with the path prefix `/tikz/graphs`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzgraphsset"
  },
  tikzifexternalizing = {
    arguments = {{meta = "true code"}, {meta = "false code"}},
    details = [[
This command can be used to check whether an image is currently written
to its separate graphics file (if the "grab" procedure is running). If
so, the `{true code}` will be executed. If not, that means if the main
document is being typeset normally, the `{false code}` will be invoked.

This command must be used *after* `\tikzexternalize`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzifexternalizing"
  },
  tikzifexternalizingnext = {
    arguments = {{meta = "true code"}, {meta = "false code"}},
    details = [[
Like `\tikzifexternalizing`, but this variant also checks if the next
following figure is the one which is about to be written to its separate
graphics file.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzifexternalizingnext"
  },
  tikzinputsegmentfirst = {
    details = [[
The first point on the current input segment path.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzinputsegmentfirst"
  },
  tikzinputsegmentlast = {
    details = [[
The last point on the current input segment path.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzinputsegmentlast"
  },
  tikzinputsegmentsupporta = {
    details = [[
The first support on the curveto input segment path.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzinputsegmentsupporta"
  },
  tikzinputsegmentsupportb = {
    details = [[
The second support on the curveto input segment path.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzinputsegmentsupportb"
  },
  tikzlastnode = {
    details = [[
Expands to the last node on the path.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzlastnode"
  },
  tikzmath = {
    details = [[
This command process a series of ⟨statements⟩ which can represent
assignments, function definitions, conditional evaluation, and
iterations. It provides, in effect, a miniature mathematical language to
perform basic mathematical operations. Perhaps the most important thing
to remember is that *every statement should end with a semi-colon*. This
is likely to be the most common reason why the `\tikzmath` command
fails.

    \tikzmath{
      % Adapted from http://www.cs.northwestern.edu/academics/courses/110/html/fib_rec.html
      function fibonacci(\n) {
        if \n == 0 then {
          return 0;
        } else {
           return fibonacci2(\n, 0, 1);
         };
      };
      function fibonacci2(\n, \p, \q) {
        if \n == 1 then {
          return \q;
        } else {
          return fibonacci2(\n-1, \q, \p+\q);
        };
      };
      int \f, \i;
      for \i in {0,1,...,20} {
        \f = fibonacci(\i);
        print {\f, };
      };
    }
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzmath"
  },
  tikzpicturedependsonfile = {
    arguments = {{meta = "file name"}},
    details = [[
Adds a dependency for the *next* picture which is about to be
externalized. If the command is invoked within a picture environment, it
adds a dependency for the surrounding picture. Dependencies are written
into ⟨target file⟩`.dep` in the format

⟨target file⟩`.\tikzexternalimgextension: `⟨file name⟩.

The effect is that if ⟨file name⟩ changes, the external graphics
associated with the picture shall be remade.

This command uses the contents of `\tikzexternalimgextension` to check
for graphics. If you encounter difficulties with image extensions,
consider redefining this macro (after `\tikzexternalize`).

#### Limitations:

this command is currently only supported for `mode=list and make` and
the generated `makefile`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzpicturedependsonfile"
  },
  tikzrdfhashmark = {
    details = [[
Expands to `# ` with catcode 11.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzrdfhashmark"
  },
  tikzset = {
    arguments = {{keys = "$ref:tikz#/keys/tikz", meta = "options"}},
    details = [[
This command will process the ⟨options⟩ using the `\pgfkeys` command,
documented in detail in Section ??, with the default path set to
`/tikz`. Under normal circumstances, the ⟨options⟩ will be lists of
comma-separated pairs of the form ⟨key⟩`=`⟨value⟩, but more fancy things
can happen when you use the power of the `pgfkeys` mechanism, see
Section ?? once more.

When a pair ⟨key⟩`=`⟨value⟩ is processed, the following happens:

1.  If the ⟨key⟩ is a full key (starts with a slash) it is handled
    directly as described in Section ??.

2.  Otherwise (which is usually the case), it is checked whether
    `/tikz/`⟨key⟩ is a key and, if so, it is executed.

3.  Otherwise, it is checked whether `/pgf/`⟨key⟩ is a key and, if so,
    it is executed.

4.  Otherwise, it is checked whether ⟨key⟩ is a color and, if so,
    `color=`⟨key⟩ is executed.

5.  Otherwise, it is checked whether ⟨key⟩ contains a dash and, if so,
    `arrows=`⟨key⟩ is executed.

6.  Otherwise, it is checked whether ⟨key⟩ is the name of a shape and,
    if so, `shape=`⟨key⟩ is executed.

7.  Otherwise, an error message is printed.

Note that by the above description, all keys starting with `/tikz` and
also all keys starting with `/pgf` can be used as ⟨key⟩s in an ⟨options⟩
list.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzset"
  },
  tikzsetexternalprefix = {
    arguments = {{meta = "file name prefix"}},
    details = [[
Assigns a common prefix used by all file names. For example,

    \tikzsetexternalprefix{figures/}

will prepend `figures/` to every external graphics file name.

Please note that `\tikzsetexternalprefix` is the *only* way to assign a
prefix in case you want to prepare your document for environments where
PGF is not installed (see section ??).
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzsetexternalprefix"
  },
  tikzsetfigurename = {
    arguments = {{meta = "name"}},
    details = [[
Changes the names of *all* following figures. It is possible to change
`figure name` during the document either using
`\tikzset{external/figure name`=`{name}``}` or with this command. A
unique counter will be used for each different `{name}`, and each
counter will start at $0$.

The value of `prefix` will be applied after `figure name` has been
evaluated.

    \documentclass{article}
    % main document, called main.tex
    \usepackage{tikz}

    \usetikzlibrary{external}
    \tikzexternalize % activate

    \begin{document}

    \begin{tikzpicture} % will be written to 'main-figure0.pdf'
      \node {root}
        child {node {left}}
        child {node {right}
          child {node {child}}
          child {node {child}}
        };
    \end{tikzpicture}

    {
      \tikzsetfigurename{subset_}
      A simple image is \tikz \fill (0,0) circle(5pt);. % will be written to 'subset_0.pdf'

      \begin{tikzpicture} % will be written to 'subset_1.pdf'
         \draw[help lines] (0,0) grid (5,5);
      \end{tikzpicture}
    }% here, the old file name will be restored:

    \begin{tikzpicture} % will be written to 'main-figure1.pdf'
       \draw (0,0) -- (5,5);
    \end{tikzpicture}
    \end{document}

The scope of `figure name` ends with the next closing brace.

Remark: Use `\tikzset{external/figure name/.add={prefix_ }{_ suffix_ }}`
to add a `prefix_ ` and a `_ suffix_ ` to the actual value of
`figure name`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzsetfigurename"
  },
  tikzsetnextfilename = {
    arguments = {{meta = "file name"}},
    details = [[
Sets the file name for the *next* TikZ picture or `\tikz` short command.
It will *only* be used for the next picture.

Pictures for which no explicit file name has been set (or the next file
name is empty) will get automatically generated file names.

Please note that `prefix` will still be prepended to `{file name}`.

    \documentclass{article}
    % main document, called main.tex
    \usepackage{tikz}

    \usetikzlibrary{external}
    \tikzexternalize[prefix=figures/] % activate

    \begin{document}

    \tikzsetnextfilename{trees}
    \begin{tikzpicture} % will be written to 'figures/trees.pdf'
      \node {root}
        child {node {left}}
        child {node {right}
          child {node {child}}
          child {node {child}}
        };
    \end{tikzpicture}

    \tikzsetnextfilename{simple}
    A simple image is \tikz \fill (0,0) circle(5pt);. % will be written to 'figures/simple.pdf'

    \begin{tikzpicture} % will be written to 'figures/main-figure0.pdf'
       \draw[help lines] (0,0) grid (5,5);
    \end{tikzpicture}
    \end{document}

    pdflatex -shell-escape main
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/tikzsetnextfilename"
  },
  useasboundingbox = {
    action = "tikzpath",
    arguments = {{delimiters = {"", ";"}, meta = "specification"}},
    details = [[
Inside `{tikzpicture}` this is an abbreviation for
`\path[use as bounding box]`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/useasboundingbox"
  },
  usegdlibrary = {
    arguments = {{meta = "list of libraries"}},
    details = [[
This command is used to load the special graph drawing libraries (the
`gd` in the name of the command stands for "graph drawing"). The ⟨list
of libraries⟩ is a comma-separated list of library written in the Lua
programming language (which is why a special command is needed).

In detail, this command does the following. For each ⟨name⟩ in the ⟨list
of libraries⟩ we do:

1.  Check whether LuaTeX can call `require` on the library file
    `pgf.gd.`⟨name⟩`.library`. LuaTeX's usual file search mechanism will
    search the texmf-trees in the usual manner and the dots in the file
    name get converted into directory slashes.

2.  If the above failed, try to `require` the string `pgf.gd.`⟨name⟩.

3.  If this fails, try to `require` the string ⟨name⟩`.library`.

4.  If this fails, try to `require` the string ⟨name⟩. If this fails,
    print an error message.

The net effect of the above is the following: Authors of graph drawing
algorithms can bundle together multiple algorithms in a library by
creating a `...xyz/library.lua` file that internally just calls
`require` for all files containing declarations. On the other hand, if a
graph drawing algorithm completely fits inside a single file, it can
also be read directly using `\usegdlibrary`.

    \usetikzlibrary{graphdrawing}
    \usegdlibrary{trees,force}

The different graph drawing libraries are documented in the following
Sections ?? to ??.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/usegdlibrary"
  },
  usetikzlibrary = {
    arguments = {{meta = "list of libraries", list=true}},
    action="input", filename="tikzlibrary?.code.tex",
    details = [[
Once TikZ has been loaded, you can use this command to load further
libraries. The list of libraries should contain the names of libraries
separated by commas. Instead of curly braces, you can also use square
brackets, which is something ConTeXt users will like. If you try to load
a library a second time, nothing will happen.

`\usetikzlibrary{arrows.meta}`

The above command will load a whole bunch of extra arrow tip
definitions.

What this command does is to load the file
`tikzlibrary`⟨library⟩`.code.tex` for each ⟨library⟩ in the ⟨list of
libraries⟩. If this file does not exist, the file
`pgflibrary`⟨library⟩`.code.tex` is loaded instead. If this file also
does not exist, an error message is printed. Thus, to write your own
library file, all you need to do is to place a file of the appropriate
name somewhere where TeX can find it. LaTeX, plain TeX, and ConTeXt
users can then use your library.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/usetikzlibrary"
  },
  value = {
    arguments = {{meta = "variable"}},
    details = [[
This expands to the current value of the key `/data point/`⟨variable⟩.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/value"
  },
  x = {
    arguments = {{meta = "point register"}},
    details = [[
This macro expands just to the $x$-part of the point register. If we say
as above, as we did above, `let \p1=(1pt,1pt+2pt) in ...`, then inside
the `...` part the macro `\x1` expands to `1pt`.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/x"
  },
  y = {
    arguments = {{meta = "point register"}},
    details = [[
Works like `\x`, only for the $y$-part.
]],
    documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf.back/y"
  }
}
keys = {
  ["data visualization"] = {
    about = {
      details = [[
This key asks the data visualization to place *about* ⟨number⟩ many
ticks on an axis. It is not guaranteed that *exactly* ⟨number⟩ many
ticks will be used, rather the actual number will be the closest number
of ticks to ⟨number⟩ so that their stepping is still "good". For
instance, when you say `about=10`, it may happen that exactly `10`, but
perhaps even `13` ticks are actually selected, provided that these
numbers of ticks lead to good stepping values like `5` or `2.5` rather
than numbers like `3.4` or `7`. The method that is used to determine
which steppings a deemed to be "good" depends on the current tick
placement strategy.

**Linear steps.** Let us start with `linear steps`: First, the
difference between the maximum value $v_{\max}$ and the minimum value
$v_{\min}$ on the axis is computed; let us call it $r$ for "range".
Then, $r$ is divided by ⟨number⟩, yielding a target stepping $s$. If $s$
is a number like $1$ or $5$ or $10$, then this number could be used
directly as the new value of `step`. However, $s$ will typically
something strange like $0.023\,45$ or $345\,223.76$, so $s$ must be
replaced by a better value like $0.02$ in the first case and perhaps
$250\,000$ in the second case.

In order to determine which number is to be used, $s$ is rewritten in
the form $m \cdot 10^k$ with $1 \le m < 10$ and $k \in \mathbb Z$. For
instance, $0.023\,45$ would be rewritten as $2.345 \cdot 10^{-2}$ and
$345\,223.76$ as $3.452\,2376 \cdot 10^5$. The next step is to replace
the still not-so-good number $m$ like $2.345$ or $3.452\,237$ by a
"good" value $m'$. For this, the current value of the `about strategy`
is used:

Once $m'$ has been determined, the stepping is set to
$s' = m' \cdot 10^k$.

The net effect of all this is that for the default strategy the only
valid stepping are the values $1$, $2$, $2.5$ and $5$ and every value
obtainable by multiplying one of these values by a power of ten. The
following example shows the effects of, first, setting `about=5`
(corresponding to the `some` option) and then having axes where the
minimum value is always `0` and where the maximum value ranges from `10`
to `100` and, second, setting `about` to the values from `3`
(corresponding to the `few` option) and to `10` (corresponding to the
`many` option) while having the minimum at `0` and the maximum at `100`:

**Exponential steps.** For `exponential steps` the strategy for
determining a good stepping value is similar to `linear steps`, but with
the following differences:

-   Naturally, since the stepping value refers to the exponent, the
    whole computation of a good stepping value needs to be done "in the
    exponent". Mathematically spoken, instead of considering the
    difference $r = v_{\max} - v_{\min}$, we consider the difference $r
                = \log v_{\max} - \log v_{\min}$. With this difference,
    we still compute $s = r / ⟨number⟩$ and let $s = m \cdot 10^k$ with
    $1
                \le m < 10$.

-   It makes no longer sense to use values like $2.5$ for $m'$ since
    this would yield a fractional exponent. Indeed, the only sensible
    values for $m'$ seem to be $1$, $3$, $6$, and $10$. Because of this,
    the `about strategy` is ignored and one of these values or a
    multiple of one of them by a power of ten is used.

The following example shows the chosen steppings for a maximum varying
from $10^1$ to $10^5$ and from $10^{10}$ to $10^{50}$ as well as for
$10^{100}$ for `about=3`:

**Alternative strategies.**

In addition to the standard `about strategy`, there are some additional
strategies that you might wish to use instead:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/about",
      meta = "⟨number⟩"
    },
    ["about strategy"] = {
      details = [[
The ⟨list⟩ is a comma-separated sequence of pairs ⟨threshold⟩/⟨value⟩
like for instance `1.5/1.0` or `2.3/2.0`. When a good value $m'$ is
sought for a given $m$, we iterate over the list and find the first pair
⟨threshold⟩/⟨value⟩ where ⟨threshold⟩ exceeds $m$. Then $m'$ is set to
⟨value⟩. For instance, if ⟨list⟩ is `1.5/1.0,2.3/2.0,4/2.5,7/5,11/10`,
which is the default, then for $m=3.141$ we would get $m'=2.5$ since
$4 >
        3.141$, but $2.3 \le 3.141$. For $m=6.3$ we would get $m'=5$.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/about:strategy",
      meta = "⟨list⟩"
    },
    ["after creation"] = {
      details = [[
This code is executed right after the object has just been created. A
handle to the just-created object is available in `\tikzdvobj`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/after:creation",
      meta = "⟨code⟩"
    },
    ["after survey"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/after:survey",
      meta = "⟨code⟩"
    },
    ["after visualization"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/after:visualization",
      meta = "⟨code⟩"
    },
    ["all axes"] = {
      details = [[
This key passes the ⟨options⟩ to all axes inside the current scope, just
as if you had written ⟨some axis name⟩`=`⟨options⟩ for each ⟨some axis
name⟩ in the current scope, including the just-created name ⟨axis name⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/all:axes",
      meta = "⟨options⟩"
    },
    ["also at"] = {
      details = [[
This key is similar to `at`, but it causes ticks or grid lines to be
placed at the positions in the ⟨list⟩ *in addition* to the ticks that
have already been specified either directly using `at` or indirectly
using keys like `step` or `some`. The effect of multiple calls of this
key accumulate. However, when `at` is used after an `also at` key, the
`at` key completely resets the positions where ticks or grid lines are
shown.

    \tikz \datavisualization
      [ school book axes, visualize as smooth line,
        x axis={grid, ticks and grid={major={also at={0.5}}}}]
      data [format=function] {
        var x : interval [-1.25:2];
        func y = \value x * \value x / 2;
      };

As for `at`, there are some shorthands available:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/also:at",
      meta = "⟨list⟩"
    },
    arg1 = {
      details = [[
The value to be passed as the first parameter to the constructor.
Similarly, the keys `arg2` to `arg8` specify further parameters passed.
Naturally, only as many arguments are passed as parameters are set. Here
is an example:

    \tikzdatavisualizationset{
      new object={
        class = example class,
        arg1  = foo,
        arg2  = \bar
      }
    }

causes the following object creation code to be executed later on:

    \pgfoonew \tikzdvobj=new example class(foo,\bar)

Note that you key mechanisms like `.expand once` to pass the value of a
macro instead of the macro itself:

    \tikzdatavisualizationset{
      new object={
        class              = example class,
        arg1               = foo,
        arg2/.expand once  = \bar
      }
    }

Now, if `\bar` is set to `This \emph{is} it.`at the moment to object is
created later on, the following object creation code is executed:

    \pgfoonew \tikzdvobj=new example class(foo,This \emph{is} it)
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/arg1",
      meta = "⟨value⟩"
    },
    ["arg1 from key"] = {
      details = [[
Works like the `arg1`, only the value that is passed to the constructor
is the current value of the specified ⟨key⟩ at the moment when the
object is created.

    \tikzdatavisualizationset{
      new object={
        class              = example class,
        arg1 from key      = /tikz/some key
      }
    }
    \tikzset{some key/.initial=foobar}

causes the following to be executed:

    \pgfoonew \tikzdvobj=new example class(foobar)

Naturally, the keys `arg2 from key` to `arg8 from key` are also
provided.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/arg1:from:key",
      meta = "⟨key⟩"
    },
    ["arg1 handle from key"] = {
      details = [[
Works like the `arg1 from key`, only the key must store an object and
instead of the object a handle to the object is passed to the
constructor.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/arg1:handle:from:key",
      meta = "⟨key⟩"
    },
    at = {
      details = [[
Basically, the ⟨list⟩ must be a list of values that is processed with
the `\foreach` macro (thus, it can contain ellipses to specify ranges of
value). Empty values are skipped.

The effect of passing `at` to a `major`, `minor`, or `subminor` key is
that ticks or grid lines on the axis will be placed exactly at the
values in ⟨list⟩. Here is an example:

    \tikz \datavisualization
      [ school book axes, visualize as smooth line,
        x axis={ticks={major={at={-1,0.5,(pi/2)}}}}]
      data [format=function] {
        var x : interval [-1.25:2];
        func y = \value x * \value x / 2;
      };

When this option is used, any previously specified tick positions are
overwritten by the values in ⟨list⟩. Automatically computed ticks are
also overwritten. Thus, this option gives you complete control over
where ticks should be placed.

Normally, the individual values inside the ⟨list⟩ are just numbers that
are specified in the same way as an attribute value. However, such a
value may also contain the keyword `as`, which allows you so specify the
styling of the tick in detail. Section ?? details how this works.

It is often a bit cumbersome that one has to write things like

    some axis = {ticks = {major = {at = {...}}}}

A slight simplification is given by the following keys, which can be
passed directly to `ticks` and `grid`:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/at",
      meta = "⟨list⟩"
    },
    ["at end survey"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/at:end:survey",
      meta = "⟨code⟩"
    },
    ["at end visualization"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/at:end:visualization",
      meta = "⟨code⟩"
    },
    ["at start survey"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/at:start:survey",
      meta = "⟨code⟩"
    },
    ["at start visualization"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/at:start:visualization",
      meta = "⟨code⟩"
    },
    ["axis layer"] = {
      details = [[
The layer on which the axis is drawn. See the description of
`grid layer` on page ?? for details.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:layer"
    },
    ["axis option/anchor at max"] = {
      details = [[
Like `anchor at min`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:option/anchor:at:max"
    },
    ["axis option/anchor at min"] = {
      details = [[
When passed to an axis, this key sets the `anchor` so that a node
positioned at either the `min` or the `padded min` value of the axis
will be placed "nicely" with respect to the axis. For instance, if the
axis points upwards from the `min` value to the `max` value, the
`anchor` would be set to `north` since this gives a label below the
axis's start. Similarly, if the axis points right, the anchor would be
set to `east`, and so on.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:option/anchor:at:min"
    },
    ["axis options/attribute"] = {
      details = [[
Specifies that the axis is used to transform the data points according
the different values of the key `/data point/`⟨attribute⟩. For instance,
when we create a classical two-dimensional Cartesian coordinate system,
then there are two axes called `x axis` and `y axis` that monitor the
values of the attributes `/data point/x` and `/data point/y`,
respectively:

      [new axis base=x axis,
       new axis base=y axis,
       x axis={attribute=x},
       y axis={attribute=y}]

In another example, we also create an `x axis` and a `y axis`. However,
this time, we want to plot the values of the `/data point/time`
attribute on the $x$-axis and, say, the value of the `height` attribute
on the $y$-axis:

      [new axis base=x axis,
       new axis base=y axis,
       x axis={attribute=time},
       y axis={attribute=height}]

During the data visualization, the ⟨attribute⟩ will be "monitored"
during the survey phase. This means that for each data point, the
current value of `/data point/`⟨attribute⟩ is examined and the minimum
value of all of these values as well as the maximum value is recorded
internally. Note that this works even when very large numbers like
`100000000000` are involved.

Here is a real-life example. The `scientific axes` create two axes,
called `x axis` and `y axis`, respectively.

    \tikz \datavisualization [scientific axes,
                              x axis={attribute=people, length=2.5cm, ticks=few},
                              y axis={attribute=year},
                              visualize as scatter]
      data {
        year, people
        1900, 100
        1910, 200
        1950, 200
        1960, 250
        2000, 150
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/attribute",
      meta = "⟨attribute⟩"
    },
    ["axis options/degrees"] = {
      details = [[
When this key is passed to the angle axis of a polar axis system, it
sets up the scaling so that a value of `360` on this axis corresponds to
a complete circle.

    \tikz \datavisualization
        [new polar axes={angle axis}{radius axis},
         radius axis={unit length=1cm},
         angle axis={degrees},
         visualize as scatter]
      data [format=named] {
        angle={10,90}, radius={0.25,0.5,...,2}
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/degrees"
    },
    ["axis options/exponential steps"] = {
      details = [[
This strategy produces ticks at positions that are appropriate for
logarithmic plots. It is automatically selected when you use the
`logarithmic` option with an axis.

In detail, the following happens: As for `linear steps` let numbers $a$,
$b$, $s$, and $p$ be given. Then, major ticks are placed at all
positions $10^{i\cdot s+p}$ that lie in the interval $[a,b]$ for
$i \in \mathbb{Z}$.

The minor steps are added in the same way as for `linear steps`. In
particular, they interpolate *linearly* between major steps.

    \begin{tikzpicture}
      \datavisualization
        [scientific axes,
         x axis={logarithmic, length=2cm, ticks={step=1.5}},
         y axis={logarithmic, ticks={step=1, minor steps between steps=9}},
         visualize as scatter]
        data {
          x, y
          1, 10
          1000, 1000000
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/exponential:steps"
    },
    ["axis options/function"] = {
      details = [[
The ⟨code⟩ should specify a function $f$ that is applied during the
transformation of the interval $[s_1,s_2]$ to the interval $[t_1,t_2]$
in the following way: When the ⟨code⟩ is called, the macro `\pgfvalue`
will have been set to an internal representation of the
to-be-transformed value $v$. You can then call the commands of the
math-micro-kernel of the data visualization system, see Section ??, to
compute a new value. This new value must once more be stored in
`\pgfvalue`.

The most common use of this key is to say

    some axis={function=\pgfdvmathln{\pgfvalue}{\pgfvalue}}

This specifies that the function $f$ is the logarithm function.

    \tikz \datavisualization
       [scientific axes,
        x axis={ticks={major={at={1,10,100,1000}}},
                 scaling=1 at 0cm and 1000 at 3cm,
                 function=\pgfdvmathln{\pgfvalue}{\pgfvalue}},
        visualize as scatter]
      data [format=named] {
        x={1,100,...,1000}, y={1,2,3}
      };

Another possibility might be to use the square-root function, instead:

    \tikz \datavisualization
       [scientific axes,
        x axis={ticks=few,
                scaling=1 at 0cm and 1000 at 3cm,
                function=\pgfdvmathunaryop{\pgfvalue}{sqrt}{\pgfvalue}},
        visualize as scatter]
      data [format=named] {
        x={0,100,...,1000}, y={1,2,3}
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/function",
      meta = "⟨code⟩"
    },
    ["axis options/goto"] = {
      details = [[
The key can be passed to an axis. It will set the attribute monitored by
the axis to the given ⟨value⟩, which is usually some number. However,
⟨value⟩ may also be one of the following, which causes a special
behavior:

-   `min`: The attribute is set to the minimal value that the attribute
    has attained along this axis.

-   `max`: Like `min`.

-   `padded min`: This will also set the ⟨attribute⟩ monitored by the
    axis to the same value as `min`. Additionally, however, the subkey
    `/data point/`⟨attribute⟩`/offset` is set to the current padding for
    the minimum, see the description of `padding min` later on. The
    effect of this is that the actual point "meant" by the attribute is
    offset by this padding along the attribute's axis.

-   `padded max`: Like `padded min`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/goto",
      meta = "⟨value⟩"
    },
    ["axis options/goto pos"] = {
      details = [[
The key works like `goto`, only the ⟨fraction⟩ is not interpreted as a
value but as a fraction of the way between the minimum and the maximum
value for this axis.

Suppose that for an axis the attribute range interval is $[500,1000]$
and the reasonable interval is $[1,3]$. Then for a ⟨fraction⟩ of `0`,
the mapping process would choose value $1$ from the reasonable interval,
for a ⟨fraction⟩ of `1` the position $3$ from the reasonable interval,
and for a ⟨fraction⟩ or `0.25` the position $1.5$ since it is one
quarter at the distance from $1$ to $3$.

Note that neither the attribute range interval nor the transformation
function for the attribute are important for the `goto pos` option --
the ⟨fraction⟩ is computed with respect to the reasonable interval. Also
note that the values of the actual attribute corresponding to the
fractional positions in the reasonable interval are not computed.

    \tikzset{
      data visualization/our system/.append style={
        x axis=    {visualize axis={left axis={goto pos=0.25}},
                    visualize axis={left axis={goto pos=0.5}}},
     }
    }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, length=4cm},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={people 1, people 2, money 1, money 2}]
      data group {people and money};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/goto:pos",
      meta = "⟨fraction⟩"
    },
    ["axis options/grid"] = {
      details = [[
This key is similar to `ticks`, only it is used to configure where grid
lines should be shown rather than ticks. In particular, the options that
can be passed to the `ticks` key can also be passed to the `grid` key.
Just like `ticks`, the ⟨options⟩ only specify which grid lines should be
drawn in principle; it is the job of the `visualize grid` key to
actually cause any grid lines to be shown.

If you do not specify any ⟨options⟩, the default text `at default ticks`
is used. This option causes grid lines to be drawn at all positions
where ticks are shown by default. Since this usually exactly what you
would like to happen, most of the time you just need to `all axes=grid`
to cause a grid to be shown.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/grid",
      meta = "⟨options⟩"
    },
    ["axis options/include value"] = {
      details = [[
This key "fakes" data points for which the attribute's values are in the
comma-separated ⟨list of values⟩. For instance, when you write
`include value=0`, then the attribute range interval is guaranteed to
contain `0` -- even if the actual data points are all positive or all
negative.

    \tikz \datavisualization [scientific axes, all axes={length=3cm},
                              visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };

    \tikz \datavisualization [scientific axes, all axes={length=3cm},
                              visualize as line,
                              x axis={include value=20},
                              y axis={include value=0}]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/include:value",
      meta = "⟨list of value⟩"
    },
    ["axis options/label"] = {
      details = [[
This key sets the label of an axis to ⟨text⟩. This text will typically
be placed inside a `node` and the ⟨options⟩ can be used to further
configure the way this node is rendered. The ⟨options⟩ will be executed
with the path prefix `/tikz/data visualization/`, so you need to say
`node style` to configure the styling of a node, see Section ??.

    \tikz \datavisualization [
        scientific axes,
        x axis = {label, length=2.5cm},
        y axis = {label={[node style={fill=blue!20}]{$x^2$}}},
        visualize as smooth line]
     data [format=function] {
       var x : interval [-3:5];
       func y = \value x * \value x;
     };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/label",
      meta = "{[⟨options⟩]}⟨text⟩"
    },
    ["axis options/length"] = {
      details = [[
Sets `scaling` to `min at 0cm and max at `⟨dimension⟩. The effect is
that the range of all values of the axis's attribute will be mapped to
an interval of exact length ⟨dimension⟩.

    \tikz \datavisualization [scientific axes,
                              x axis={length=3cm},
                              y axis={length=2cm},
                              all axes={ticks=few},
                              visualize as line]
        data {
          x, y
          10, 10
          20, 20
          15, 30
          13, 20
        };

    \tikz \datavisualization [scientific axes,
                              x axis={length=3cm},
                              y axis={length=4cm},
                              all axes={ticks=few},
                              visualize as line]
        data {
          x, y
          10, 10
          20, 20
          15, 30
          13, 20
        };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/length",
      meta = "⟨dimension⟩"
    },
    ["axis options/linear steps"] = {
      details = [[
This strategy places ticks at positions that are evenly spaced by the
current value of `step`.

In detail, the following happens: Let $a$ be the minimum value of the
data values along the axis and let $b$ be the maximum. Let the current
*stepping* be $s$ (the stepping is set using the `step` option, see
below) and let the current *phasing* be $p$ (set using the `phase`)
option. Then ticks are placed all positions $i\cdot s + p$ that lie in
the interval $[a,b]$, where $i$ ranges over all integers.

The tick positions computed in the way described above are *major* step
positions. In addition to these, if the key `minor steps between steps`
is set to some number $n$, then $n$ many minor ticks are introduced
between each two major ticks (and also before and after the last major
tick, provided the values still lie in the interval $[a,b]$). Note that
is $n$ is $1$, then one minor tick will be added in the middle between
any two major ticks. Use a value of $9$ (not $10$) to partition the
interval between two major ticks into ten equally sized minor intervals.

    \begin{tikzpicture}
      \datavisualization
        [scientific axes={inner ticks, width=3cm},
         x axis={ticks={step=3, minor steps between steps=2}},
         y axis={ticks={step=.36}},
         visualize as scatter]
        data {
          x, y
          17, 30
          34, 32
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/linear:steps"
    },
    ["axis options/logarithmic"] = {
      details = [[
When this key is used with an axis, three things happen:

1.  The transformation `function` of the axis is setup to the logarithm.

2.  The strategy for automatically generating ticks and grid lines is
    set to the `exponential strategy`, see Section ?? for details.

3.  The default scaling is setup sensibly.

All told, to turn an axis into a logarithmic axis, you just need to add
this option to the axis.

    \tikz \datavisualization [scientific axes,
                              x axis={logarithmic},
                              y axis={logarithmic},
                              visualize as line]
     data [format=function] {
       var x : interval [0.01:100];
       func y = \value x * \value x;
     };

Note that this will work with any axis, including, say, the degrees on a
polar axis:

    \tikz \datavisualization
        [new polar axes,
         angle axis={logarithmic, scaling=1 at 0 and 90 at 90},
         radius axis={scaling=0 at 0cm and 100 at 3cm},
         visualize as scatter]
      data [format=named] {
        angle={1,10,...,90}, radius={1,10,...,100}
      };

    \tikz \datavisualization
        [new polar axes,
         angle axis={degrees},
         radius axis={logarithmic, scaling=1 at 0cm and 100 at 3cm},
         visualize as scatter]
      data [format=named] {
        angle={1,10,...,90}, radius={1,10,...,100}
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/logarithmic"
    },
    ["axis options/max value"] = {
      details = [[
Works like `min value`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/max:value",
      meta = "⟨value⟩"
    },
    ["axis options/min value"] = {
      details = [[
This key allows you to simply set the minimum value, regardless of which
values are present in the actual data. This key should be used with
care: If there are data points for which the attribute's value is less
than ⟨value⟩, they will still be depicted, but typically outside the
normal visualization area. Usually, saying `include value=`⟨value⟩ will
achieve the same as saying `min value=`⟨value⟩, but with less danger of
creating ill-formed visualizations.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/min:value",
      meta = "⟨value⟩"
    },
    ["axis options/padding"] = {
      details = [[
Sets both `padding min` to the negated value of ⟨dimension⟩ and
`padding max` to ⟨dimension⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/padding",
      meta = "⟨dimension⟩"
    },
    ["axis options/padding max"] = {
      details = [[
Works like `padding min`, but ⟨dimension⟩ should typically be positive.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/padding:max",
      meta = "⟨dimension⟩"
    },
    ["axis options/padding min"] = {
      details = [[
This is the dimension that is used whenever `goto=padded min` is used.
The ⟨dimension⟩ is then put into the `offset` subkey of the attribute
monitored by the axis. When a data point is transformed by a linear
transformer and when this subkey is nonzero, this offset is added. (For
an angle axis of a polar transformer, the ⟨dimension⟩ is interpreted as
an additional angle rather than as an additional distance). Note that
⟨dimension⟩ should typically be negative since "adding the ⟨dimension⟩"
will then make the axis longer (because it starts at a smaller value).
The standard axis systems set the padding to some default and take its
value into account:

    \begin{tikzpicture}
      \datavisualization [scientific axes=clean,
                          x axis={padding min=-1cm},
                          visualize as smooth line]
        data [format=function] {
          var x : interval [-3:5];
          func y = \value x * \value x;
        };
    \end{tikzpicture}

Using padded and using the `padded` key, we can visualize our axis "a
little removed from the actual data":

    \tikzset{
      data visualization/our system/.append style={
        all axes=  {padding=.5em},
        left axis= {visualize axis={x axis=   {goto=padded min}, padded}},
        right axis={visualize axis={x axis=   {goto=padded max}, padded}},
        x axis=    {visualize axis={left axis={goto=padded min}, padded},
                    visualize axis={left axis={goto=padded max}, padded}},
     }
    }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, length=3cm},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={people 1, people 2, money 1, money 2}]
      data group {people and money};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/padding:min",
      meta = "⟨dimension⟩"
    },
    ["axis options/power unit length"] = {
      details = [[
This key is used in conjunction with the `logarithmic` setting. It cases
the `scaling` to be set to `1 at 0cm and 10 at `⟨dimension⟩. This causes
a "power unit", that is, one power of ten in a logarithmic plot, to get
a length of ⟨dimension⟩. Again, this key is useful for ensuring that the
same scaling is used across multiple axes or pictures.

    \tikz \datavisualization
      [scientific axes,
       y axis={logarithmic, power unit length=1mm, grid},
       visualize as line]
     data {
       x, y
       0, 0.0000000001
       1, 1
       2, 100000
       3, 100000000000
       4, 10000000000000000000000000000000
       5, 500000000
       6, 5000000000000000000
     };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/power:unit:length",
      meta = "⟨dimension⟩"
    },
    ["axis options/radians"] = {
      details = [[
In contrast to `degrees`, this option sets up things so that a value of
`2*pi` on this axis corresponds to a complete circle.

    \tikz \datavisualization
        [new polar axes={angle axis}{radius axis},
         radius axis={unit length=1cm},
         angle axis={radians},
         visualize as scatter]
      data [format=named] {
        angle={0,1.5}, radius={0.25,0.5,...,2}
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/radians"
    },
    ["axis options/scaling"] = {
      details = [[
The ⟨scaling spec⟩ must have the following form:

> ⟨$s_1$⟩` at `⟨$t_1$⟩` and `⟨$s_2$⟩` at `⟨$t_2$⟩

This means that monitored values in the interval $[s_1,s_2]$ should be
mapped to values the "reasonable" interval $[t_1,t_2]$, instead. For
instance, we might write

    [y axis = {scaling = 1900 at 0cm and 2000 at 5cm}]

in order to map dates between 1900 and 2000 to the dimension interval
$[0\mathrm{cm},5\mathrm{cm}]$.

    \tikz \datavisualization
       [scientific axes,
        x axis={attribute=people, length=2.5cm, ticks=few},
        y axis={attribute=year, scaling=1900 at 0cm and 2000 at 5cm},
        visualize as scatter]
      data {
        year, people
        1900, 100
        1910, 200
        1950, 200
        1960, 250
        2000, 150
      };

So much for the basic idea. Let us now have a detailed look at what
happens.

**Number format and the min and max keywords.** The source values $s_1$
and $s_2$ are typically just numbers like `3.14` or `10000000000`.
However, as described in Section ??, you can also specify expressions
like `(pi/2)`, provided that (currently) you put them in parentheses.

Instead of a number, you may alternatively also use the two key words
`min` and `max` for $s_1$ and/or $s_2$. In this case, `min` evaluates to
the smallest value observed for the attribute in the data, symmetrically
`max` evaluates to the largest values. For instance, in the above
example with the `year` attribute ranging from `1900` to `2000`, the
keyword `min` would stand for `1900` and `max` for `2000`. Similarly,
for the `people` attribute `min` stands for `100` and `max` for `250`.
Note that `min` and `max` can only be used for $s_1$ and $s_2$, not for
$t_1$ and $t_2$.

A typical use of the `min` and `max` keywords is to say

    scaling = min at 0cm and max at 5cm

to map the complete range of values into an interval of length of 5cm.

The interval $[s_1,s_2]$ need not contain all values that the
⟨attribute⟩ may attain. It is permissible that values are less than
$s_1$ or more than $s_2$.

**Linear transformation of the attribute.** As indicated earlier, the
main job of an axis is to map values from a "large" interval $[s_1,s_2]$
to a more reasonable interval $[t_1,t_2]$. Suppose that for the current
data point the value of the key `/data point/`⟨attribute⟩ is the number
$v$. In the simplest case, the following happens: A new value $v'$ is
computed so that $v' = t_1$ when $v=s_1$ and $v'=t_2$ when $v=s_2$ and
$v'$ is some value in between $t_1$ and $t_2$ then $v$ is some value in
between $s_1$ and $s_2$. (Formally, in this basic case
$v' = t_1 + (v-s_1)\frac{t_2-t_1}{s_2-s_1}$.)

Once $v'$ has been computed, it is stored in the key
`/data point/`⟨attribute⟩`/scaled`. Thus, the "reasonable" value $v'$
does not replace the value of the attribute, but it is placed in a
different key. This means that both the original value and the more
"scaled" values are available when the data point is visualized.

As an example, suppose you have written

    [x axis = {attribute = x, scaling=1000 at 20 and 2000 at 30}]

Now suppose that `/data point/x` equals `1200` for a data point. Then
the key `/data point/x/scaled` will be set to `22` when the data point
is being visualized.

**Nonlinear transformations of the attribute.** By default, the
transformation of $[s_1,s_2]$ to $[t_1,t_2]$ is the linear
transformation described above. However, in some case you may be
interested in a different kind of transformation: For example, in a
logarithmic plot, values of an attribute may range between, say, `1` and
`1000` and we want an axis of length `3cm`. So, we would write

    [x axis = {attribute = x, scaling=1 at 0cm and 1000 at 3cm}]

Indeed, `1` will now be mapped to position `0cm` and `1000` will be
mapped to position `3cm`. Now, the value `10` will be mapped to
approximately `0.03cm` because it is (almost) at one percent between `1`
and `1000`. However, in a logarithmic plot we actually want `10` to be
mapped to the position `1cm` rather than `0.03cm` and we want `100` to
be mapped to the position `2cm`. Such a mapping a *nonlinear* mapping
between the intervals.

In order to achieve such a nonlinear mapping, the `function` key can be
used, whose syntax is described in a moment. The effect of this key is
to specify a function $f \colon \mathbb{R} \to \mathbb{R}$ like, say,
the logarithm function. When such a function is specified, the mapping
of $v$ to $v'$ is computed as follows: $$\begin{aligned}
        v' = t_1 + (f(s_2) - f(v))\frac{t_2 - t_1}{f(s_2)-f(s_1)}.
    \end{aligned}$$

The syntax of the `function` key is described next, but you typically
will not call this key directly. Rather, you will use a key like
`logarithmic` that installs appropriate code for the `function` key for
you.

**Default scaling.** When no scaling is specified, it may seem natural
to use $[0,1]$ both as the source and the target interval. However, this
would not work when the logarithm function is used as transformations:
In this case the logarithm of zero would be computed, leading to an
error. Indeed, for a logarithmic axis it is far more natural to use
$[1,10]$ as the source interval and $[0,1]$ as the target interval.

For these reasons, the default value for the `scaling` that is used when
no value is specified explicitly can be set using a special key:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/scaling",
      meta = "⟨scaling spec⟩"
    },
    ["axis options/scaling/default"] = {
      details = [[
The ⟨text⟩ is used as `scaling` whenever no other scaling is specified.
This key is mainly used when a transformation function is set using
`function`; normally, you will not use this key directly.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/scaling/default",
      meta = "⟨text⟩"
    },
    ["axis options/tick placement strategy"] = {
      details = [[
This key can be used to install a so-called *tick placement strategy*.
Whenever `visualize ticks` is used to request some ticks to be
visualized, it is checked whether some automatic ticks should be
created. This is the case when the following key is set:

Provided `compute step` is set to some nonempty value, upon
visualization of ticks the ⟨macro⟩ is executed. Typically, ⟨macro⟩ will
first call the ⟨code⟩ stored in the key `compute step`. Then, it should
implement some strategy then uses the value of the computed or desired
stepping to create appropriate `at` commands. To be precise, it should
set the keys `major`, `minor`, and/or `subminor` with some appropriate
`at` values.

Inside the call of ⟨macro⟩, the macro `\tikzdvaxis` will have been set
to the name of the axis for which default ticks need to be computed.
This allows you to access the minimum and the maximum value stored in
the `scaling mapper` of that axis.

    \def\silly{
      \tikzdatavisualizationset{major={at={
            2,3,5,7,11,13}}}
    }
    \begin{tikzpicture}
      \datavisualization [
        scientific axes, visualize as scatter,
        x axis={tick placement strategy=\silly}
        ]
        data {
          x, y
          0, 0
          15, 15
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/tick:placement:strategy",
      meta = "⟨macro⟩"
    },
    ["axis options/ticks"] = {
      details = [[
This key can be passed to an axis in order to configure which ticks are
present for the axis. The possible ⟨options⟩ include, for instance, keys
like `step`, which is used to specify a stepping for the ticks, but also
keys like `major` or `minor` for specifying the positions of major and
minor ticks in detail. The list of possible options is described in the
rest of this section.

Note that the `ticks` option will only configure which ticks should be
shown in principle. The actual rendering is done only when the
`visualize ticks` key is used, documented in Section ??, which is
typically done only internally by an axis system.

The ⟨options⟩ will be executed with the path prefix
`/tikz/data visualization/`. When the `ticks` key is used multiple times
for an axis, the ⟨options⟩ accumulate.

    \tikz \datavisualization [
      scientific axes, visualize as line,
      x axis={ticks={step=24, minor steps between steps=3},
              label=hours}]
      data {
        x, y
        0, 0
        10, 0
        20, 0.5
        30, 0.75
        40, 0.7
        50, 0.6
        60, 0.5
        70, 0.45
        80, 0.47
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/ticks",
      meta = "⟨options⟩"
    },
    ["axis options/ticks and grid"] = {
      details = [[
This key passes the ⟨options⟩ to both the `ticks` key and also to the
`grid` key. This is useful when you want to specify some special points
explicitly where you wish a tick to be shown and also a grid line.

    \tikz \datavisualization
      [scientific axes,
       visualize as smooth line,
       all axes= {grid, unit length=1.25cm},
       y axis={ ticks=few },
       x axis={ ticks=many, ticks and grid={ major also at={(pi/2) as $\frac{\pi}{2}$}}}]
      data [format=function] {
        var x : interval [-pi/2:3*pi] samples 50;
        func y = sin(\value x r);
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/ticks:and:grid",
      meta = "⟨options⟩"
    },
    ["axis options/unit length"] = {
      details = [[
Sets `scaling` to `0 at 0cm and 1 at `⟨dimension⟩. In other words, this
key allows you to specify how long a single unit should be. This key is
particularly useful when you wish to ensure that the same scaling is
used across multiple axes or pictures.

    \tikz \datavisualization [scientific axes,
                              all axes={ticks=few, unit length=1mm},
                              visualize as line]
        data {
          x, y
          10, 10
          40, 20
          15, 30
          13, 20
        };

The optional `per `⟨number⟩` units` allows you to apply more drastic
scaling. Suppose that you want to plot a graph where one billion
corresponds to one centimeter. Then the unit length would be need to be
set to a hundredth of a nanometer -- much too small for TeX to handle as
a dimension. In this case, you can write
`unit length=1cm per 1000000000 units`:

    \tikz \datavisualization
      [scientific axes,
       x axis={unit length=1mm per 1000000000 units, ticks=few},
       visualize as line]
     data {
       x, y
       10000000000, 10
       40000000000, 20
       15000000000, 30
       13000000000, 20
     };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/unit:length",
      meta = "⟨dimension⟩ per ⟨number⟩ units"
    },
    ["axis options/unit vector"] = {
      details = [[
Recall that an axis takes the values of an attribute and rescales them
so that they fit into a "reasonable" interval $[t_1,t_2]$. Suppose that
$v'$ is the rescaled dimension in (TeX) points. Then when the data point
is visualized, the coordinate system will be shifted by $v'$ times the
⟨coordinate⟩.

As an example, suppose that you have said
`scaling=0 and 10pt and 50 and 20pt`. Then when the underlying attribute
has the value `25`, it will be mapped to a $v'$ of $15$ (because `25`
lies in the middle of `0` and `50` and `15pt` lies in the middle of
`10pt` and `20pt`). This, in turn, causes the data point to be displaced
by $15$ times the ⟨coordinate⟩.

The bottom line is that the ⟨coordinate⟩ should usually denote a point
that is at distance `1pt` from the origin and that points into the
direction of the axis.

    \begin{tikzpicture}
      \draw [help lines] (0,0) grid (3,2);

      \datavisualization
        [new Cartesian axis=x axis, x axis={attribute=x},
         new Cartesian axis=y axis, y axis={attribute=y},
         x axis={unit vector=(0:1pt)},
         y axis={unit vector=(60:1pt)},
         visualize as scatter]
      data {
        x, y
        0, 0
        1, 0
        2, 0
        1, 1
        2, 1
        1, 1.5
        2, 1.5
      };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/unit:vector",
      meta = "⟨coordinate⟩"
    },
    ["axis options/unit vectors"] = {
      details = [[
Both the ⟨unit vector 0 degrees⟩ and the ⟨unit vector 90 degrees⟩ are
TikZ coordinates:

    \tikz \datavisualization
        [new polar axes={angle axis}{radius axis},
         radius axis={unit length=1cm},
         angle axis={unit vectors={(10:1pt)}{(60:1pt)}},
         visualize as scatter]
      data [format=named] {
        angle={0,90}, radius={0.25,0.5,...,2}
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/unit:vectors",
      meta = " {⟨unit vector 0 degrees⟩}{⟨unit vector 90 degrees⟩}"
    },
    ["axis options/visualize axis"] = {
      details = [[
This key is passed to an axis as an option. It causes a visual
representation of the axis to be created during the data visualization.
The ⟨options⟩ are used to determine where the axis should be drawn and
how long it should be. We can specify, for instance, that an axis should
be drawn at the minimum value of another axis or where another axis has
the value `0`.

**The goto, high, and low Keys.** In our example, the `left axis` should
be shown at the left hand side. This is the position where the `x axis`
has its minimum value. To specify this, we would use the following code:

    left axis={ visualize axis={ x axis={ goto=min } }

As can be seen, we can pass another axis as an ⟨option⟩ to
`visualize axis`, where we pass the following key to the axis in turn:

The `right axis` would be visualized the same way, only at `goto=max`.
The $x$-axis actually needs to be visualized *twice*: Once at the bottom
and once at the top. Thus, we need to call `visualize axis` twice for
this axis:

    \tikzset{
      data visualization/our system/.append style={
        left axis= {visualize axis={x axis=   {goto=min}}},
        right axis={visualize axis={x axis=   {goto=max}}},
        x axis=    {visualize axis={left axis={goto=min}},
                    visualize axis={left axis={goto=max}}},
     }
    }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, length=4cm},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={people 1, people 2, money 1, money 2}]
      data group {people and money};

There is another key that is similar to `goto`, but has a slightly
different semantics:

By default, when an axis is visualized, it spans the set of all possible
values for the monitored attribute, that is, from `min` to `max`.
However, there are actually two keys that allow you to adjust this:

By default, `low=min` and `high=max` are set for an axis visualization.
Another sensible setting is `low=padded min` and `high=padded max`. The
following key provides a shorthand for this:

As an example, consider the `scientific axes=clean`. Here, each axis is
actually drawn three times: Once at the minimum, once at the maximum and
then once more at the padded minimum.

**The axis line.** When an axis is drawn, TikZ does not simply draw a
straight line from the `low` position to the `high` position. In
reality, the data visualization system uses the two commands
`\pgfpathdvmoveto` and `\pgfpathdvlineto` internally. These will replace
the straight line by a curve in certain situations. For instance, in a
polar coordinate system, if an axis should be drawn along an angle axis
for a fixed radius, an arc will be used instead of a straight line.

**Styling the axis.** As can be seen, we now get the axis we want (but
without the ticks, visualizing them will be explained later). The axis
is, however, simply a black line. We can *style* the axis in a manner
similar to styling ticks and grid lines, see Section ??. In detail, the
following styles get executed:

1.  `axis layer`

2.  `every axis`

3.  `styling`

Additionally, even before `every axis` is executed, `low=min` and
`high=max` are executed.

Recall that the `styling` key is set using the `style` key, see
Section ??.

    \tikzset{
      data visualization/our system/.append style={
        every axis/.style={style=black!50}, % make this the default
        left axis= {visualize axis={x axis=   {goto=min}, style=red!75}},
        right axis={visualize axis={x axis=   {goto=max}, style=blue!75}},
        x axis=    {visualize axis={left axis={goto=min}},
                    visualize axis={left axis={goto=max}}},
     }
    }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, length=4cm},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={people 1, people 2, money 1, money 2}]
      data group {people and money};

**Padding the Axis.** When an axis is visualized, it is often a good
idea to make it "a little bit longer" or to "remove it a bit from the
border", because the visualization of an axis should not interfere with
the actual data. For this reason, a *padding* can be specified for axes:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/visualize:axis",
      meta = "⟨options⟩"
    },
    ["axis options/visualize grid"] = {
      details = [[
This key is passed to an axis. It causes grid lines to be drawn at the
positions specified by the `grid` key for this axis. The ⟨options⟩
govern where and how the grid lines will be drawn.

**The direction axis.** At first sight, one might expect that the grid
lines for an axis should simply be drawn perpendicular to the axis
between the minimum and maximum value of the axis. However, things are
somewhat more difficult in reality:

1.  A grid line is supposed to indicate all positions where a certain
    attribute attains a fixed value. But, then, a grid line does not
    really need to be a grid *line*. Consider for instance a three
    dimensional axis system. A "grid line" for the $x$-coordinate `3`
    would actually be a "grid plane".

2.  For a polar coordinate system and a fixed radius, this set of
    positions at a certain radius is not a straight line, but an arc.
    For more complicated coordinate systems such as the one arising from
    three-dimensional spherical projections, a grid line may well be a
    fairly involved curve.

The `visualize grid` command addresses these complications as follows:

1.  A grid line is always a line, not a plane or a volume. This means
    that in the example of a three dimensional axis system and the
    $x$-attribute being `3`, one would have to choose whether the grid
    line should go "along" the $y$-axis or "along" the $z$-axis for this
    position. One can, however, call the `visualize grid` command twice,
    once for each direction, to cause grid lines to be shown for both
    directions.

2.  A grid line is created by moving to a start position and then doing
    a lineto to the target position. However, the "moveto" and "lineto"
    are done by calling special commands of the data visualization
    system. These special commands allow coordinate system to "notice"
    that the line is along an axis and will allow them to replace the
    straight line by an appropriate curve. The polar axes systems employ
    this strategy, for instance.

By the above discussion, in order to create a grid line for attribute
$a$ having value $v$, we need to specify an axis "along" which the line
should be drawn. When there are only two axes, this is usually "the
other axis". This "other axis" is specified using the following key:

The `low` and `high` keys are the same as the ones used in the
`visualize axis` key.

    \tikz \datavisualization [
        xyz Cartesian cabinet,
        all axes={visualize axis={low=0, style=->}},
        x axis={visualize grid={direction axis=y axis}, grid=many},
        visualize as scatter]
      data {
        x, y, z
        0, 0, 1
        0, 1, 0
        2, 2, 2
      };

    \tikz \datavisualization [
        xyz Cartesian cabinet,
        all axes={visualize axis={low=0, style=->}, grid=many},
        x axis={visualize grid={direction axis=z axis}},
        z axis={visualize grid={direction axis=x axis},
                visualize grid={direction axis=y axis},},
        visualize as scatter]
      data {
        x, y, z
        0, 0, 1
        0, 1, 0
        2, 2, 2
      };

**Styling the grid lines.** When a grid line is draw, styles are applied
as described in Section ??.

**The major, minor, and subminor grid lines.** The `grid` option allows
you to specify for each kind of grid line (major, minor, or subminor) a
set of different values for which these grid lines should be drawn.
Correspondingly, it is also possible to configure for each kind of grid
line how it should be drawn. For this, the `major`, `minor`, `subminor`,
and also the `common` keys can be used inside the ⟨options⟩ of
`visualize grid`. While as option to `grid` these keys are used to
specify `at` values, as options of `visualize grid` they are used to
configure the different kinds of grid lines.

Most of the time, no special configuration is necessary since all
styling is best done by configuring keys like `every major grid`. You
need to use a key like `major` only if you wish to configure for
instance the `low` or `high` values of a `major` grid line differently
from those of `minor` grid lines -- are rather unlikely setting -- or
when the styling should deviate from the usual settings.

    \tikz \datavisualization [
        xy Cartesian,
        all axes={visualize axis={low=0, style=->},
                  grid={some, minor steps between steps}},
        x axis=  {visualize grid={
                    direction axis=y axis,
                    minor={low=0.25, high=1.75, style=red!50}}},
        visualize as scatter]
      data {
        x, y
        0, 0
        3, 3
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/visualize:grid",
      meta = "⟨options⟩"
    },
    ["axis options/visualize label"] = {
      details = [[
The ⟨options⟩ should be used to configure a "good place" for the axis
label. Usually, you will use the `goto` or the `goto pos` key.

For the example of `our system`, we would like the label of the `x axis`
to be placed below at the middle of the axis, so we use `goto pos=.5` to
determine this position. Concerning the other axes, we want it to be
placed at the minimum position of the `left axis` with a lot of padding.

    \tikzdatavisualizationset{
      our system/.append style={
        x axis={visualize label={
            x axis={goto pos=.5},
            left axis={padding=1.5em, goto=padded min}}}
      }
    }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, ticks=some, label},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={
          people 1, people 2, money 1, money 2}]
      data group {people and money};

In the above example, the `padding` of `1.5em` was rather arbitrary and
"suboptimal". It would be outright wrong if the labels on the `x axis`
were larger or if they were missing. It would be better if the vertical
position of the `x axis` label were always "below" all other options.
For such cases a slightly strange approach is useful: You position the
node using `node style={at=...}` where `at` is now the normal
TikZ option that is used to specify the position of a node. Inside the
`...`, you specify that the horizontal position should be the bottom of
up-to-now-constructed data visualization and the vertical position
should be at the "origin", which is, however, the position computed by
the `goto` keys for the axes:

    \tikzdatavisualizationset{
      our system/.append style={
        x axis={visualize label={
          x axis={goto pos=.5},
          node style={
            at={(0,0 |- data visualization bounding box.south)},
            below
    } } } } }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, ticks=some, label=Year},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={
          people 1, people 2, money 1, money 2}]
      data group {people and money};

Two additional keys are useful for positioning axis labels:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/visualize:label",
      meta = "⟨options⟩"
    },
    ["axis options/visualize ticks"] = {
      details = [[
Visualizing a tick involves (possibly) drawing a tick mark and adding
(possibly) the tick node. The process is similar to `visualize grid`:
Users use the `ticks` key to configure how many ticks they would like
for an axis and at which positions. The axis system uses the
`visualize ticks` key to specify where these ticks should actually be
shown.

Unlike grid lines, which are typically only visualized once for each
combination of an axis and a direction axis, tick marks might be
visualized at different places for the same axis. Consider for instance
the `scientific axes`:

    \tikz \datavisualization [scientific axes, all axes={length=3cm},
                              x axis={ticks={stack}},
                              visualize as smooth line]
      data [format=function] {
        var x : interval [0:2];
        func y = \value  x*\value x;
      };

Have a look at the ticks on the $y$-axis: There are ticks at values `0`,
`1`, `2`, `3`, and `4`. These are visualized both at the left side
(where the tick nodes are also shown) and additionally also at the right
side, but only as small marks. Similarly, the ticks on the $x$-axis
appear at the bottom, but also (in much simpler versions) at the top.
Both for the $x$-axis and for the $y$-axis the `visualize ticks` key was
called twice.

**The tick marks.** Drawing a tick mark is quite similar to visualizing
a grid line; indeed a tick mark can be thought of as a "mini grid line":
Just like a grid line it "points a long an axis". However, a tick will
always be a short straight line -- even when the coordinate system is
actually twisted (experimentation has shown that ticks that follow the
curvature of the coordinate system like grid lines are hard to
recognize). For this reason, the `low` and `high` keys have a different
meaning from the one used with the `visualize grid` key. In detail to
configure the size and position of a tick mark for the value $v$ of
attribute $a$, proceed as follows:

-   The `visualize ticks` key will have setup attribute $a$ to be equal
    to $v$.

-   You should now use the `goto` or `goto pos` key together with all
    *other* axes to configure at which position with respect to these
    other options the tick mark should be shown. For instance, suppose
    we want tick marks in `our system` for the $x$-axis at the bottom
    and at the top. This corresponds to once setting the `left axis` to
    its minimal value and once to its maximal value:

        \tikzset{
          data visualization/our system/.append style={
            x axis={visualize ticks={direction axis=left axis, left axis={goto=min}},
                    visualize ticks={direction axis=left axis, left axis={goto=max}},
            }
          }
        }
        \tikz \datavisualization [
            our system,
            x axis={attribute=time, length=3cm, ticks=many},
            left axis ={attribute=money},
            right axis={attribute=people},
            visualize as line/.list={people 1, people 2, money 1, money 2}]
          data group {people and money};

-   In the above example, we may wish to shorten the ticks a bit at the
    bottom and at the top. For this, we use the `low` and `high` key:

    What we want to happen is that in the upper visualization of the
    ticks the `low` value is `0pt`, while in the lower one the `high`
    value is `0pt`:

        \tikzset{
          data visualization/our system/.append style={
            x axis={
              visualize ticks={direction axis=left axis,high=0pt,left axis={goto=min}},
              visualize ticks={direction axis=left axis,low=0pt,left axis={goto=max}},
            }
          }
        }
        \tikz \datavisualization [
            our system,
            x axis={attribute=time, length=3cm, ticks=many},
            left axis ={attribute=money},
            right axis={attribute=people},
            visualize as line/.list={people 1, people 2, money 1, money 2}]
          data group {people and money};

In order to style the tick mark, use the styling mechanism that is
detailed in Section ??.

**The tick label node.** At certain tick positions, we may wish to add a
node indicating the value of the attribute at the given position. The
`visualize ticks` command has no influence over which text should be
shown at a node -- the text is specified and typeset as explained in
Section ??.

Each time `visualize ticks`, for each tick position up to two tick label
nodes will be created: One at the `low` position and one at the `high`
position. The following keys are used to configure which of these cases
happen:

When a tick label node is to be placed at the low or the high position,
the next step is to determine the exact position and the correct anchor
of the node. This is done as follows:

-   In order to compute an appropriate `anchor`, the tick mark is
    considered: This is a short line pointing in a certain direction.
    For a tick label node at the `low` position, the `anchor` attribute
    is setup in such a way that the node label will be below the `low`
    position when the tick mark direction points up, it will be to the
    right when the direction points left, above when it points down, and
    so on also for diagonal directions. Similarly, for the `high`
    position, when the direction points up, the node will be placed
    above the tick mark and so on.

    This computation is done automatically.

-   The tick label node is styled. The styles that are applied are
    described in Section ??.

-   A tick label node for the `low` position is usually anchored at this
    `low` position, but an additional padding will be added as described
    in Section ??.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/visualize:ticks",
      meta = "⟨options⟩"
    },
    ["before creation"] = {
      details = [[
This code is executed right before the object is finally created. It can
be used to compute values that are then passed to the constructor.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/before:creation",
      meta = "⟨code⟩"
    },
    ["before survey"] = {
      details = [[
The ⟨code⟩ is passed to the `before survey` method of the data
visualization object and then executed at the appropriate time (see
Section ?? for details).

The following commands work likewise:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/before:survey",
      meta = "⟨code⟩"
    },
    ["before visualization"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/before:visualization",
      meta = "⟨code⟩"
    },
    class = {
      details = [[
The class of the to-be-created object.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/class",
      meta = "⟨class name⟩"
    },
    common = {
      details = [[
This key allows you to specify ⟨options⟩ that apply to `major`, `minor`
and `subminor` alike. It does not make sense to use `common` to specify
positions (since you typically do not want both a major and a minor tick
at the same position), but it can be useful to configure, say, the size
of all kinds of ticks:

    \tikz \datavisualization
      [ school book axes, visualize as smooth line,
        x axis={ticks={minor steps between steps, common={low=0}}} ]
      data [format=function] {
        var x : interval [-1.25:2];
        func y = \value x * \value x / 2;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/common",
      meta = "⟨options⟩"
    },
    ["compute step"] = {
      details = [[
The ⟨code⟩ should compute a suitable value for the stepping to be used
by the ⟨macro⟩ in the tick placement strategy.

For instance, the `step` key sets `compute step` to
`\def\tikz@lib@dv@step{# 1}`. Thus, when you say `step=5`, then the
desired stepping of `5` is communicated to the ⟨macro⟩ via the macro
`\tikz@lib@dv@step`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/compute:step",
      meta = "⟨code⟩"
    },
    ["data point"] = {
      details = [[
This key is the "key version" of the previous command. The difference is
that this key can be used internally inside styles.

    \tikzdatavisualizationset{
      horizontal/.style={
        data point={x=#1, y=1}, data point={x=#1, y=2}},
    }
    \tikz \datavisualization
    [ school book axes, visualize as line,
      horizontal=1,
      horizontal=2 ];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/data:point",
      meta = "⟨options⟩"
    },
    ["decimal about strategy"] = {
      details = [[
The only permissible value for $m'$ is $1$. This is an even more radical
version of the previous strategy.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/decimal:about:strategy"
    },
    ["direction axis"] = {
      details = [[
You must pass this key as an ⟨option⟩ each time you use
`visualize axis`. When the grid line is drawn, the attribute $a$ is set
to $v$ and the axis ⟨axis name⟩'s attribute is set once to the current
value of `low` and once to `high`. Then a line is drawn between these
two positions using `\pgfpathdvlineto`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/direction:axis",
      meta = "⟨axis name⟩"
    },
    ["euro about strategy"] = {
      details = [[
Permissible values for $m'$ are: $1$, $2$, and $5$. These are the same
values as for the Euro coins, hence the name.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/euro:about:strategy"
    },
    ["every axis"] = {
      details = [[
Put styling of the axis here. It is usually a good idea to set this
style to `style={black!50}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:axis"
    },
    ["every data set label"] = {
      details = [[
This style is executed with every label that represents a data set.
Inside this style, use `node style` to change the appearance of nodes.
This style has a default definition, usually you should just append
things to this style.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      school book axes,
      x axis={label=$x$},
      visualize as smooth line/.list={log, lin, squared, exp},
      every data set label/.append style={text colored},
      log=    {label in data={text'=$\log x$, when=y is -1}},
      lin=    {label in data={text=$x/2$,
                        node style=sloped,    when=x is 2}},
      squared={label in data={text=$x^2$,     when=x is 1.1}},
      exp=    {label in data={text=$e^x$,
                        node style=sloped,    when=x is -2}},
      style sheet=vary hue]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:data:set:label"
    },
    ["every grid"] = {
      details = [[
This style provides overall configuration options for grid lines. By
default, it is set to the following:

    low=min, high=max

This causes grid lines to span all possible values when they are
visualized, which is usually the desired behavior (the `low` and `high`
keys are explained in Section ??. You can append the `style` key to this
style to configure the overall appearance of grid lines. It should be
noted that settings to `style` inside `every grid` will take precedence
over ones in `every major grid` and `every minor grid`. In the following
example we cause all grid lines to be dashed (which is not a good idea
in general since it creates a distracting background pattern).

    \tikz \datavisualization
      [scientific axes,
       all axes={length=3cm, grid},
       every grid/.append style={style=densely dashed},
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:grid"
    },
    ["every label in data"] = {
      details = [[
Like `every data set label`, this key is also executed with labels.
However, this key is executed after the style sheets have been executed,
giving you a chance to overrule their styling.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:label:in:data"
    },
    ["every label in legend"] = {
      details = [[
This key is executed with every label in a legend. However, the options
stored in this style are executed with the path prefix
`/tikz/data visualization/legend entry options`. Thus, this key can use
keys like `node style` to configure the styling of all text nodes:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      every label in legend/.style={node style=
        {fill=red!30}},
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=north east outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$,
          node style={circle, draw=red}}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:label:in:legend"
    },
    ["every major grid"] = {
      details = [[
This style configures the appearance of major grid lines. It does so by
calling the `style` key to setup appropriate TikZ options for
visualizing major grid lines. The default definition of this style is:

    style = {help lines, thin, black!25}

In the following example, we use thin major blue grid lines:

    \tikz \datavisualization
      [scientific axes,
       all axes={
         length=3cm,
         grid,
         grid={minor steps between steps}
       },
       every major grid/.style = {style={blue, thin}},
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };

As can be seen, this is not exactly visually pleasing. The default
settings for the grid lines should work in most situations; you may wish
to increase the blackness level, however, when you experience trouble
during printing or projecting graphics.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:major:grid"
    },
    ["every major ticks"] = {
      details = [[
The default is

      style={line cap=round}, tick length=2pt
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:major:ticks"
    },
    ["every minor grid"] = {
      details = [[
Works like `every major grid`. The default is

    style = {help lines, black!25}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:minor:grid"
    },
    ["every minor ticks"] = {
      details = [[
The default is

      style={help lines,thin, line cap=round}, tick length=1.4pt
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:minor:ticks"
    },
    ["every scientific axes"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:scientific:axes"
    },
    ["every subminor grid"] = {
      details = [[
Works like `every major grid`. The default is

    style = {help lines, black!10}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:subminor:grid"
    },
    ["every subminor ticks"] = {
      details = [[
The default is

      style={help lines, line cap=round}, tick length=0.8pt
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:subminor:ticks"
    },
    ["every ticks"] = {
      details = [[
This style allows you to configure the appearance of ticks using the
`style` and `node style` key. Here is (roughly) the default definition
of this style:

    node style={
      font=\footnotesize,
      inner sep=1pt,
      outer sep=.1666em,
      rounded corners=1.5pt
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:ticks"
    },
    ["every visualizer"] = {
      details = [[
This style is used with every visualizer. Note that it should contain
normal TikZ keys.

    \tikz \datavisualization
     [scientific axes=clean,
      every visualizer/.style={dashed},
      visualize as smooth line]
    data [format=function] {
      var x : interval[0:3*pi];
      func y = sin(\value x r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:visualizer"
    },
    ["every ⟨axis system name⟩"] = {
      details = [[
Even though this style has the path prefix `/tikz/data visualization`
itself, the keys stored in this style will be executed with the path
prefix `/tikz/data visualization/`⟨axis system name⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:⟨axis:system:name⟩"
    },
    few = {
      details = [[
This is an abbreviation for `about=3`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/few"
    },
    ["grid layer"] = {
      details = [[
\[section-dv-grid-layer\] This key is used to specified the *layer* on
which grid lines should be drawn (layers are explained in Section ??).
By default, all grid lines are placed on the `background` layer and thus
behind the data visualization. This is a sensible strategy since it
avoids obscuring the more important data with the far less important
grid lines. However, you can change this style to "get the grid lines to
the front":

    \tikz \datavisualization
      [scientific axes,
       all axes={
         length=3cm,
         grid,
         grid={minor steps between steps}
       },
       grid layer/.style=, % none, so on top of data (bad idea)
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };

When this style is executed, the keys stored in the style will be
executed with the prefix `/tikz`. Normally, you should only set this
style to be empty or to `on background layer`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/grid:layer"
    },
    ["half about strategy"] = {
      details = [[
Permissible values for $m'$: $1$ and $5$. Use this strategy if only
powers of $10$ or halves thereof seem logical.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/half:about:strategy"
    },
    high = {
      details = [[
Like `low`, only for where the axis ends.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/high",
      meta = "⟨value⟩"
    },
    ["int about strategy"] = {
      details = [[
Permissible values for $m'$ are: $1$, $2$, $3$, $4$, and $5$.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/int:about:strategy"
    },
    legend = {
      details = [[
This is a shorthand for `new legend=main legend, main legend=`⟨options⟩.
In other words, this key creates a new `main legend` and immediately
passes the configuration ⟨options⟩ to this legend.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes, x axis={label=$x$},
      visualize as smooth line/.list={log, lin, squared, exp},
      legend=below,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=vary dashing]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend",
      meta = "⟨options⟩"
    },
    ["legend entry options/circular label in legend line"] = {
      details = [[
This style is especially tailored to represent lines that are closed. It
is automatically selected for instance by the `polygon` or the
`smooth cycle` styles.

    \tikz \datavisualization [
      scientific axes={clean}, all axes={length=3cm},
      visualize as line/.list={a,b,c},
      a={polygon}, b={smooth cycle},
      style sheet=cross marks,
      a={label in legend={text=polygon}},
      b={label in legend={text=circle}},
      c={label in legend={text=line}}]
    data [format=function, set=a] {
      var t : {0,72,...,359};
      func x = cos(\value t);
      func y = sin(\value t);
    }
    data [format=function, set=b] {
      var t : [0:2*pi];
      func x = .8*cos(\value t r);
      func y = .8*sin(\value t r);
    }
    data point [x=-1, y=0.5, set=c]
    data point [x=1,  y=0.25, set=c];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/circular:label:in:legend:line"
    },
    ["legend entry options/default label in legend closed path"] = {
      details = [[
This style is executed by `smooth cycle` and `straight cycle`. There are
(currently) no other predefined sets of coordinates that can be used
instead of the default value `circular label in legend line`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/default:label:in:legend:closed:path"
    },
    ["legend entry options/default label in legend mark"] = {
      details = [[
This style is executed by `no lines` and, implicitly, by scatter plots.
The default is to use `label in legend line one mark`. Another possible
value is `label in legend line three marks`.

    \tikz \datavisualization [
      visualize as scatter/.list={a,b,c},
      style sheet=cross marks,
      legend entry options/default label in legend mark/.style=
        label in legend three marks,
      a={label in legend={text=example a}},
      b={label in legend={text=example b}},
      c={label in legend={text=example c}}];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/default:label:in:legend:mark"
    },
    ["legend entry options/default label in legend path"] = {
      details = [[
This style is set, by default, to `zig zag label in legend line`. It is
installed by the styles `straight line`, `smooth line`, and `gap line`,
so changing this style will change the appearance of lines in legends.
The main other sensible option for this key is
`straight label in legend line`.

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      style sheet=vary dashing,
      a={label in legend={text=a}},  b={label in legend={text=b}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      legend entry options/default label in legend path/.style=
        straight label in legend line,
      style sheet=vary dashing,
      a={label in legend={text=a}},  b={label in legend={text=b}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/default:label:in:legend:path"
    },
    ["legend entry options/gap circular label in legend line"] = {
      details = [[
This style is especially tailored to for the `gap cycle` style and
automatically selected by it:

    \tikz \datavisualization [
      scientific axes={clean}, all axes={length=3cm},
      visualize as line/.list={a,b,c},
      a={gap cycle}, b={smooth cycle}, c={gap line},
      a={style={mark=*, mark size=0.5pt},
         label in legend={text=polygon}},
      b={label in legend={text=circle}},
      c={style={mark=*, mark size=0.5pt, mark options=red},
         label in legend={text=line}}]
    data [format=function, set=a] {
      var t : {0,72,...,359};
      func x = cos(\value t);
      func y = sin(\value t);
    }
    data [format=function, set=b] {
      var t : [0:352];
      func x = .8*cos(\value t);
      func y = .8*sin(\value t);
    }
    data point [x=-1, y=0.5, set=c]
    data point [x=1,  y=0.25, set=c];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/gap:circular:label:in:legend:line"
    },
    ["legend entry options/label in legend line coordinates"] = {
      details = [[
This key takes a ⟨list of coordinates⟩, which are TikZ-coordinates
separated by commas like `(0,0),``(1,1)`. The effect of setting the key
is the following: The label in legend visualizer used by, for instance,
`visualize as line` will draw a path going through these points. When
the line is drawn, the exact same style will be used as was used for the
data set. For instance, if the `smooth line` key was used and also the
`style=red` key, the line through the ⟨list of coordinates⟩ will also be
red and smooth. When the `straight cycle` key was used, the coordinates
will also be connected by a cycle, and so on.

When the line connecting the ⟨list of coordinates⟩ is drawn, the
coordinate system will have been shifted and transformed in such a way
that `(0,0)` lies to the left of the text and at half the height of the
character "x". This means that the right-most-point in the list should
usually be `(0,0)` and all other $x$-coordinates should usually be
negative. When the `text left` options is used, the coordinate system
will have been flipped, so the ⟨list of coordinates⟩ is independent of
whether the text is to the right or to the left of the line.

Let us now have a look at a first, simple example. We create a legend
entry that is just a straight line, so it should start somewhere to the
left of the origin at height $0$ and go to the origin:

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      style sheet=vary dashing,
      a={label in legend={text=a,
          label in legend line coordinates={(-1em,0), (0,0)}}},
      b={label in legend={text=b,
          label in legend line coordinates={(-2em,0), (0,0)}}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];

Now let us make this a bit more fancy and useful by using shifted lines:

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      legend={up then right}, style sheet=vary dashing,
      a={label in legend={text=a,
          label in legend line coordinates={(-2em,-.25ex), (0,0)}}},
      b={label in legend={text=b,
          label in legend line coordinates={(-2em,.25ex), (0,0)}}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];

In the final example, we use a little "hat" to represent lines:

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      legend={up then right}, style sheet=vary dashing,
      a={label in legend={text=a,
          label in legend line coordinates={
            (-2em,-.2ex), (-1em,.2ex), (0,-.2ex)}}},
      b={label in legend={text=b,
          label in legend line coordinates={
            (-2em,-.2ex), (-1em,.2ex), (0,-.2ex)}}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/label:in:legend:line:coordinates",
      meta = " {list of coordinates}"
    },
    ["legend entry options/label in legend mark coordinates"] = {
      details = [[
This key is similar to `label in legend line coordinates`, but now the
⟨list of coordinates⟩ is used as the positions where plot marks are
shown. Naturally, plot marks are only shown there if they are also shown
by the visualizer in the actual data -- just like the line through the
coordinates of the previous key is only shown when there is a line.

The ⟨list of coordinates⟩ may be the same as the one used for lines, but
usually it is not. In general, it is better to have marks for instance
not at the ends of the line.

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      legend={up then right},
      style sheet=vary dashing,
      style sheet=cross marks,
      a={label in legend={text=a,
          label in legend line coordinates={
            (-2em,-.2ex), (-1em,.2ex), (0,-.2ex)},
          label in legend mark coordinates={
            (-1em,.2ex)}}},
      b={label in legend={text=b,
          label in legend line coordinates={
            (-2em,-.2ex), (-1em,.2ex), (0,-.2ex)},
          label in legend mark coordinates={
            (-2em,-.2ex), (0,-.2ex)}}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/label:in:legend:mark:coordinates",
      meta = " {list of coordinates}"
    },
    ["legend entry options/label in legend one mark"] = {
      details = [[
To be used with scatter plots, since no line is drawn. Just displays a
single mark (this is the default with a scatter plot or when the
`no line` is selected.

    \tikz \datavisualization [visualize as scatter/.list={a,b,c},
       style sheet=cross marks,
      a={label in legend={text=example a}},
      b={label in legend={text=example b}},
      c={label in legend={text=example c}}];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/label:in:legend:one:mark"
    },
    ["legend entry options/label in legend three marks"] = {
      details = [[
An alternative to the previous style, where several marks are shown.

    \tikz \datavisualization [visualize as scatter/.list={a,b,c},
      style sheet=cross marks,
      a={label in legend={text=example a, label in legend three marks}},
      b={label in legend={text=example b, label in legend three marks}},
      c={label in legend={text=example c, label in legend three marks}}];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/label:in:legend:three:marks"
    },
    ["legend entry options/legend"] = {
      details = [[
Set this key to the name of a legend that has previously been created
using `new legend`. The label will then be shown in this legend.

In most cases, there is only one legend (namely `main legend`) and there
is no need to set this key since it defaults to the main legend.

Also note that the legend ⟨name⟩ is automatically created if it nodes
not yet exist.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/legend",
      meta = "⟨name⟩"
    },
    ["legend entry options/node style"] = {
      details = [[
This key adds ⟨options⟩ to the styling of the text nodes of the label.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=north east outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$,
          node style={circle, draw=red}}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/node:style",
      meta = "⟨options⟩"
    },
    ["legend entry options/setup"] = {
      details = [[
Some code to be executed at this point. Mostly, it is used to setup
attributes for style sheets.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/setup"
    },
    ["legend entry options/straight label in legend line"] = {
      details = [[
Just gives a straight line and two plot marks.

    \tikz \datavisualization [visualize as line,
      line={style={mark=x}, label in legend={text=example,
        straight label in legend line}}];

This style might seem like a good idea to use in general, but it does
have a huge drawback: Some commonly used plot marks will be impossible
to distinguish -- even though there is no problem distinguishing them in
a graph.

    \tikz \datavisualization [visualize as line/.list={a,b,c},
      legend entry options/default label in legend path/.style=
        straight label in legend line,
      a={style={mark=+}, label in legend={text=bad example a}},
      b={style={mark=-}, label in legend={text=bad example b}},
      c={style={mark=|}, label in legend={text=bad example c}}];

For this reason, this option is not the default, but rather the next
one.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/straight:label:in:legend:line"
    },
    ["legend entry options/text"] = {
      details = [[
Use this key to setup the ⟨text⟩ that is shown as the label of the data
set.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes, x axis={label=$x$},
      visualize as smooth line/.list=
      {log, lin, squared, exp},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={pin in data    ={text=$x^2$, pos=0.1}},
      exp=    {label in data  ={text=$e^x$}},
      style sheet=vary dashing]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/text",
      meta = "⟨text⟩"
    },
    ["legend entry options/text colored"] = {
      details = [[
Causes the `node style` to set the text color to `visualizer color`. The
effect of this is that the label's text will have the same color as the
data set to which it is attached.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend={label style=text colored},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/text:colored"
    },
    ["legend entry options/text left"] = {
      details = [[
Placed the text node to the left of the data set style visualization.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend={label style=text left},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/text:left"
    },
    ["legend entry options/text only"] = {
      details = [[
Shows only the text nodes and no data set style visualization at all.
This options only makes sense in conjunction with the `text colored`
options, which is why this options is also selected implicitly.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend={south east inside, rows=2,
              label style=text only},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/text:only"
    },
    ["legend entry options/text right"] = {
      details = [[
Placed the text node to the right of the data set style visualization.
This is the default for most, but not all, legends.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/text:right"
    },
    ["legend entry options/visualizer in legend"] = {
      details = [[
Set this key to some code that paints something in the cell picture.
Typically, this will be a visual representation of the data set styling,
but it could also be something different.

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      style sheet=vary dashing,
      a={label in legend={text=a}},
      new legend entry={
        text=spacer,
        visualizer in legend={\draw[solid] (0,0) circle[radius=2pt];}
      },
      b={label in legend={text=b}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/visualizer:in:legend"
    },
    ["legend entry options/visualizer in legend style"] = {
      details = [[
Calls to this key accumulate ⟨options⟩ that will be executed with the
path prefix `/tikz` at this point.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/visualizer:in:legend:style",
      meta = " {options}"
    },
    ["legend entry options/zig zag label in legend line"] = {
      details = [[
Uses a small up-down-up line as the label in legend visualizer. The two
plot marks are at the extremal points of the line. It works pretty well
in almost all situations and is the default.

    \tikz \datavisualization [
      visualize as line=a,
      visualize as smooth line/.list={b,c},
      a={style={mark=+}, label in legend={text=better example a}},
      b={style={mark=-}, label in legend={text=better example b}},
      c={style={mark=|}, label in legend={text=better example c}}];

Even though the above example shows that the marks are easier to
distinguish than with a straight line, the chosen marks are still not
optimal. This is the reason that the `cross marks` style uses different
crosses:

    \tikz \datavisualization [
      visualize as line/.list={a,b},
      visualize as smooth line=c,
      style sheet=cross marks,
      a={label in legend={text=good example a}},
      b={label in legend={text=good example b}},
      c={gap line, label in legend={text=good example c}}];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/zig:zag:label:in:legend:line"
    },
    ["legend options/above"] = {
      details = [[
This is an easier-to-remember alias.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/above"
    },
    ["legend options/above left of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/above:left:of",
      meta = "⟨data point⟩"
    },
    ["legend options/above of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/above:of",
      meta = "⟨data point⟩"
    },
    ["legend options/above right of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/above:right:of",
      meta = "⟨data point⟩"
    },
    ["legend options/anchor"] = {
      details = [[
The whole legend is a TikZ-matrix internally. Thus, in particular, it is
stored in a node, which has anchors. Like for any other node, when the
node is shown, the node is shifted in such a way that the ⟨anchor⟩ of
the node lies at the current `at` position.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/anchor",
      meta = "⟨anchor⟩"
    },
    ["legend options/at"] = {
      details = [[
Configures the ⟨coordinate⟩ at which the ⟨anchor⟩ of the legend's node
should lie.

It may seem hard to predict a good ⟨coordinate⟩ for a legend since,
depending of the size of the axis, different positions need to the
chosen for the legend. However, it turns out that one can often use the
coordinates of the special nodes `data bounding box` and
`data visualization bounding box`, documented in Section ??.

As an example, let us put a legend to the right of the visualization,
but so that the first entry starts at the top of the visualization:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes, x axis={label=$x$},
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend={anchor=north west, at=
        (data visualization bounding box.north east)},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=vary dashing]
    data group {function classes};

As can be seen, a bit of an additional shift might have been in order,
but the result is otherwise quite satisfactory.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/at",
      meta = "⟨coordinate⟩"
    },
    ["legend options/at values"] = {
      details = [[
This key allows you to specify the desired center of the legend in terms
of a data point. The ⟨data point⟩ should be a list of comma-separated
key--value pairs that specify a data point. The legend will then be
centered at this data point.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list={log, lin},
      legend={at values={x=-1, y=2}},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/at:values",
      meta = "⟨data point⟩"
    },
    ["legend options/below"] = {
      details = [[
This is an easier-to-remember alias.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/below"
    },
    ["legend options/below left of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/below:left:of",
      meta = "⟨data point⟩"
    },
    ["legend options/below of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/below:of",
      meta = "⟨data point⟩"
    },
    ["legend options/below right of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/below:right:of",
      meta = "⟨data point⟩"
    },
    ["legend options/columns"] = {
      details = [[
Shorthand for `ideal number of columns=`⟨number⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/columns",
      meta = "⟨number⟩"
    },
    ["legend options/down then left"] = {
      details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={down then left, columns=3}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/down:then:left"
    },
    ["legend options/down then right"] = {
      details = [[
Causes the legend entries to fill the legend matrix first downward and,
once a column is full, the next column is begun to the right of the
previous one. This is the default.

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={down then right, columns=3}]
    data group {sin functions};

In the example, the `legend example` is the following style:

    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/down:then:right"
    },
    ["legend options/east inside"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/east:inside"
    },
    ["legend options/east outside"] = {
      details = [[
Placing the legend to the right of the data visualization is the
default:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=east outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/east:outside"
    },
    ["legend options/every legend inside"] = {
      details = [[
Executed the keys `opaque` by default and sets the text size to the size
of footnotes.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/every:legend:inside"
    },
    ["legend options/every new legend"] = {
      details = [[
This key defaults to `east outside, label style=text right`. This means
that by default a legend is placed to the right of the data
visualization and that in the individual legend entries the text is to
the right of the data set visualization.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/every:new:legend"
    },
    ["legend options/ideal number of columns"] = {
      details = [[
Specifies, that the entries should be split into ⟨number⟩ different
columns, whenever possible. However, when there would be more than the
`max rows` value of rows per column, more columns than the ideal number
are created.

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={ideal number of columns=2}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={ideal number of columns=4}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={max rows=3,ideal number of columns=2}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/ideal:number:of:columns",
      meta = "⟨number⟩"
    },
    ["legend options/ideal number of rows"] = {
      details = [[
Works like `ideal number of columns`.

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={ideal number of rows=2}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={ideal number of rows=4}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={max columns=3,ideal number of rows=2}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/ideal:number:of:rows",
      meta = "⟨number⟩"
    },
    ["legend options/label style"] = {
      details = [[
This key can be used with a legend. It will simply add the ⟨options⟩ to
the `every label in legend` style for the given legend.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend={label style={node style=draw}},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$,
          node style={circle, draw=red}}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/label:style",
      meta = "⟨options⟩"
    },
    ["legend options/left"] = {
      details = [[
This is an easier-to-remember alias.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/left"
    },
    ["legend options/left of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/left:of",
      meta = "⟨data point⟩"
    },
    ["legend options/left then down"] = {
      details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={left then down, columns=3}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/left:then:down"
    },
    ["legend options/left then up"] = {
      details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={left then up, columns=3}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/left:then:up"
    },
    ["legend options/matrix node style"] = {
      details = [[
Adds the ⟨options⟩ to the list of options that will be executed when the
legend's node is created.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend={matrix node style={fill=black!25}},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=vary dashing]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/matrix:node:style",
      meta = "⟨options⟩"
    },
    ["legend options/max columns"] = {
      details = [[
This key works like `max rows`, only now the number of columns is
monitored. Note that this strategy only really makes sense when the when
you use this key with a strategy that first goes left or right and then
up or down.

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={right then down, max columns=2}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={right then down,max columns=3}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={right then down,max columns=4}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/max:columns",
      meta = "⟨number⟩"
    },
    ["legend options/max rows"] = {
      details = [[
As the legend matrix is being filled, whenever the number of rows in the
current column would exceed ⟨number⟩, a new column is started.

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={max rows=3}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={max rows=4}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={max rows=5}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/max:rows",
      meta = "⟨number⟩"
    },
    ["legend options/north east inside"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:east:inside"
    },
    ["legend options/north east outside"] = {
      details = [[
A variant, where the legend is to the right, but aligned with the
northern end of the data visualization:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=north east outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:east:outside"
    },
    ["legend options/north inside"] = {
      details = [[
As above.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:inside"
    },
    ["legend options/north outside"] = {
      details = [[
The legend is placed above the data. Note that the legend entries now
for a row rather than a column.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=north outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:outside"
    },
    ["legend options/north west inside"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:west:inside"
    },
    ["legend options/north west outside"] = {
      details = [[
     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=north west outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:west:outside"
    },
    ["legend options/opaque"] = {
      details = [[
When this key is used, the legend's node will be filled with the ⟨color⟩
and its corners will be rounded. Additionally, the inner and outer
separations will be set to sensible values.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/opaque",
      meta = "⟨color⟩"
    },
    ["legend options/right"] = {
      details = [[
This is an easier-to-remember alias.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/right"
    },
    ["legend options/right of"] = {
      details = [[
Works like `at values`, but the anchor is set to `west`:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list={log, lin},
      legend={right of={x=-1, y=2}},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/right:of",
      meta = "⟨data point⟩"
    },
    ["legend options/right then down"] = {
      details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={right then down, columns=3}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/right:then:down"
    },
    ["legend options/right then up"] = {
      details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={right then up, columns=3}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/right:then:up"
    },
    ["legend options/rows"] = {
      details = [[
Shorthand for `ideal number of rows=`⟨number⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/rows",
      meta = "⟨number⟩"
    },
    ["legend options/south east inside"] = {
      details = [[
Puts the legend in the upper right corner of the data.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin},
      legend=south east inside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      style sheet=strong colors]
    data group {function classes};

Note that the text is now a little smaller since there tends to be much
less space inside the data visualization than next to it. Also, the
legend's node is filled in white by default to ensures that the legend
is clearly legible even in the presence of, say, a grid or data points
behind it. This behavior is triggered by the following style key:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:east:inside"
    },
    ["legend options/south east outside"] = {
      details = [[
     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=south east outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:east:outside"
    },
    ["legend options/south inside"] = {
      details = [[
Puts the legend in the upper right corner of the data. Note that the
text is now a little smaller since there tends to be much less space
inside the data visualization than next to it.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list={log, lin},
      legend=south inside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:inside"
    },
    ["legend options/south outside"] = {
      details = [[
     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=south outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:outside"
    },
    ["legend options/south west inside"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:west:inside"
    },
    ["legend options/south west outside"] = {
      details = [[
     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=south west outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:west:outside"
    },
    ["legend options/transparent"] = {
      details = [[
Sets the filling of the legend node to `none`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/transparent"
    },
    ["legend options/up then left"] = {
      details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={up then left, columns=3}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/up:then:left"
    },
    ["legend options/up then right"] = {
      details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={up then right, columns=3}]
    data group {sin functions};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/up:then:right"
    },
    ["legend options/west inside"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/west:inside"
    },
    ["legend options/west outside"] = {
      details = [[
The legend is placed left. Note that the text also swaps its position.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=west outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/west:outside"
    },
    low = {
      details = [[
When used with the `visualize ticks` option, the `low` key contains a
dimension that specifies the extend of the tick going "toward the
minimum" of the direction axis. More precisely, when a tick mark is
visualized, a unit tangent vector at the current data point in the
direction of the `direction axis` is computed and this vector is
multiplied by ⟨dimension⟩ to compute the start position of the tick
line. The end position is given by this vector times the `high` value.

Note that the ⟨dimension⟩ should usually be negative for the `low` key
and positive for the `high` key.

For tick marks where a tick label node is shown, the ⟨dimension⟩ is
increased by the current values of keys like
`tick text even low padding`, see Section ?? for details.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/low",
      meta = "⟨dimension⟩"
    },
    major = {
      details = [[
The key can be passed as an option to the `ticks` key and also to the
`grid` key, which in turn is passed as an option to an axis. The
⟨options⟩ passed to `major` specify at which positions major ticks/grid
lines should be shown (using the `at` option and `also at` option) and
also any special styling. The different possible options are described
later in this section.

    \tikz \datavisualization
      [ school book axes, visualize as smooth line,
        x axis={ticks={major={at={1, 1.5, 2}}}}]
      data [format=function] {
        var x : interval [-1.25:2];
        func y = \value x * \value x / 2;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/major",
      meta = "⟨options⟩"
    },
    ["major also at"] = {
      details = [[
A shorthand for `major={also at={`⟨list⟩`}}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/major:also:at",
      meta = "⟨list⟩"
    },
    ["major at"] = {
      details = [[
A shorthand for `major={at={`⟨list⟩`}}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/major:at",
      meta = "⟨list⟩"
    },
    many = {
      details = [[
This is an abbreviation for `about=10`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/many"
    },
    minor = {
      details = [[
Like `major`, only for minor ticks/grid lines.

    \tikz \datavisualization
      [ school book axes, visualize as smooth line,
        x axis={grid={minor={at={1, 1.5, 2}}}}]
      data [format=function] {
        var x : interval [-1.25:2];
        func y = \value x * \value x / 2;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/minor",
      meta = "⟨options⟩"
    },
    ["minor also at"] = {
      details = [[
A shorthand for `major={also at={`⟨list⟩`}}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/minor:also:at",
      meta = "⟨list⟩"
    },
    ["minor at"] = {
      details = [[
A shorthand for `major={at={`⟨list⟩`}}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/minor:at",
      meta = "⟨list⟩"
    },
    ["minor steps between steps"] = {
      details = [[
Specifies that between any two major steps (whose positions are
specified by the `step` key), there should be ⟨number⟩ many minor steps.
Note that the default of `9` is exactly the right number so that each
interval between two minor steps is exactly a tenth of the size of a
major step. See also Section ?? for further details.

    \begin{tikzpicture}
      \datavisualization [school book axes, visualize as smooth line,
        x axis={ticks={minor steps between steps=3}},
        y axis={ticks={minor steps between steps}},
      ]
        data [format=function] {
          var x : interval [-1.5:1.5];
          func y = \value x*\value x;
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/minor:steps:between:steps",
      meta = "⟨number⟩"
    },
    ["new Cartesian axis"] = {
      details = [[
This key creates a new "Cartesian" axis, named ⟨name⟩. For such an axis,
the (scaled) values of the axis's attribute are transformed into a
displacement on the page along a straight line. The following key is
used to configure in which "direction" the axis points:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:Cartesian:axis",
      meta = "⟨name⟩"
    },
    ["new axis base"] = {
      details = [[
This key defines a new axis for the current data visualization called
⟨name⟩. This has two effects:

1.  A so called *scaling mapper* is created that will monitor a certain
    attribute, rescale it, and map it to another attribute. (This will
    be explained in detail in a moment.)

2.  The ⟨axis name⟩ is made available as a key that can be used to
    configure the axis:

3.  The ⟨axis name⟩ becomes part of the current set of axes. This set
    can be accessed through the following key:

There are many ⟨options⟩ that can be passed to a newly created axis.
They are explained in the rest of this section.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:axis:base",
      meta = "⟨axis name⟩"
    },
    ["new axis system"] = {
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:axis:system",
      meta = "{axis system name}{axis setup}{default options} {application options}"
    },
    ["new legend"] = {
      details = [[
This key is used to create a new legend named ⟨legend name⟩. The legend
is empty by default and further options are needed to add entries to it.
When the key is called a second time for the same ⟨legend name⟩ nothing
happens.

When a legend is created, a new key is created that can subsequently be
used to configure the legend:

In the end, the legend is just a TikZ node, a `matrix` node, to be
precise. The following key is used to style this node:

The following style allows you to configure the default appearance of
every newly created legend:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes, x axis={label=$x$},
      visualize as smooth line/.list={log, lin, squared, exp},
      new legend={upper legend},
      new legend={lower legend},
      upper legend=above,
      lower legend=below,
      log=    {label in legend={text=$\log x$, legend=upper legend}},
      lin=    {label in legend={text=$x/2$, legend=upper legend}},
      squared={label in legend={text=$x^2$, legend=lower legend}},
      exp=    {label in legend={text=$e^x$, legend=lower legend}},
      style sheet=vary dashing]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:legend",
      meta = "⟨legend name⟩"
    },
    ["new legend entry"] = {
      details = [[
This key will add a new entry to the legend that is identified by the
⟨options⟩. For this, the ⟨options⟩ are executed once with the path
prefix `/tikz/data visualization/legend entry options` and the resulting
setting of the `legend` key is used to pick which legend the new entry
should belong to. Then, the ⟨options⟩ are stored away for the time
being.

Later, when the legend is created, the ⟨options⟩ get executed once more.
This time, however, the `legend` key is no longer important. Instead,
the ⟨options⟩ that setup keys like `text` or `visualizer in legend` now
play a role.

In detail, the following happens:

-   For the legend entry, a little cell picture is created in the matrix
    of the legend (see Section ?? for details on cell pictures).

-   Inside this picture, a node is created whose text is taken from the
    key

        /tikz/data visualization/legend entry options/text

-   Also inside the picture, the code stored in the following key gets
    executed:

The following styles are applied in the following order before the cell
picture is filled:

1.  `/tikz/data visualization/every data set label` with path
    `/tikz/data visualization`

2.  `/tikz/data visualization/every label in legend` with path  
    `/tikz/data visualization/legend entry options`.

3.  The ⟨options⟩.

4.  The code in the following key:

5.  A styling signal is emitted.

6.  Only for the node: The current value of `node style`.

7.  Only for the visualizer in legend: The styling that has been
    accumulated by calls to the following key:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:legend:entry",
      meta = "⟨options⟩"
    },
    ["new object"] = {
      details = [[
This key serves two purposes:

1.  This method makes it easy to create a new object as part of the
    rendering pipeline, using ⟨options⟩ to specify arguments rather that
    directly calling `\pgfoonew`. Since you have the full power of the
    keys mechanism at your disposal, it is easy, for instance, to
    control whether or not parameters to the constructor are expanded or
    not.

2.  The object is not created immediately, but only just before the
    visualization starts. This allows you to specify that an object must
    be created, but the parameter values of for its constructor may
    depend on keys that are not yet set. A typical application is the
    creating of an axis object: When you say `scientific axes`, the
    `new object` command is used internally to create two objects
    representing these axes. However, keys like `x={length=5cm}` can
    only *later* be used to specify the parameters that need to be
    passed to the constructor of the objects.

The following keys may be used inside the ⟨options⟩:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:object",
      meta = "⟨options⟩"
    },
    ["new polar axes"] = {
      details = [[
This key actually creates two axes, whose names are give as parameters:
An *angle axis* and a *radius axis*. These two axes work in concert in
the following way: Suppose a data point has two attributes called
`angle` and `radius` (these attribute names can be changed by changing
the `attribute` of the ⟨angle axis name⟩ or the ⟨radius axis name⟩,
respectively). These two attributes are then scaled as usual, resulting
in two "reasonable" values $a$ (for the angle) and $r$ (for the radius).
Then, the data point gets visualized (in principle, details will follow)
at a position on the page that is at a distance of $r$ from the origin
and at an angle of $a$.

    \tikz \datavisualization
        [new polar axes={angle axis}{radius axis},
         radius axis={length=2cm},
         visualize as scatter]
      data [format=named] {
        angle={0,20,...,160}, radius={0,...,5}
      };

In detail, the ⟨angle axis⟩ keeps track of two vectors $v_0$ and
$v_{90}$, each of which will usually have unit length (length `1pt`) and
which point in two different directions. Given a radius $r$ (measured in
TeX `pt`s, so if the radius attribute `10pt`, then $r$ would be $10$)
and an angle $a$, let $s$ be the sine of $a$ and let $c$ be the cosine
of $a$, where $a$ is a number is degrees (so $s$ would be $1$ for
$a = 90$). Then, the current page position is shifted by $c \cdot r$
times $v_0$ and, additionally, by $s \cdot r$ times $v_{90}$. This means
that in the "polar coordinate system" $v_0$ is the unit vector along the
"$0^\circ$-axis" and $v_{90}$ is the unit vector along
"$90^\circ$-axis". The values of $v_0$ and $v_{90}$ can be changed using
the following key on the ⟨angle axis⟩:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:polar:axes",
      meta = "{⟨angle axis name⟩}{⟨radius axis name⟩}"
    },
    ["new visualizer"] = {
      details = [[
This key configures a new visualizer named ⟨name⟩. This entails the
following actions:

-   The key `/tikz/data visualization/`⟨name⟩ is created. As described
    earlier, this key can be used to pass for instance `style` options
    to the visualizer.

-   The style key
    `/tikz/data visualization/visualizers/`⟨name⟩`/styling` is created
    and made empty. This is the key in which the `style` key will store
    the options passed to the visualizer.

-   The style key
    `/tikz/data visualization/visualizers/`⟨name⟩`/label in legend options`
    is set to ⟨legend entry options⟩. These options are used to
    configure how the visualizer should be rendered in a legend, see
    Section ?? for details.

-   The key `/data point/set/`⟨name⟩ is set to a number that is
    increased for each visualizer in the current data visualization.
    This number is important for style sheets, see Section ??.

-   The key `/data point/`⟨name⟩`/execute at begin` is set to code that
    creates a `{scope}` that executes the following styles as options:

    1.  The ⟨options⟩ passed to the `new visualizer` key.

    2.  The `every visualizer` style.

    3.  The styling from the currently active style sheets, see
        Section ??.

    4.  The styling stored in the `styling` key mentioned above.

-   The key `/data point/`⟨name⟩`/execute at end` is set to code that
    will finish all paths that may have been created by the visualizer
    and closes the scope.

All of the above mean the following in practice:

-   Inside a new `visualize as ...` key, you pass the name of the
    to-be-created to `new visualizer` as the first parameter and any
    special default styling setup of the visualizer as the second
    parameter.

-   The new `visualize as ...` key should also create a visualizer
    object using `new object`.

-   When this object finally is about to create the actual
    visualization, it should surround the code by invoking the code
    stored in the `execute at begin` and the `execute at end` keys of
    the visualizer.

Everything else is usually taken care of by the `new visualizer` key
automatically.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:visualizer",
      meta = "{name}{options}{legend entry options}"
    },
    ["no tick text"] = {
      details = [[
Shorthand for `tick text at low=false, tick text at high=false`.

    \tikz \datavisualization [scientific axes, all axes={length=3cm},
                              x axis={ticks={
                                  major also at={6.5 as [no tick text]}}},
                              visualize as smooth line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/no:tick:text"
    },
    ["no tick text at"] = {
      details = [[
Shorthand for `options at=`⟨value⟩` as [no tick text]`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/no:tick:text:at",
      meta = "⟨value⟩"
    },
    ["node style"] = {
      details = [[
This key works like `style`, but it has an effect only on nodes that are
created during a data visualization. This includes tick labels and axis
labels:

    \tikz \datavisualization
      [scientific axes,
       all axes={ticks={node style=red}, length=3cm},
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };

Note that in the example the ticks themselves (the little thicker lines)
are not red.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/node:style",
      meta = "⟨tikzoptions⟩"
    },
    ["node styling"] = {
      details = [[
Executing this key will cause all "accumulated" node stylings to be
executed.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/node:styling"
    },
    none = {
      details = [[
Switches off the automatic step computation. Unless you use `step=`
explicitly to set a stepping, no ticks will be (automatically) added.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/none"
    },
    ["options at"] = {
      details = [[
This key causes the ⟨options⟩ to be executed for any tick mark(s) at
⟨value⟩ in addition to any options given already for this position:

    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line,
      x axis={ticks={major={
        options at = 3    as [no tick text],
        also at    = (pi) as
          [{tick text padding=1ex}] $\pi$}}}]
    data [format=function] {
      var x : interval[0:2*pi];
      func y = sin(\value x r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/options:at",
      meta = "⟨value⟩ as [⟨options⟩]"
    },
    padded = {
      details = [[
Shorthand for `low=padded min, high=padded max`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/padded"
    },
    phase = {
      details = [[
See Section ?? for details on how the phase of steps influences the tick
placement.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/phase",
      meta = "⟨value⟩"
    },
    ["quarter about strategy"] = {
      details = [[
Permissible values for $m'$ are: $1$, $2.5$, and $5$.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/quarter:about:strategy"
    },
    ["school book axes"] = {
      details = [[
This axis system is intended to "look like" the coordinate systems often
used in school books: The axes are drawn in such a way that they
intersect to origin. Furthermore, no automatic scaling is done to ensure
that the lengths of units are the same in all directions.

This axis system must be used with care -- it is nearly always necessary
to specify the desired unit length by hand using the option
`unit length`. If the magnitudes of the units on the two axes differ,
different unit lengths typically need to be specified for the different
axes.

Finally, if the data is "far removed" from the origin, this axis system
will also "look bad".

    \begin{tikzpicture}
      \datavisualization [school book axes, visualize as smooth line]
        data [format=function] {
          var x : interval [-1.3:1.3];
          func y = \value x*\value x*\value x;
        };
    \end{tikzpicture}

The stepping of the ticks is one unit by default. Using keys like
`ticks=some` may help to give better steppings.

The ⟨options⟩ are executed with the key itself as path prefix. Thus, the
following subkeys are permissible options:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/school:book:axes",
      meta = "⟨options⟩"
    },
    ["school book axes/standard labels"] = {
      details = [[
This key makes the label of the $x$-axis appear at the right end of this
axis and it makes the label of the $y$-axis appear at the top of the
$y$-axis.

Currently, this is the only supported placement strategy for the school
book axis system.

    \begin{tikzpicture}
      \datavisualization [school book axes={standard labels},
                          visualize as smooth line,
                          clean ticks,
                          x axis={label=$x$},
                          y axis={label=$f(x)$}]
        data [format=function] {
          var x : interval [-1:1];
          func y = \value x*\value x + 1;
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/school:book:axes/standard:labels"
    },
    ["school book axes/unit"] = {
      details = [[
Sets the scaling so that 1 cm corresponds to ⟨value⟩ units. At the same
time, the stepping of the ticks will also be set to ⟨value⟩.

    \begin{tikzpicture}
      \datavisualization [school book axes={unit=10},
                          visualize as smooth line,
                          clean ticks,
                          x axis={label=$x$},
                          y axis={label=$f(x)$}]
        data [format=function] {
          var x : interval [-20:20];
          func y = \value x*\value x/10;
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/school:book:axes/unit",
      meta = "⟨value⟩"
    },
    ["scientific axes"] = {
      details = [[
This key installs a two-dimensional coordinate system based on the
attributes `/data point/x` and `/data point/y`.

    \begin{tikzpicture}
      \datavisualization [scientific axes,
                          visualize as smooth line]
        data [format=function] {
          var x : interval [0:100];
          func y = sqrt(\value x);
        };
    \end{tikzpicture}

This axis system is usually a good choice to depict "arbitrary two
dimensional data". Because the axes are automatically scaled, you do not
need to worry about how large or small the values will be. The name
`scientific axes` is intended to indicate that this axis system is often
used in scientific publications.

You can use the ⟨options⟩ to fine tune the axis system. The ⟨options⟩
will be executed with the following path prefix:

    /tikz/data visualization/scientific axes

All keys with this prefix can thus be passed as ⟨options⟩.

This axis system will always distort the relative magnitudes of the
units on the two axis. If you wish the units on both axes to be equal,
consider directly specifying the unit length "by hand":

    \begin{tikzpicture}
      \datavisualization [visualize as smooth line,
                          scientific axes,
                          all axes={unit length=1cm per 10 units, ticks={few}}]
        data [format=function] {
          var x : interval [0:100];
          func y = sqrt(\value x);
        };
    \end{tikzpicture}

The `scientific axes` have the following properties:

-   The `x`-values are surveyed and the $x$-axis is then scaled and
    shifted so that it has the length specified by the following key.

    The minimum value is at the left end of the axis and at the canvas
    origin. The maximum value is at the right end of the axis.

-   The `y`-values are surveyed and the $y$-axis is then scaled so that
    is has the length specified by the following key.

    The minimum value is at the bottom of the axis and at the canvas
    origin. The maximum value is at the top of the axis.

-   Lines (forming a frame) are depicted at the minimum and maximum
    values of the axes in 50% black.

The following keys are executed by default as options: `outer ticks` and
`standard labels`.

You can use the following style to overrule the defaults:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes",
      meta = "⟨options⟩"
    },
    ["scientific axes/clean"] = {
      details = [[
The axes and the ticks are completely removed from the actual data,
making this axis system especially useful for scatter plots, but also
for most other scientific plots.

    \tikz \datavisualization [
      scientific axes=clean,
      visualize as smooth line]
    data [format=function] {
      var x : interval [-12:12];
      func y = \value x*\value x*\value x;
    };

The distance of the axes from the actual plot is given by the padding of
the axes.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/clean"
    },
    ["scientific axes/end labels"] = {
      details = [[
Places the labels at the end of the $x$- and the $y$-axis, similar to
the axis labels of a school book axis system.

    \tikz \datavisualization [
      scientific axes={clean, end labels},
      visualize as smooth line,
      x axis={label=degree $d$,
        ticks={tick unit={}^\circ}},
      y axis={label=$\tan d$}]
    data [format=function] {
      var x : interval [-80:80];
      func y = tan(\value x);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/end:labels"
    },
    ["scientific axes/height"] = {
      details = [[
By default, the `height` is the golden ratio times the `width`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/height",
      meta = "⟨dimension⟩"
    },
    ["scientific axes/inner ticks"] = {
      details = [[
This axis system works like `scientific axes`, only the ticks are on the
"inside" of the frame.

    \begin{tikzpicture}
      \datavisualization [scientific axes=inner ticks,
                          visualize as smooth line]
        data [format=function] {
          var x : interval [-12:12];
          func y = \value x*\value x*\value x;
        };
    \end{tikzpicture}

This axis system is also common in publications, but the ticks tend to
interfere with marks if they are near to the border as can be seen in
the following example:

    \begin{tikzpicture}
      \datavisualization [scientific axes={inner ticks, width=3.2cm},
                          style sheet=cross marks,
                          visualize as scatter/.list={a,b}]
        data [set=a] {
          x, y
          0, 0
          1, 1
          0.5, 0.5
          2, 1
        }
        data [set=b] {
          x, y
          0.05, 0
          1.5, 1
          0.5, 0.75
          2, 0.5
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/inner:ticks"
    },
    ["scientific axes/outer ticks"] = {
      details = [[
This causes the ticks to be drawn " on the outside" of the frame so that
they interfere as little as possible with the data. It is the default.

    \begin{tikzpicture}
      \datavisualization [scientific axes=outer ticks,
                          visualize as smooth line]
        data [format=function] {
          var x : interval [-12:12];
          func y = \value x*\value x*\value x;
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/outer:ticks"
    },
    ["scientific axes/standard labels"] = {
      details = [[
As the name suggests, this is the standard placement strategy. The label
of the $x$-axis is placed below the center of the $x$-axis, the label of
the $y$-axis is rotated by $90^\circ$ and placed left of the center of
the $y$-axis.

    \tikz \datavisualization
     [scientific axes={clean, standard labels},
      visualize as smooth line,
      x axis={label=degree $d$,
        ticks={tick unit={}^\circ}},
      y axis={label=$\sin d$}]
    data [format=function] {
      var x : interval [-10:10] samples 10;
      func y = sin(\value x);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/standard:labels"
    },
    ["scientific axes/upright labels"] = {
      details = [[
Works like `scientific axes standard labels`, only the label of the
$y$-axis is not rotated.

    \tikz \datavisualization [
      scientific axes={clean, upright labels},
      visualize as smooth line,
      x axis={label=degree $d$,
        ticks={tick unit={}^\circ}},
      y axis={label=$\cos d$, include value=1,
        ticks={style={
            /pgf/number format/precision=4,
            /pgf/number format/fixed zerofill}}}]
    data [format=function] {
      var x : interval [-10:10] samples 10;
      func y = cos(\value x);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/upright:labels"
    },
    ["scientific axes/width"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/width",
      meta = "⟨dimension⟩"
    },
    ["scientific polar axes"] = {
      details = [[
This key installs a polar axis system that can be used in a "scientific"
publication. Two axes are created called the `angle axis` and the
`radius axis`. Unlike "normal" Cartesian axes, these axes do not point
in a specific direction. Rather, the `radius axis` is used to map the
values of one attribute to a distance from the origin while the
`angle axis` is used to map the values of another attribute to a
rotation angle.

The ⟨options⟩ will be executed with the path prefix

    /tikz/data visualization/scientific polar axes

The permissible keys are documented in the later subsections of this
section.

Let us start with the configuration of the radius axis since it is
easier. Firstly, you should specify which attribute is linked to the
radius. The default is `radius`, but you will typically wish to change
this. As with any other axis, the `attribute` key is used to configure
the axis, see Section ?? for details. You can also apply all other
configurations to the radius axis like, say, `unit length` or `length`
or `style`. Note, however, that the `logarithmic` key will not work with
the radius axis for a `scientific polar axes` system since the attribute
value zero is always placed at the center -- and for a logarithmic plot
the value `0` cannot be mapped.

    \tikz \datavisualization [
      scientific polar axes,
      radius axis={
        attribute=distance,
        ticks={step=5000},
        padding=1.5em,
        length=3cm,
        grid
      },
      visualize as smooth line]
    data [format=function] {
      var  angle : interval [0:100];
      func distance = \value{angle}*\value{angle};
    };

For the `angle axis`, you can also specify an attribute using the
`attribute` key. However, for this axis the mapping of a value to an
actual angle is a complicated process involving many considerations of
how the polar axis system should be visualized. For this reason, there
are a large number of predefined such mappings documented in Section ??.
Finally, as for a `scientific plot`, you can configure where the ticks
should be shown using the keys `inner ticks`, `outer ticks`, and
`clean`, documented below.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:polar:axes",
      meta = "⟨options⟩"
    },
    ["scientific polar axes/clean"] = {
      details = [[
This key separates the area where the data is shown from the area where
the ticks are shown. Usually, this is the best choice for the tick
placement since it avoids a collision of data and explanations.

    \tikz \datavisualization [
      scientific polar axes={clean, 0 to 180},
      visualize as smooth line]
    data [format=function] {
      var  angle : interval [0:100];
      func radius = \value{angle};
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:polar:axes/clean"
    },
    ["scientific polar axes/inner ticks"] = {
      details = [[
This key causes the ticks to be "turned to the inside". I do not
recommend using this key.

    \tikz \datavisualization [
      scientific polar axes={inner ticks, 0 to 180},
      visualize as smooth line]
    data [format=function] {
      var  angle : interval [0:100];
      func radius = \value{angle};
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:polar:axes/inner:ticks"
    },
    ["scientific polar axes/outer ticks"] = {
      details = [[
This key, which is the default, causes ticks to be drawn "outside" the
outer "ring" of the polar axes:

    \tikz \datavisualization [
      scientific polar axes={outer ticks, 0 to 180},
      visualize as smooth line]
    data [format=function] {
      var  angle : interval [0:100];
      func radius = \value{angle};
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:polar:axes/outer:ticks"
    },
    some = {
      details = [[
This is an abbreviation for `about=5`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/some"
    },
    stack = {
      details = [[
Shorthand for `tick text even padding=`⟨dimension⟩.

    \tikz \datavisualization [scientific axes,
                              all axes={length=2.5cm},
                              x axis={ticks={stack=1.5em}},
                              visualize as smooth line]
      data [format=function] {
        var y : interval[-100:100];
        func x = \value y*\value y;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/stack",
      meta = "⟨dimension⟩"
    },
    ["stack'"] = {
      details = [[
Shorthand for `tick text odd padding=`⟨dimension⟩. The difference to
`stack` is that the set of value that are "lowered" is exactly exchanged
with the set of value "lowered" by `stack`.

    \tikz \datavisualization [scientific axes,
                              all axes={length=2.5cm},
                              x axis={ticks=stack'},
                              visualize as smooth line]
      data [format=function] {
        var y : interval[-100:100];
        func x = \value y*\value y;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/stack'",
      meta = "⟨dimension⟩"
    },
    ["standard about strategy"] = {
      details = [[
Permissible values for $m'$ are: $1$, $2$, $2.5$, and $5$. This strategy
is the default strategy.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/standard:about:strategy"
    },
    step = {
      details = [[
The value of this key is used to determine the spacing of the major
ticks. The key is used by the `linear steps` and `exponential steps`
strategies, see the explanations in Section ?? for details. Basically,
all ticks are placed at all multiples of ⟨value⟩ that lie in the
attribute range interval.

    \tikz \datavisualization [
        school book axes, visualize as smooth line,
        y axis={ticks={step=1.25}},
      ]
        data [format=function] {
          var x : interval [0:3];
          func y = \value x*\value x/2;
        };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/step",
      meta = "⟨value⟩"
    },
    store = {
      details = [[
If the ⟨key name⟩ is not empty, once the object has been created, a
handle to the object will be stored in ⟨key name⟩. If a handle is
already stored in ⟨key name⟩, the object is not created twice.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/store",
      meta = "⟨key name⟩"
    },
    style = {
      details = [[
This key takes options whose path prefix is `/tikz`, not
`/tikz/data visualization`. These options will be *appended* to a
current list of such options (thus, multiple calls of this key
accumulate). The resulting list of keys is not executed immediately, but
it will be executed whenever the data visualization engine calls the
TikZ layer to draw something (this placed will be indicated in the
following).

    \tikz \datavisualization
      [scientific axes,
       all axes={ticks={style=blue}, length=3cm},
       y axis={grid, grid={minor steps between steps, major={style=red}}},
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/style",
      meta = "⟨tikzoptions⟩"
    },
    ["style sheet"] = {
      details = [[
Adds the ⟨style sheet⟩ to the list of style sheets attached to the `set`
attribute.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      school book axes, all axes={unit length=7.5mm},
      visualize as smooth line/.list={log, lin, squared, exp},
      style sheet=vary thickness and dashing,
      style sheet=vary hue]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/style:sheet",
      meta = "⟨style sheet⟩"
    },
    styling = {
      details = [[
Executing this key will cause all "accumulated" TikZ options from
previous calls to the key `/tikz/data visualization/style` to be
executed. Thus, you use `style` to set TikZ options, but you use
`styling` to actually apply these options. Usually, you do not call this
option directly since this application is only done deep inside the data
visualization engine.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/styling"
    },
    subminor = {
      details = [[
Like `major`, only for subminor ticks/grid lines.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/subminor",
      meta = "⟨options⟩"
    },
    ["subminor also at"] = {
      details = [[
A shorthand for `major={also at={`⟨list⟩`}}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/subminor:also:at",
      meta = "⟨list⟩"
    },
    ["subminor at"] = {
      details = [[
A shorthand for `major={at={`⟨list⟩`}}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/subminor:at",
      meta = "⟨list⟩"
    },
    ["tick layer"] = {
      details = [[
Like `grid layer`, this key specifies on which layer the ticks should be
placed.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:layer"
    },
    ["tick length"] = {
      details = [[
Shorthand for `low=-`⟨dimension⟩`, high=`⟨dimension⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:length",
      meta = "⟨dimension⟩"
    },
    ["tick node layer"] = {
      details = [[
Like `tick layer`, but now for the nodes. By default, tick nodes are
placed on the main layer and thus on top of the data in case that the
tick nodes are inside the data.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:node:layer"
    },
    ["tick prefix"] = {
      details = [[
The ⟨text⟩ will be put in front of every typeset tick:

    \tikz \datavisualization
      [scientific axes, all axes={ticks=few, length=2.5cm},
       x axis={ticks={tick prefix=$\langle$, tick suffix=$]$}},
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:prefix",
      meta = "⟨text⟩"
    },
    ["tick suffix"] = {
      details = [[
Works like `tick prefix`. This key is especially useful for adding units
like "cm" or "$\mathrm m/\mathrm s$" to every tick label. For this
reason, there is a (near) alias that is easier to memorize:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:suffix",
      meta = "⟨text⟩"
    },
    ["tick text at high"] = {
      details = [[
Like `tick text at low`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:at:high",
      meta = "⟨true or false⟩"
    },
    ["tick text at low"] = {
      details = [[
Pass this option to `visualize ticks` when you want tick label nodes to
be placed at the `low` position of each tick mark.

    \tikzset{
      data visualization/our system/.append style={
        x axis={
          visualize ticks={direction axis=left axis, left axis={goto=min},
                           high=0pt, tick text at low, stack},
          visualize ticks={direction axis=left axis, left axis={goto=max},
                           low=0pt, tick text at high, stack}
        }
      }
    }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, length=3cm, ticks=some},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={people 1, people 2, money 1, money 2}]
      data group {people and money};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:at:low",
      meta = "⟨true or false⟩"
    },
    ["tick text even padding"] = {
      details = [[
A shorthand for setting `tick text even low padding` and
`tick text even high padding` at the same time.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:even:padding",
      meta = "⟨dimension⟩"
    },
    ["tick text high even padding"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:high:even:padding",
      meta = "⟨dimension⟩"
    },
    ["tick text high odd padding"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:high:odd:padding",
      meta = "⟨dimension⟩"
    },
    ["tick text low even padding"] = {
      details = [[
When a tick label is shown at the low position of an even tick, the
⟨distance⟩ is added to the `low` value, see also Section ??.

    \tikz \datavisualization [scientific axes,
                              all axes={length=2.5cm},
                              x axis={ticks={tick text low even padding=-1em}},
                              visualize as smooth line]
      data [format=function] {
        var y : interval[-100:100];
        func x = \value y*\value y;
      };

Note that ⟨dimension⟩ should usually be non-positive.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:low:even:padding",
      meta = "⟨dimension⟩"
    },
    ["tick text low odd padding"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:low:odd:padding",
      meta = "⟨dimension⟩"
    },
    ["tick text odd padding"] = {
      details = [[
A shorthand for setting `tick text odd low padding` and
`tick text odd high padding` at the same time.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:odd:padding",
      meta = "⟨dimension⟩"
    },
    ["tick text padding"] = {
      details = [[
Sets all text paddings to ⟨dimension⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:padding",
      meta = "⟨dimension⟩"
    },
    ["tick typesetter"] = {
      details = [[
The key gets called for each number that should be typeset. The argument
⟨value⟩ will be in scientific notation (like `1.0e1` for $10$). By
default, this key applies `\pgfmathprintnumber` to its argument. This
command is a powerful number printer whose configuration is documented
in Section ??.

You are invited to code underlying this key so that a different
typesetting mechanism is used. Here is a (not quite finished) example
that shows how, say, numbers could be printed in terms of multiples of
$\pi$:

    \def\mytypesetter#1{%
      \pgfmathparse{#1/pi}%
      \pgfmathprintnumber{\pgfmathresult}$\pi$%
    }
    \tikz \datavisualization
      [school book axes, all axes={unit length=1.25cm},
       x axis={ticks={step=(0.5*pi), tick typesetter/.code=\mytypesetter{##1}}},
       y axis={include value={-1,1}},
       visualize as smooth line]
      data [format=function] {
        var x : interval [0.5:7];
        func y = sin(\value x r);
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:typesetter",
      meta = "⟨value⟩"
    },
    ["tick unit"] = {
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:unit",
      meta = "⟨roman math text⟩"
    },
    ["uv Cartesian"] = {
      details = [[
This axis system works like `xy Cartesian`, but it introduces two axes
called `u axis` and `v axis` rather than the `x axis` and the `y axis`.
The idea is that in addition to a "major" $xy$-coordinate system this is
also a "smaller" or "minor" coordinate system in use for depicting, say,
small vectors with respect to this second coordinate system.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/uv:Cartesian"
    },
    ["uv axes"] = {
      details = [[
Applies the ⟨options⟩ to both the `u axis` and the `y axis`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/uv:axes",
      meta = "⟨options⟩"
    },
    ["uvw Cartesian cabinet"] = {
      details = [[
Like `xyz Cartesian cabinet`, but for the $uvw$-system.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/uvw:Cartesian:cabinet"
    },
    ["uvw axes"] = {
      details = [[
Like `xyz axes`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/uvw:axes",
      meta = "⟨options⟩"
    },
    ["visualizer label options/auto"] = {
      details = [[
This key is executed automatically by default. It works like the `pos`
option, where the ⟨fraction⟩ is set to $(⟨data set's
        index⟩-1/2)/⟨number of data sets⟩$. For instance, when there are
$10$ data sets, the fraction for the first one will be $5\%$, the
fraction for the second will be $15\%$, for the third it will be $25\%$,
ending with $95\%$ for the last one.

The net effect of all this is that when there are several lines, labels
will be placed at different positions along the lines with hopefully
only little overlap.

    \tikz \datavisualization [
      scientific axes=clean,
      visualize as smooth line/.list={linear, squared, cubed},
      linear ={label in data={text=$2x$}},
      squared={label in data={text=$x^2$}},
      cubed  ={label in data={text=$x^3$}}]
    data [set=linear, format=function] {
      var x : interval [0:1.5];
      func y = 2*\value x;
    }
    data [set=squared, format=function] {
      var x : interval [0:1.5];
      func y = \value x * \value x;
    }
    data [set=cubed, format=function] {
      var x : interval [0:1.5];
      func y = \value x * \value x * \value x;
    };

As can be seen in the example, the result is not always satisfactory. In
this case, the `pin in data` option might be preferable, see below.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/auto"
    },
    ["visualizer label options/index"] = {
      details = [[
This key chooses the ⟨number⟩th data point belonging to the visualizer's
data set.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      school book axes,
      x axis={label=$x$},
      visualize as smooth line/.list={exp},
      exp=    {label in data={text=$5$, index=5},
               label in data={text=$10$, index=10},
               label in data={text=$20$, index=20},
               style={mark=x}},
      style sheet=vary hue]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/index",
      meta = "⟨number⟩"
    },
    ["visualizer label options/node style"] = {
      details = [[
Just passes the options to `/tikz/data visualization/node style`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/node:style",
      meta = "⟨options⟩"
    },
    ["visualizer label options/pin angle"] = {
      details = [[
The position of the label of a `pin in data` is mainly computed in the
same way as for a `label in data`. However, once the position has been
computed, the label is shifted as follows:

-   When an ⟨angle⟩ is specified using the present key, the shift is by
    the current value of `pin length` in the direction of ⟨angle⟩.

-   When ⟨angle⟩ is empty (which is the default), then the shift is also
    by the current value of `pin length`, but now in the direction that
    is orthogonal and to the left of the line between the coordinate of
    the data point and the coordinate of the next data point. When
    `text’` is used, the direction is to the right instead of the left.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/pin:angle",
      meta = "⟨angle⟩"
    },
    ["visualizer label options/pin length"] = {
      details = [[
See the description of `pin angle`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/pin:length",
      meta = "⟨dimension⟩"
    },
    ["visualizer label options/pos"] = {
      details = [[
This key chooses the first data point belonging to the data set whose
index is at least ⟨fraction⟩ times the number of all data points in the
data set.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      school book axes,
      x axis={label=$x$},
      visualize as smooth line=exp,
      exp=    {label in data={text=$.2$, pos=0.2},
               label in data={text=$.5$, pos=0.5},
               label in data={text=$.95$, pos=0.95},
               style={mark=x}},
      style sheet=vary hue]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/pos",
      meta = "⟨fraction⟩"
    },
    ["visualizer label options/text"] = {
      details = [[
This is the text that will be displayed next to the data. It will be to
the "left" of the data, see the description below.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/text",
      meta = "⟨text⟩"
    },
    ["visualizer label options/text colored"] = {
      details = [[
Causes the `node style` to set the text color to `visualizer color`. The
effect of this is that the label's text will have the same color as the
data set to which it is attached.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/text:colored"
    },
    ["visualizer label options/text'"] = {
      details = [[
Like `text`, only the text will be to the "right" of the data.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/text'",
      meta = "⟨text⟩"
    },
    ["visualizer label options/when"] = {
      details = [[
This key causes the value of the ⟨attribute⟩ to be monitored in the
stream of data points. The chosen is data point is the first data point
where the ⟨attribute⟩ is at least ⟨number⟩ (if this never happens, the
last data point is used).

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      school book axes,
      x axis={label=$x$},
      visualize as smooth line/.list={log, lin, squared, exp},
      log=    {label in data={text'=$\log x$, when=y is -1,
                              text colored}},
      lin=    {label in data={text=$x/2$,     when=x is 2}},
      squared={label in data={text=$x^2$,     when=x is 1.1}},
      exp=    {label in data={text=$e^x$,     when=x is -2,
                              text colored}},
      style sheet=vary hue]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/when",
      meta = "⟨attribute⟩ is⟨number⟩"
    },
    ["visualizer options/gap cycle"] = {
      details = [[
Like `gapped line`, only with a cycle:

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={gap cycle}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/gap:cycle"
    },
    ["visualizer options/gap line"] = {
      details = [[
This key causes the data points to be connected by lines that "do not
quite touch" the data points. This is implemented by using the
`\pgfplothandlergaplineto`, see Section ??.

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={gap line}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/gap:line"
    },
    ["visualizer options/ignore style sheets"] = {
      details = [[
This option, which should be passed to a visualizer after its creation
before another visualizer is created, causes style sheets *not* to apply
to the visualizer (but the `style` option will still have an effect).
This allows you to create visualizers that are used for special purposes
and that do not "take part" in the usual styling. For instance, a
visualizer might be used internally to depict a regression line, even
though the regression line itself should not participate in the usual
styling by, say, dashing or different coloring.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/ignore:style:sheets"
    },
    ["visualizer options/label in data"] = {
      details = [[
This key is passed to a visualizer that has previously been created
using keys starting `visualize as ...`. It will create a label inside
the data visualization "next" to the visualizer (the details are
explained in a moment). You can use this key multiple times with a
visualizer to create multiple labels at different points with different
texts.

The ⟨options⟩ determine which text is shown and where it is shown. They
are executed with the following path prefix:

    /tikz/data visualization/visualizer label options

In order to configure which text is shown and where, use the following
keys inside the ⟨options⟩:

The following keys are used to configure where the label will be shown.
They use different strategies to specify one data point where the label
will be anchored. The coordinate of this data point will be stored in
`(label` `visualizer` `coordinate)`. Independently of the strategy, once
the data point has been chosen, the coordinate of the next data point is
stored in `(label` `visualizer` `coordinate’)`. Then, a (conceptual)
line is created from the first coordinate to the second and a node is
placed at the beginning of this line to its "left" or, for the `text’`
option, on its "right". More precisely, an automatic anchor is computed
for a node placed implicitly on this line using the `auto` option or,
for the `text’` option, using `auto,swap`.

The node placed at the position computed in this way will have the
⟨text⟩ set by the `text` or `text’` option and its styling is determined
by the current `node style`.

Let us now have a look at the different ways of determining the data
point at which the label in anchored:

The following keys allow you to style labels.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/label:in:data",
      meta = "⟨options⟩"
    },
    ["visualizer options/label in legend"] = {
      details = [[
This key is passed to a data set, similar to options like `pin in data`
or `smooth line`. The ⟨options⟩ are used to configure the following:

-   The legend in which the data set should be visualized.

-   The text that is to be shown in the legend for the data set.

-   The appearance of the legend entries.

In detail, the ⟨options⟩ are executed with the path prefix

    /tikz/data visualization/legend entry options

To configure in which legend the label should appear, use the following
key:

In addition to the two keys described above, there are further keys that
are described in Section ??.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/label:in:legend",
      meta = "⟨options⟩"
    },
    ["visualizer options/label in legend options"] = {
      details = [[
Use this key with a visualizer to configure the label in legend options.
Typically, this key is used only internally by a visualizer upon its
creating to set the ⟨options⟩ to setup the `visualizer in legend` key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/label:in:legend:options",
      meta = "⟨options⟩"
    },
    ["visualizer options/no lines"] = {
      details = [[
Suppresses the line. This option only makes sense when the `mark` option
is used.

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={no lines, style={mark=x}}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/no:lines"
    },
    ["visualizer options/pin in data"] = {
      details = [[
This key is a variant of the `label in data` key and takes the same
options, plus two additional ones. The difference to `label in data` is
that the label node is shown a bit removed from the data set, but
connected to it via a small line (this is like the difference between
the `label` and `pin` options).

    \tikz \datavisualization [
      scientific axes=clean,
      visualize as smooth line/.list={linear, squared, cubed},
      linear ={pin in data={text=$2x$}},
      squared={pin in data={text=$x^2$}},
      cubed  ={pin in data={text=$x^3$}}]
    data [set=linear, format=function] {
      var x : interval [0:1.5];
      func y = \value x;
    }
    data [set=squared, format=function] {
      var x : interval [0:1.5];
      func y = \value x * \value x;
    }
    data [set=cubed, format=function] {
      var x : interval [0:1.5];
      func y = \value x * \value x * \value x;
    };

The following keys can be used additionally:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      school book axes,
      x axis={label=$x$},
      visualize as smooth line/.list={log, lin, squared, exp},
      every data set label/.append style={text colored},
      log=    {pin in data={text'=$\log x$, when=y is -1}},
      lin=    {pin in data={text=$x/2$, when=x is 2,
                            pin length=1ex}},
      squared={pin in data={text=$x^2$, when=x is 1.1,
                            pin angle=230}},
      exp=    {label in data={text=$e^x$, when=x is -2}},
      style sheet=vary hue]
    data group {function classes};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/pin:in:data",
      meta = "⟨options⟩"
    },
    ["visualizer options/polygon"] = {
      details = [[
This is an alias for `straight cycle`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/polygon"
    },
    ["visualizer options/smooth cycle"] = {
      details = [[
Causes the data points to be connected by a circular line that is
smoothed at the joins:

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={smooth cycle}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/smooth:cycle"
    },
    ["visualizer options/smooth line"] = {
      details = [[
Causes the data points to be connected by a line that is smoothed at the
joins:

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={smooth line}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/smooth:line"
    },
    ["visualizer options/straight cycle"] = {
      details = [[
Causes the data points to be connected by a polygon.

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={straight cycle}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/straight:cycle"
    },
    ["visualizer options/straight line"] = {
      details = [[
Causes the data points to be connected by straight lines.

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={straight line}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/straight:line"
    },
    ["visualizer options/style"] = {
      details = [[
The ⟨options⟩ given to this key should be normal TikZ options. They will
be executed when the visualizer is used.

    \tikz \datavisualization
     [scientific axes=clean,
      visualize as smooth line=sin,
      sin={style={red, densely dotted}},
      visualize as smooth line=cos,
      cos={style={mark=x}},
    ]
    data [set=sin, format=function] {
      var x : interval[0:3*pi];
      func y = sin(\value x r);
    }
    data [set=cos, format=function] {
      var x : interval[0:3*pi];
      func y = cos(\value x r);
    };

When you have multiple visualizers in a single data visualization, you
can use the `style` option with each visualizer to configure their
different appearances as in the above example. However, it is usually
much better (and easier) to use a style sheet, see Section ??.

    \tikz \datavisualization
     [scientific axes={clean, end labels},
      x axis={label=$x$}, y axis={grid={major also at=0}},
      visualize as smooth line/.list={sin,cos,sin 2,cos 2},
      legend={below, rows=2},
      sin={label in legend={text=$\sin x$}},
      cos={label in legend={text=$\cos x$}},
      sin 2={label in legend={text=$\sin 2x$}},
      cos 2={label in legend={text=$\cos 2x$}},
      style sheet=strong colors]
    data [set=sin, format=function] {
      var x : interval[0:3*pi];
      func y = sin(\value x r);
    }
    data [set=cos, format=function] {
      var x : interval[0:3*pi];
      func y = cos(\value x r);
    }
    data [set=sin 2, format=function] {
      var x : interval[0:3*pi];
      func y = sin(2*\value x r);
    }
    data [set=cos 2, format=function] {
      var x : interval[0:3*pi];
      func y = cos(2*\value x r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/style",
      meta = "⟨options⟩"
    },
    when = {
      details = [[
This key is used to specify when the object is to be created. As
described above, the object is not created immediately, but at some time
during the rendering process. You can specify any of the phases defined
by the data visualization object, see Section ?? for details.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/when",
      meta = "⟨phase name⟩"
    },
    ["xy Cartesian"] = {
      details = [[
This axis system creates two axes called `x axis` and `y axis` that
point right and up, respectively. By default, one unit is mapped to one
cm.

    \begin{tikzpicture}
      \datavisualization [xy Cartesian, visualize as smooth line]
        data [format=function] {
          var x : interval [-1.25:1.25];
          func y = \value x*\value x*\value x;
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/xy:Cartesian"
    },
    ["xy axes"] = {
      details = [[
This key applies the ⟨options⟩ both to the `x axis` and the `y axis`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/xy:axes",
      meta = "⟨options⟩"
    },
    ["xyz Cartesian cabinet"] = {
      details = [[
This axis system works like `xy Cartesian`, only it *additionally*
creates an axis called `z axis` that points left and down. For this
axis, one unit corresponds to $\frac{1}{2}\sin 45^\circ\mathrm{cm}$.
This is also known as a cabinet projection.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/xyz:Cartesian:cabinet"
    },
    ["xyz axes"] = {
      details = [[
This key applies the ⟨options⟩ both to the `x axis` and the `y axis`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/xyz:axes",
      meta = "⟨options⟩"
    },
    ["⟨axis name⟩"] = {
      details = [[
This key becomes available once `new axis base=`metaaxis name has been
called. It will execute the ⟨options⟩ with the path prefix
`/tikz/data visualization/axis options`.

    [new axis base=my axis,
     my axis={attribute=some attribute}]
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/⟨axis:name⟩",
      meta = "⟨options⟩"
    },
    ["⟨axis system name⟩"] = {
      details = [[
When the key ⟨axis system name⟩ is used, the following keys will be
executed in the following order:

1.  The ⟨axis setup⟩ with the path prefix `/tikz/data visualization/`.

2.  The ⟨default options⟩ with the same path prefix.

3.  The following style:

4.  The ⟨options⟩ with the path prefix `/tikz/data visualization/`⟨axis
    system name⟩.

5.  The ⟨application options⟩ with the path prefix
    `/tikz/data visualization/`
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/⟨axis:system:name⟩",
      meta = "⟨options⟩"
    },
    ["⟨legend name⟩"] = {
      details = [[
When this key is used, the ⟨options⟩ are executed with the path prefix

    /tikz/data visualization/legend options

The different keys with this path prefix allow you to change the
position where the legend is shown and how it is organised (for
instance, whether legend entries are shown in a row or in a column or in
a square).

The different possible keys will be explained in the course of this
section.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/⟨legend:name⟩",
      meta = "⟨options⟩"
    },
    ["⟨visualizer name⟩"] = {
      details = [[
For each visualizer, a key of the same name is created with the path
prefix `/tikz/data visualization`. This key takes the ⟨options⟩ and
executes them with the path prefix

    /tikz/data visualization/visualizer options/

These options are then used to configure the appearance of the current
visualizer. (This is quite similar to the way options are passed to an
axis in order to configure the axis.) Possible options include `style`,
but also `label in legend` and `label in data`. The latter two options
are discussed in Section ??, the first option below.

    \tikz \datavisualization
     [scientific axes=clean,
      visualize as smooth line/.list={sin, cos},
      sin={style=red},
      cos={style=blue}]
    data [set=sin, format=function] {
      var x : interval[0:3*pi];
      func y = sin(\value x r);
    }
    data [set=cos, format=function] {
      var x : interval[0:3*pi];
      func y = cos(\value x r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/⟨visualizer:name⟩",
      meta = "⟨options⟩"
    }
  },
  graphs = {
    ["--"] = {
      details = [[
Sets the `default edge kind` to `–`.

    \tikz \graph { subgraph K_n [--, n=5, clockwise, radius=6mm] };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/--"
    },
    ["->"] = {
      details = [[
Sets the `default edge kind` to `->`.

    \tikz \graph { subgraph K_n [->, n=5, clockwise, radius=6mm] };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/->"
    },
    ["-\\protect\\exclamationmarktext-"] = {
      details = [[
Sets the `default edge kind` to `-!-`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/-\\protect\\exclamationmarktext-"
    },
    ["<-"] = {
      details = [[
Sets the `default edge kind` to `<-`.

    \tikz \graph { subgraph K_n [<-, n=5, clockwise, radius=6mm] };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/<-"
    },
    ["<->"] = {
      details = [[
Sets the `default edge kind` to `<->`.

    \tikz \graph { subgraph K_n [<->, n=5, clockwise, radius=6mm] };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/<->"
    },
    ["Cartesian placement"] = {
      details = [[
This strategy is the default strategy. It works, roughly, as follows:
For each new node on a chain, advance a "logical width" counter and for
each new node in a group, advance a "logical depth" counter. When a
chain contains a whole group, then the "logical width" taken up by the
group is the maximum over the logical widths taken up by the chains
inside the group; and symmetrically the logical depth of a chain is the
maximum of the depths of the groups inside it.

This slightly confusing explanation is perhaps best exemplified. In the
below example, the two numbers indicate the two logical width and depth
of each node as computed by the `graphs` library. Just ignore the arcane
code that is used to print these numbers.

    \tikz
      \graph [nodes={align=center, inner sep=1pt}, grow right=7mm,
              typeset={\tikzgraphnodetext\\[-4pt]
                       \tiny\mywidth\\[-6pt]\tiny\mydepth},
              placement/compute position/.append code=
                \pgfkeysgetvalue{/tikz/graphs/placement/width}{\mywidth}
                \pgfkeysgetvalue{/tikz/graphs/placement/depth}{\mydepth}]
    {
      a,
      b,
      c -> d -> {
        e -> f -> g,
        h -> i
      } -> j,
      k -> l
    };

You will find a detailed description of how these logical units are
computed, exactly, in Section ??.

Now, even though we talk about "widths" and "depths" and even though by
default a graph "grows" to the right and down, this is by no means
fixed. Instead, you can use the following keys to change how widths and
heights are interpreted:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/Cartesian:placement"
    },
    V = {
      details = [[
Sets a list of vertex names for use with graphs like `subgraph I_ n` and
also other graphs. This list is available in the macro `\tikzgraphV`.
The number of elements of this list is available in `\tikzgraphVnum`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/V",
      meta = "{list of vertices}"
    },
    W = {
      details = [[
Sets the list of vertices for the `W` set. The elements and their number
are available in the macros `\tikzgraphW` and `\tikzgraphWnum`,
respectively.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/W",
      meta = "{list of vertices}"
    },
    as = {
      details = [[
The ⟨text⟩ is used as the text of the node. This allows you to provide a
text for the node that differs arbitrarily from the name of the node.

    \tikz \graph { a [as=$x$] -- b [as=$y_5$] -> c [red, as={a--b}] };

This key always takes precedence over all of the mechanisms described
below.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/as",
      meta = "⟨text⟩"
    },
    ["branch down"] = {
      details = [[
    \tikz \graph [branch down=7mm] { a -> b -> {c, d, e}};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:down",
      meta = "⟨distance⟩"
    },
    ["branch down sep"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:down:sep",
      meta = "⟨distance⟩"
    },
    ["branch left"] = {
      details = [[
    \tikz \graph [branch left=7mm, grow down=7mm] { a -> b -> {c, d, e}};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:left",
      meta = "⟨distance⟩"
    },
    ["branch left sep"] = {
      details = [[
    \tikz \graph [grow down sep, branch left sep] {
      start -- {
        an even longer text -- {short, very long text} -- more text,
        long -- longer,
        some text -- a -- b
      } -- end
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:left:sep",
      meta = "⟨distance⟩"
    },
    ["branch right"] = {
      details = [[
    \tikz \graph [branch right=7mm, grow down=7mm] { a -> b -> {c, d, e}};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:right",
      meta = "⟨distance⟩"
    },
    ["branch right sep"] = {
      details = [[
This key works like `grow right sep`, only it affects groups rather than
chains.

    \tikz \graph [grow down, branch right sep] {
      start -- {
        an even longer text -- {short, very long text} -- more text,
        long -- longer -- longest,
        some text -- a -- b
      } -- end
    };

When both this key and, say, `grow down sep` are set, instead of the
`west` anchor, the `north west` anchor will be selected automatically.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:right:sep",
      meta = "⟨distance⟩"
    },
    ["branch up"] = {
      details = [[
Sets the `group shift` so that groups "branch upward". The distance by
which the center of each new element is removed from the center of the
previous one is ⟨distance⟩.

    \tikz \graph [branch up=7mm] { a -> b -> {c, d, e} };

Note that when you draw a tree, the `branch ...` keys specify how
siblings (or adjacent branches) are arranged, while the `grow ...` keys
specify in which direction the branches "grow".
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:up",
      meta = "⟨distance⟩"
    },
    ["branch up sep"] = {
      details = [[
    \tikz \graph [branch up sep] { a, b, c[draw, circle, inner sep=7mm] };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:up:sep",
      meta = "⟨distance⟩"
    },
    butterfly = {
      details = [[
The `butterfly` connector is used to create the kind of connections
present between layers of a so-called *butterfly network*. As for other
connectors, two sets of nodes are connected, which are the nodes having
color `target’` and `source’` by default. In a *level $l$* connection,
the first $l$ nodes of the first set are connected to the second $l$
nodes of the second set, while the second $l$ nodes of the first set get
connected to the first $l$ nodes of the second set. Then, for next $2l$
nodes of both sets a similar kind of connection is installed.
Additionally, each node gets connected to the corresponding node in the
other set with the same index (as in a `matching`):

    \tikz \graph [left anchor=east, right anchor=west,
                  branch down=4mm, grow right=15mm] {
      subgraph I_n [n=12, name=A] --[butterfly={level=3}]
      subgraph I_n [n=12, name=B] --[butterfly={level=2}]
      subgraph I_n [n=12, name=C]
    };

Unlike most joining operators, the colors of the nodes in the first and
the second set are not passed as parameters to the `butterfly` key.
Rather, they can be set using the ⟨options⟩, which are executed with the
path prefix `/tikz/graphs/butterfly`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/butterfly",
      meta = "⟨options⟩"
    },
    ["butterfly/from"] = {
      details = [[
Sets the color class of the from nodes.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/butterfly/from",
      meta = "⟨color⟩"
    },
    ["butterfly/level"] = {
      details = [[
Sets the level $l$ for the connections.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/butterfly/level",
      meta = "⟨level⟩"
    },
    ["butterfly/to"] = {
      details = [[
Sets the color class of the to nodes.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/butterfly/to",
      meta = "⟨color⟩"
    },
    ["chain polar shift"] = {
      details = [[
Under the regime of the `circular placement` strategy, each node on a
chain is shifted by `(`⟨logical width⟩⟨angle⟩`:`⟨logical
width⟩⟨angle⟩`)`.

    \tikz \graph [circular placement] {
      a -> b -> c;
      d -> e;
      f ->  g -> h;
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/chain:polar:shift",
      meta = "(⟨angle⟩:⟨radius⟩)"
    },
    ["chain shift"] = {
      details = [[
Under the regime of the `Cartesian placement` strategy, each node is
shifted by the current logical width times this ⟨coordinate⟩.

    \tikz \graph [chain shift=(45:1)] {
      a -> b -> c;
      d -> e;
      f -> g -> h;
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/chain:shift",
      meta = "⟨coordinate⟩"
    },
    ["circular placement"] = {
      details = [[
This key works quite similar to `Cartesian placement`. As for that
placement strategy, a node has logical width and depth `1`. However, the
computed total width and depth are mapped to polar coordinates rather
than Cartesian coordinates.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/circular:placement"
    },
    ["clear <"] = {
      details = [[
A more easy-to-remember shorthand for `source edge clear`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/clear:<"
    },
    ["clear >"] = {
      details = [[
A more easy-to-remember shorthand for `target edge clear`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/clear:>"
    },
    clique = {
      details = [[
Adds an edge between all vertices of the current group having the
(logical) color ⟨color⟩. Since, by default, this color is set to `all`,
which is a color that all nodes get by default, when you do not specify
anything, all nodes will be connected.

    \tikz \graph [clockwise, n=5] {
      a,
      b,
      {
        [clique]
        c, d, e
      }
    };

    \tikz \graph [color class=red, clockwise, n=5] {
      [clique=red, ->]
      a, b[red], c[red], d, e[red]
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/clique",
      meta = "⟨color⟩"
    },
    clockwise = {
      details = [[
This key sets the `group shift` so that if there are exactly ⟨number⟩
many nodes in a group, they will form a complete circle. If you do not
provide a ⟨number⟩, the current value of `\tikzgraphVnum` is used, which
is exactly what you want when you use predefined graph macros like
`subgraph K_ n`.

    \tikz \graph [clockwise=4] { a, b, c, d };

    \tikz \graph [clockwise] { subgraph K_n [n=5] };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/clockwise",
      meta = "⟨number⟩"
    },
    ["color class"] = {
      details = [[
This sets up a new color class called ⟨color class name⟩. Nodes and
whole groups of nodes can now be colored with ⟨color class name⟩. This
is done using the following keys, which become available inside the
current scope:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/color:class",
      meta = "⟨color class name⟩"
    },
    ["complete bipartite"] = {
      details = [[
Adds all possible edges from every node having color ⟨from color⟩ to
every node having color ⟨to color⟩:

    \tikz \graph { {a, b}       ->[complete bipartite]
                   {c, d, e}    --[complete bipartite]
                   {g, h, i, j} --[complete bipartite]
                   k };

    \tikz \graph [color class=red, color class=green, clockwise, n=6] {
      [complete bipartite={red}{green}, ->]
      a [red], b[red], c[red], d[green], e[green], f[green]
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/complete:bipartite",
      meta = "⟨from color⟩⟨to color⟩"
    },
    counterclockwise = {
      details = [[
Works like `clockwise`, only the direction is inverted.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/counterclockwise",
      meta = "⟨number⟩"
    },
    cycle = {
      details = [[
Connects the nodes colored ⟨color⟩ is a cyclic fashion. The ordering is
the ordering in which they appear in the whole graph specification.

    \tikz \graph [clockwise, n=6, phase=60] {
      { [cycle, ->] a, b, c },
      { [cycle, <-] d, e, f }
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/cycle",
      meta = "⟨color⟩"
    },
    declare = {
      details = [[
This key declares that ⟨graph name⟩ can subsequently be used as a
replacement for a ⟨node name⟩. Whenever the ⟨graph name⟩ is used in the
following, a graph group will be inserted instead whose content is
exactly ⟨specification⟩. In case ⟨graph name⟩ is used together with some
⟨options⟩, they are executed prior to inserting the ⟨specification⟩.

    \tikz \graph [branch down=4mm, declare={claw}{1 -- {2,3,4}}] {
      a;
      claw;
      b;
    };

In the next example, we use a key to configure a subgraph:

    \tikz \graph [ n/.code=\def\n{#1}, branch down=4mm,
                   declare={star}{root -- { \foreach \i in {1,...,\n} {\i} }}]
    { star [n=5]; };

Actually, the `n` key is already defined internally for a similar
purpose.

As a last example, let us define a somewhat more complicated graph
macro.

    \newcount\mycount
    \tikzgraphsset{
      levels/.store in=\tikzgraphlevel,
      levels=1,
      declare={bintree}{%
        [/utils/exec={%
          \ifnum\tikzgraphlevel=1\relax%
            \def\childtrees{ / }%
          \else%
            \mycount=\tikzgraphlevel%
            \advance\mycount by-1\relax%
            \edef\childtrees{
              / -> {
                bintree[levels=\the\mycount],
                bintree[levels=\the\mycount]
              }}
          \fi%
        },
        parse/.expand once=\childtrees
        ]
        % Everything is inside the \childtrees...
      }
    }
    \tikz \graph [grow down=5mm, branch right=5mm] { bintree [levels=5] };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/declare",
      meta = "{graph name}{specification}"
    },
    ["default edge kind"] = {
      details = [[
This key stores one of the five edge kinds `–`, `<-`, `->`, `<->`, and
`-!-`. When an operator wishes to create a new edge, it should typically
set

    \tikzgraphsset{new \pfkeysvalueof{/tikz/graphs/default edge kind}=...}

While this key can be set explicitly, it may be more convenient to use
the abbreviating keys listed below. Also, this key is automatically set
to the current value of ⟨edge specification⟩ when a joining operator is
called, see the discussion of joining operators in Section ??.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/default:edge:kind",
      meta = "⟨value⟩"
    },
    ["default edge operator"] = {
      details = [[
This key stores the name of a ⟨key⟩ that is executed for every ⟨edge
specification⟩ whose ⟨options⟩ do not contain the `operator` key.

    \tikz \graph [default edge operator=matching] {
      {a, b}    ->[matching and star]
      {c, d, e} --[complete bipartite]
      {f, g, h} --
      {i, j, k}
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/default:edge:operator",
      meta = "⟨key⟩"
    },
    edge = {
      details = [[
This is an alias for `edges`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge",
      meta = "⟨options⟩"
    },
    ["edge label"] = {
      details = [[
This key is an abbreviation for `edge node=node[auto]{`⟨text⟩`}`. The
net effect is that the `text` is placed next to the newly created edges.

    \tikz \graph [edge label=x] { a -> b -> {c,d} };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:label",
      meta = "⟨text⟩"
    },
    ["edge label'"] = {
      details = [[
This key is an abbreviation for `edge node=node[auto,swap]{`⟨text⟩`}`.

    \tikz \graph [edge label=out, edge label'=in]
      { subgraph C_n [clockwise, n=5] };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:label'",
      meta = "⟨text⟩"
    },
    ["edge node"] = {
      details = [[
This key specifies that the ⟨node specification⟩ should be added to each
newly created edge as an implicitly placed node.

    \tikz \graph [edge node={node [red, near end] {X}}] { a -> b -> c };

Again, multiple uses of this key accumulate.

    \tikz \graph [edge node={node [near end] {X}},
                  edge node={node [near start] {Y}}] { a -> b -> c };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:node",
      meta = "⟨node specification⟩"
    },
    ["edge quotes"] = {
      details = [[
A shorthand for setting the style `every edge quotes` to ⟨options⟩.

      \tikz \graph [edge quotes={blue,auto}] {
      a ->["x"] b ->["y"'] c ->["b" red] d;
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:quotes",
      meta = "⟨options⟩"
    },
    ["edge quotes center"] = {
      details = [[
A shorthand for `edge quotes` to `anchor=center`.

    \tikz \graph [edge quotes center] {
      a ->["x"] b ->["y"] c ->["z" red] d;
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:quotes:center"
    },
    ["edge quotes mid"] = {
      details = [[
A shorthand for `edge quotes` to `anchor=mid`.

    \tikz \graph [edge quotes mid] {
      a ->["x"] b ->["y"] c ->["z" red] d;
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:quotes:mid"
    },
    edges = {
      details = [[
This option causes the ⟨options⟩ to be applied to each newly created
edge inside the ⟨group specification⟩.

    \tikz \graph [edges={red,thick}] { a -> b -> c };

Again, multiple uses of this key accumulate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edges",
      meta = "⟨options⟩"
    },
    ["empty nodes"] = {
      details = [[
Just sets `typeset` to nothing, which causes all nodes to have an empty
text (unless, of course, the `as` option is used):

    \tikz \graph [empty nodes, nodes={circle, draw}] { a -> {b, c} };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/empty:nodes"
    },
    ["every graph"] = {
      details = [[
This style is executed at the beginning of every `graph` path command
prior to the ⟨options⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/every:graph"
    },
    ["fresh nodes"] = {
      details = [[
When this key is set to `true`, all nodes will be considered to be
fresh. This option is useful when you create for instance a tree with
many identical nodes.

When a node name is encountered that was already used previously, a new
name is chosen is follows: An apostrophe (`’`) is appended repeatedly
until a node name is found that has not yet been used:

    \tikz \graph [branch down=5mm] {
      { [fresh nodes]
        a -> {
          b -> {c, c},
          b -> {c, c},
          b -> {c, c},
        }
      },
      b' -- b''
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/fresh:nodes",
      meta = "⟨true or false⟩"
    },
    ["grid placement"] = {
      details = [[
This key works similar to `Cartesian placement`. As for that placement
strategy, a node has logical width and depth 1. However, the computed
total width and depth are mapped to a $N\times M$ grid. The values of
$N$ and $M$ depend on the size of the graph and the value of
`wrap after`. The number of columns $M$ is either set to `wrap after`
explicitly or computed automatically as
$\sqrt{\texttt{\string\texttt{V\textbackslash string}}}$. $N$ is the
number of rows needed to lay out the graph in a grid with $M$ columns.

    % An example with 6 nodes, 3 columns and therefor 2 rows
    \tikz \graph [grid placement] { subgraph I_n[n=6, wrap after=3] };

    % An example with 9 nodes with columns and rows computed automatically
    \tikz \graph [grid placement] { subgraph Grid_n [n=9] };

    % Directions can be changed
    \tikz \graph [grid placement, branch up, grow left] { subgraph Grid_n [n=9] };

In case a user-defined graph instead of a pre-defined `subgraph` is to
be laid out using `grid placement`, `n` has to be specified explicitly:

    \tikz \graph [grid placement] {
      [n=6, wrap after=3]
      a -- b -- c -- d -- e -- f
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grid:placement"
    },
    ["group polar shift"] = {
      details = [[
Like for `group shift`, each node on a chain is shifted by `(`⟨logical
depth⟩⟨angle⟩`:`⟨logical depth⟩⟨angle⟩`)`.

    \tikz \graph [circular placement, group polar shift=(30:0)] {
      a -> b -> c;
      d -> e;
      f -> g -> h;
    };

    \tikz \graph [circular placement,
                  chain polar shift=(30:0),
                  group polar shift=(0:1cm)] {
      a -- b -- c;
      d -- e;
      f -- g -- h;
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/group:polar:shift",
      meta = "(⟨angle⟩:⟨radius⟩)"
    },
    ["group shift"] = {
      details = [[
Like for `chain shift`, each node is shifted by the current logical
depth times this ⟨coordinate⟩.

    \tikz \graph [chain shift=(45:7mm), group shift=(-45:7mm)] {
      a -> b -> c;
      d -> e;
      f -> g -> h;
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/group:shift",
      meta = "⟨coordinate⟩"
    },
    ["grow down"] = {
      details = [[
Like `grow up`.

    \tikz \graph [grow down=7mm] { a -> b -> c};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:down",
      meta = "⟨distance⟩"
    },
    ["grow down sep"] = {
      details = [[
As above.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:down:sep",
      meta = "⟨distance⟩"
    },
    ["grow left"] = {
      details = [[
Like `grow up`.

    \tikz \graph [grow left=7mm] { a -> b -> c};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:left",
      meta = "⟨distance⟩"
    },
    ["grow left sep"] = {
      details = [[
    \tikz \graph [grow left sep] { long -- longer -- longest };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:left:sep",
      meta = "⟨distance⟩"
    },
    ["grow right"] = {
      details = [[
Like `grow up`.

    \tikz \graph [grow right=7mm] { a -> b -> c};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:right",
      meta = "⟨distance⟩"
    },
    ["grow right sep"] = {
      details = [[
This key has several effects, but let us start with the bottom line:
Nodes along a chain are placed in such a way that the left end of a new
node is ⟨distance⟩ from the right end of the previous node:

    \tikz \graph [grow right sep, left anchor=east, right anchor=west] {
      start -- {
        long text -- {short, very long text} -- more text,
        long -- longer -- longest
      } -- end
    };

What happens internally is the following: First, the `anchor` of the
nodes is set to `west` (or `north west` or `south west`, see below).
Second, the logical width of a node is no longer `1`, but set to the
actual width of the node (which we define as the horizontal difference
between the `west` anchor and the `east` anchor) in points. Third, the
`chain shift` is set to `(1pt,0pt)`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:right:sep",
      meta = "⟨distance⟩"
    },
    ["grow up"] = {
      details = [[
Sets the `chain shift` to `(0,`⟨distance⟩`)`, so that chains "grow
upward". The distance by which the center of each new element is removed
from the center of the previous one is ⟨distance⟩.

    \tikz \graph [grow up=7mm] { a -> b -> c};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:up",
      meta = "⟨distance⟩"
    },
    ["grow up sep"] = {
      details = [[
    \tikz \graph [grow up sep] {
      a / $a=x$ --
      b / {$b=\displaystyle \int_0^1 x dx$} --
      c [draw, circle, inner sep=7mm]
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:up:sep",
      meta = "⟨distance⟩"
    },
    ["induced complete bipartite"] = {
      details = [[
Works like the `complete bipartite` operator, but in a `simple` graph
any edges between the vertices in either shore are removed (more
precisely, they get replaced by `-!-` edges).

    \tikz \graph [simple] {
      subgraph K_n [n=5, clockwise];  % Lots of edges

      {2, 3} ->[induced complete bipartite] {4, 5}
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/induced:complete:bipartite"
    },
    ["induced cycle"] = {
      details = [[
While the `cycle` command will only add edges, this key will also remove
all other edges between the nodes of the cycle, provided we are
constructing a `simple` graph.

    \tikz \graph [simple] {
      subgraph K_n [n=7, clockwise]; % create lots of edges

      { [induced cycle, ->, edge=red] 2, 3, 4, 6, 7 },
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/induced:cycle",
      meta = "⟨color⟩"
    },
    ["induced independent set"] = {
      details = [[
This key is the "opposite" of a `clique`: It removes all edges in the
current group having belonging to color class ⟨color⟩. More precisely,
an edge of kind `-!-` is added for each pair of vertices. This means
that edge only get removed if you specify the `simple` option.

    \tikz \graph [simple] {
      subgraph K_n [<->, n=7, clockwise]; % create lots of edges

      { [induced independent set] 1, 3, 4, 5, 6 }
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/induced:independent:set",
      meta = "⟨color⟩"
    },
    ["induced path"] = {
      details = [[
Works like `induced cycle`, only there is no edge from the last to the
first vertex.

    \tikz \graph [simple] {
      subgraph K_n [n=7, clockwise]; % create lots of edges

      { [induced path, ->, edges=red] 2, 3, 4, 6, 7 },
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/induced:path",
      meta = "⟨color⟩"
    },
    ["left anchor"] = {
      details = [[
This anchor is used for the node that is to the left of an edge
specification. Setting this anchor to the empty string means that no
special anchor is used (which is the default). The ⟨anchor⟩ is stored in
the macro `\tikzgraphleftanchor` with a leading dot.

    \tikz \graph {
      {a,b,c} -> [complete bipartite] {e,f,g}
    };

    \tikz \graph [left anchor=east, right anchor=west] {
      {a,b,c} -- [complete bipartite] {e,f,g}
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/left:anchor",
      meta = "⟨anchor⟩"
    },
    m = {
      details = [[
This is an abbreviation for
`W={1,...,`⟨number⟩`}, name shore W/.style={name=W}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/m",
      meta = "⟨number⟩"
    },
    matching = {
      details = [[
This joining operator forms a maximum *matching* between the nodes of
the two sets of nodes having colors ⟨from color⟩ and ⟨to color⟩,
respectively. The first node of the from set is connected to the first
node of to set, the second node of the from set is connected to the
second node of the to set, and so on. If the sets have the same size,
what results is what graph theoreticians call a *perfect matching*,
otherwise only a maximum, but not perfect matching results.

    \tikz \graph {
      {a, b, c} ->[matching]
      {d, e, f} --[matching]
      {g, h}    --[matching]
      {i, j, k}
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/matching",
      meta = "⟨from color⟩⟨to color⟩"
    },
    ["matching and star"] = {
      details = [[
The `matching and star` connector works like the `matching` connector,
only it behaves differently when the two to-be-connected sets have
different size. In this case, all the surplus nodes get connected to the
last node of the other set, resulting in what is known as a *star* in
graph theory. This simple rule allows for some powerful effects (since
this connector is the one initially set, there is no need to add it
here):

    \tikz \graph { a -> {b, c} -> {d, e} -- f};

The `matching and star` connector also makes it easy to create trees and
series-parallel graphs.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/matching:and:star",
      meta = "⟨from color⟩⟨to color⟩"
    },
    ["math nodes"] = {
      details = [[
Sets `typeset` to `\textbackslash tikzgraphnodetext`, which causes all
nodes names to be typeset in math mode:

    \tikz \graph [math nodes, nodes={circle, draw}] { a_1 -> {b^2, c_3^n} };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/math:nodes"
    },
    multi = {
      details = [[
When this edge is set for a whole graph (which is the default) or just
for a group (which is useful if the whole graph is simple in general,
but a part is a multi-graph), then when you specify an edge between two
nodes several times, several such edges get created:

    \tikz \graph [multi] { % "multi" is not really necessary here
      a ->[bend left,  red]  b;
      a ->[bend right, blue] b;
    };

In case `multi` is used for a scope inside a larger scope where the
`simple` option is specified, then inside the local `multi` scope edges
are immediately created and they are completely ignored when it comes to
deciding which kind of edges should be present in the surrounding simple
graph. From the surrounding scope's point of view it is as if the local
`multi` graph contained no edges at all.

This means, in particular, that you can use the `multi` option with a
single edge to "enforce" this edge to be present in a simple graph.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/multi"
    },
    n = {
      details = [[
This is an abbreviation for
`V={1,...,`⟨number⟩`}, name shore V/.style={name=V}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/n",
      meta = "⟨number⟩"
    },
    name = {
      details = [[
This key prepends the ⟨text⟩, followed by a separating symbol (a space
by default), to all ⟨node name⟩s inside a ⟨full node name⟩. Repeated
calls of this key accumulate, leading to ever-longer "name paths":

    \begin{tikzpicture}
      \graph {
        { [name=first]  1, 2, 3} --
        { [name=second] 1, 2, 3}
      };
      \draw [red] (second 1) circle [radius=3mm];
    \end{tikzpicture}

Note that, indeed, in the above example six nodes are created even
though the first and second set of nodes have the same ⟨node name⟩. The
reason is that the full names of the six nodes are all different. Also
note that only the ⟨node name⟩ is used as the node text, not the full
name. This can be changed as described later on.

This key can be used repeatedly, leading to ever longer node names.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/name",
      meta = "⟨text⟩"
    },
    ["name separator"] = {
      details = [[
Changes the symbol that is used to separate the ⟨text⟩ from the ⟨node
name⟩. The default is `\space`, resulting in a space.

    \begin{tikzpicture}
      \graph [name separator=] { % no separator
        { [name=first]  1, 2, 3} --
        { [name=second] 1, 2, 3}
      };
      \draw [red] (second1) circle [radius=3mm];
    \end{tikzpicture}

    \begin{tikzpicture}
      \graph [name separator=-] {
        { [name=first]  1, 2, 3} --
        { [name=second] 1, 2, 3}
      };
      \draw [red] (second-1) circle [radius=3mm];
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/name:separator",
      meta = "⟨symbols⟩"
    },
    ["name shore V"] = {
      details = [[
Set this style to, say, `name=my V set` in order to set a name for the
`V` set.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/name:shore:V"
    },
    ["name shore W"] = {
      details = [[
Same as for `name shore V`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/name:shore:W"
    },
    ["new --"] = {
      details = [[
This key is called for `–` with the same parameters as above. The only
difference in the definition is that in the `\path` command the `->`
gets replaced by `-`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/new:--",
      meta = "{left node}{right node}{edge options}{edge nodes}"
    },
    ["new ->"] = {
      details = [[
This key will be called for a `->` edge specification with the following
four parameters:

1.  ⟨left node⟩ is the name of the "left" node, that is, the name of
    $l_i$.

2.  ⟨right node⟩ is the name of the right node.

3.  ⟨edge options⟩ are the accumulated options from all calls of
    `/tikz/graph/edges` in groups that surround the edge specification.

4.  ⟨edge nodes⟩ is text like `node {A} node {B}` that specifies some
    nodes that should be put as labels on the edge using TikZ's implicit
    positioning mechanism.

By default, the key executes the following code:

> `\path [->,every new ->]`  
> `(`⟨left node⟩`\tikzgraphleftanchor) edge [` ⟨edge options⟩`]` ⟨edge
> nodes⟩``  
> `(`⟨right node⟩`\tikzgraphrightanchor);`

You are welcome to change the code underlying the key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/new:->",
      meta = "{left node}{right node}{edge options}{edge nodes}"
    },
    ["new -\\protect\\exclamationmarktext-"] = {
      details = [[
Called for `-!-` with the same parameters as above. Does nothing by
default.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/new:-\\protect\\exclamationmarktext-",
      meta = "{left node}{right node}{edge options}{edge nodes}"
    },
    ["new <-"] = {
      details = [[
Called for `<-` with the same parameters as above. [1]

[1] You might wonder why this key is needed: It seems more logical at
first sight to just call `new edge directed` with swapped first
parameters. However, a positioning algorithm might wish to take the fact
into account that an edge is "backward" rather than "forward" in order
to improve the layout. Also, different arrow heads might be used.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/new:<-",
      meta = "{left node}{right node}{edge options}{edge nodes}"
    },
    ["new <->"] = {
      details = [[
Called for `<->` with the same parameters as above. The `->` is replaced
by `<-`
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/new:<->",
      meta = "{left node}{right node}{edge options}{edge nodes}"
    },
    ["no placement"] = {
      details = [[
This strategy simply "switches off" the whole placement mechanism,
causing all nodes to be placed at the origin by default. You need to use
this strategy if you position nodes "by hand". For this, you can use the
`at` key, the `shift` keys:

    \tikz \graph [no placement]
    {
      a[at={(0:0)}] -> b[at={(1,0)}] -> c[yshift=1cm];
    };

Since the syntax and the many braces and parentheses are a bit
cumbersome, the following two keys might also be useful:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/no:placement"
    },
    nodes = {
      details = [[
This option causes the ⟨options⟩ to be applied to each newly created
node inside the ⟨group specification⟩.

    \tikz \graph [nodes=red] { a -> b -> c };

Multiple uses of this key accumulate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/nodes",
      meta = "⟨options⟩"
    },
    ["not ⟨color class name⟩"] = {
      details = [[
Sets up an operator for the current scope so that all nodes in it loose
the color ⟨color class name⟩. You can also use `!`⟨color class name⟩ as
an alias for this key.

    \tikz \graph [color class=red, color class=green,
                  math nodes, clockwise, n=5] {
      [complete bipartite={red}{green}]
      { [red]   r_1, r_2 },
      { [green] g_1, g_2, g_3 },
      g_2 [not green]
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/not:⟨color:class:name⟩"
    },
    ["number nodes"] = {
      details = [[
When this key is used in a scope, each encountered node name will get
appended a new number, starting with ⟨start⟩. Typically, this ensures
that all node names are different. Between the original node name and
the appended number, the setting of the following will be inserted:

    \tikz \graph [branch down=5mm] {
      { [number nodes]
        a -> {
          b -> {c, c},
          b -> {c, c},
          b -> {c, c},
        }
      },
      b 2 -- b 5
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/number:nodes",
      meta = "⟨start number⟩"
    },
    ["number nodes sep"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/number:nodes:sep",
      meta = "⟨text⟩"
    },
    operator = {
      details = [[
This key has an effect in three places:

1.  It can be used in the ⟨options⟩ of a ⟨direct node specification⟩.

2.  It can be used in the ⟨options⟩ of a ⟨group specification⟩.

3.  It can be used in the ⟨options⟩ of an ⟨edge specification⟩.

The first case is a special case of the second, since it is treated like
a group specification containing a single node. The last case is more
complicated and discussed in the next section. So, let us focus on the
second case.

Even though the ⟨options⟩ of a group are given at the beginning of the
⟨group specification⟩, the ⟨code⟩ is only executed when the group has
been parsed completely and all its nodes have been identified. If you
use the `operator` multiple times in the ⟨options⟩, the effect
accumulates, that is, all code passed to the different calls of
`operator` gets executed in the order it is encountered.

The ⟨code⟩ can do "whatever it wants", but it will typically add edges
between certain nodes. You can configure what kind of edges (directed,
undirected, etc.) are created by using the following keys:

When the ⟨code⟩ of an operator is executed, the following commands can
be used to find the nodes that should be connected:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/operator",
      meta = "⟨code⟩"
    },
    path = {
      details = [[
Works like `cycle`, only there is no edge from the last to the first
vertex.

    \tikz \graph [clockwise, n=6] {
      { [path, ->] a, b, c },
      { [path, <-] d, e, f }
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/path",
      meta = "⟨color⟩"
    },
    phase = {
      details = [[
This is an initial value that is added to the total computed angle when
the polar shift of a node has been calculated.

    \tikz \graph [circular placement] { a, b, c, d };

    \tikz \graph [circular placement, phase=0] { a, b, c, d };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/phase",
      meta = "⟨angle⟩"
    },
    ["placement/chain count"] = {
      details = [[
This key stores a number that tells us the sequence number of the chain
in the current group.

    \tikz \graph [
      grow right sep, branch down=5mm, typeset=\tikzgraphnodetext:\mynum,
      placement/compute position/.append code=
        \pgfkeysgetvalue{/tikz/graphs/placement/chain count}{\mynum}]
    {
      a -> b -> {c,d,e},
      f,
      g -> h
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/chain:count"
    },
    ["placement/compute position"] = {
      details = [[
The ⟨code⟩ is called by the `graph` command just prior to creating a new
node (the exact moment when this key is called is detailed in the
description of the `place` key). When the ⟨code⟩ is called, all of the
keys described above will hold numbers computed in the way described
above.

The job of the ⟨code⟩ is to setup node options appropriately so that the
to-be-created node will be placed correctly. Thus, the ⟨code⟩ should
typically set the key `nodes={shift=`⟨coordinate⟩`}` where ⟨coordinate⟩
is the computed position for the node. The ⟨code⟩ could also set other
options like, say, the color of a node depending on its depth.

The following example appends some code to the standard code of
`compute position` so that "deeper" nodes of a tree are lighter.
(Naturally, the same effect could be achieved much more easily using the
`level` key.)

    \newcount\mycount
    \def\lightendeepernodes{
      \pgfmathsetcount{\mycount}{
        100-20*\pgfkeysvalueof{/tikz/graphs/placement/width}
      }
      \edef\mydepth{\the\mycount}
      \tikzset{nodes={fill=red!\mydepth,circle,text=white}}
    }
    \tikz
      \graph [placement/compute position/.append code=\lightendeepernodes]
       {
         a -> {
           b -> c -> d,
           e -> {
             f,
             g
           },
           h
         }
       };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/compute:position",
      meta = "⟨code⟩"
    },
    ["placement/depth"] = {
      details = [[
Similarly to the `width` key, this key stores the "logical depth" of the
nodes parsed up to now in the current group or chain and, also
similarly, this key may or may not be related to the actual depth/height
of the current node. As for the `width`, the exact definition is as
follows: For a single node, the depth is computed by the following key:

Second, the depth of a group is the sum of the depths of its elements.
Third, the depth of a chain is the maximum of the depth of its elements.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/depth"
    },
    ["placement/element count"] = {
      details = [[
This key stores a number that tells us the position of the node on the
current chain. However, you only have access to this value inside the
code passed to the macro `compute position`, explained later on.

    \tikz \graph [
      grow right sep, typeset=\tikzgraphnodetext:\mynum,
      placement/compute position/.append code=
        \pgfkeysgetvalue{/tikz/graphs/placement/element count}{\mynum}]
    {
      a -> b -> c,
      d -> {e, f->h} -> j
    };

As can be seen, each group resets the element counter.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/element:count"
    },
    ["placement/level"] = {
      details = [[
This key stores a number that is increased for each element on a chain,
but gets reset at the end of a group:

    \tikz \graph [ branch down=5mm, typeset=
        \tikzgraphnodetext:\pgfkeysvalueof{/tikz/graphs/placement/level}]
    {
      a -> {
        b,
        c -> {
          d,
          e -> {f,g},
          h
        },
        j
      }
    };

Unlike the parameters `depth` and `width` described in the next section,
the key `level` is always available.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/level"
    },
    ["placement/logical node depth"] = {
      details = [[
The code behind this key should return the "logical height" of the node
⟨full node name⟩ in the macro `\pgfmathresult`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/logical:node:depth",
      meta = "⟨full node name⟩"
    },
    ["placement/logical node width"] = {
      details = [[
This key is called to compute a physical or logical width of the node
⟨full node name⟩. You can change the code of this key. The code should
return the computed value in the macro `\pgfmathresult`. By default,
this key returns `1`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/logical:node:width",
      meta = "⟨full node name⟩"
    },
    ["placement/place"] = {
      details = [[
Executing this key has two effects: First, the key `compute position` is
called to compute a good position for future nodes (usually, these
"future nodes" are just a single node that is created immediately).
Second, all of the above counters like `depth` or `width` are reset (but
not `level`).

There are two places where this key is sensibly called: First, just
prior to creating a node, which happens automatically. Second, when you
change the online strategy. In this case, the computed width and depth
values from one strategy typically make no sense in the other strategy,
which is why the new strategy should proceed "from a fresh start". In
this case, the implicit call of `compute position` ensures that the new
strategy gets the last place the old strategy would have used as its
starting point, while the computation of its positions is now relative
to this new starting point.

For these reasons, when an online strategy like `Cartesian placement` is
called, this key gets called implicitly. You will rarely need to call
this key directly, except when you define a new online strategy.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/place"
    },
    ["placement/width"] = {
      details = [[
This key stores the "logical width" of the nodes parsed up to now in the
current group or chain (more precisely, parsed since the last call of
`place` in an enclosing group). This is not necessarily the "total
physical width" of the nodes, but rather a number representing how "big"
the elements prior to the current element were. This *may* be their
width, but it may also be their height or even their number (which,
incidentally, is the default). You can use the `width` to perform shifts
or rotations of to-be-created nodes (to be explained later).

The logical width is defined recursively as follows. First, the width of
a single node is computed by calling the following key:

The width of a chain is the sum of the widths of its elements. The width
of a group is the maximum of the widths of its elements.

To get a feeling what the above rules imply in practice, let us first
have a look at an example where each node has logical width and height
`1` (which is the default). The arcane options at the beginning of the
code just setup things so that the computed width and depth of each node
is displayed at the bottom of each node.

    \tikz
      \graph [nodes={align=center, inner sep=1pt}, grow right=7mm,
              typeset={\tikzgraphnodetext\\[-4pt]
                       \tiny\mywidth\\[-6pt]\tiny\mydepth},
              placement/compute position/.append code=
                \pgfkeysgetvalue{/tikz/graphs/placement/width}{\mywidth}
                \pgfkeysgetvalue{/tikz/graphs/placement/depth}{\mydepth}]
    {
      a,
      b,
      c -> d -> {
        e -> f -> g,
        h -> i
      } -> j,
      k -> l
    };

In the next example the "logical" width and depth actually match the
"physical" width and height. This is caused by the `grow right sep`
option, which internally sets the `logical node width` key so that it
returns the width of its parameter in points.

    \tikz
      \graph [grow right sep, branch down sep, nodes={align=left, inner sep=1pt},
              typeset={\tikzgraphnodetext\\[-4pt] \tiny Width: \mywidth\\[-6pt] \tiny Depth: \mydepth},
              placement/compute position/.append code=
                \pgfkeysgetvalue{/tikz/graphs/placement/width}{\mywidth}
                \pgfkeysgetvalue{/tikz/graphs/placement/depth}{\mydepth}]
    {
      a,
      b,
      c -> d -> {
        e -> f -> g,
        h -> i
      } -> j,
      k -> l
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/width"
    },
    ["put node text on incoming edges"] = {
      details = [[
When this key is used with a node or a group, the following happens:

1.  The command
    `target edge node={node[`⟨options⟩`]{\tikzgraphnodetext}}` is
    executed. This means that all incoming edges of the node get a label
    with the text that would usually be displayed in the node. You can
    use keys like `math nodes` normally.

2.  The command `as={}` is executed. This means that the node itself
    will display nothing.

Here is an example that show how this command is used.

    \tikz \graph [put node text on incoming edges,
                  math nodes, nodes={circle,draw}]
      { a -> b -> {c, d} };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/put:node:text:on:incoming:edges",
      meta = "⟨options⟩"
    },
    ["put node text on outgoing edges"] = {
      details = [[
Works like the previous key, only with `target` replaced by `source`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/put:node:text:on:outgoing:edges",
      meta = "⟨options⟩"
    },
    quick = {
      details = [[
When you provide this key with a graph, the syntax of graph
specifications gets restricted. You are no longer allowed to use certain
features of the graph syntax; but all features that are still allowed
are also allowed in the same way when you do not provide the `quick`
option. Thus, leaving out the `quick` option will never hurt.

Since the syntax is so severely restricted, it is easier to explain
which aspects of the graph syntax *will* still work:

1.  A quick graph consists of a sequence of either nodes, edges
    sequences, or groups. These are separated by commas or semicolons.

2.  Every node is of the form

    > `"`⟨node name⟩`"``/"`⟨node text⟩`"[`⟨options⟩`]`

    The quotation marks are mandatory. The part `/"`⟨node text⟩`"` may
    be missing, in which case the node name is used as the node text.
    The ⟨options⟩ may also be missing. The ⟨node name⟩ may not contain
    any "funny" characters (unlike in the normal graph command).

3.  Every chain is of the form

    > ⟨node spec⟩ ⟨connector⟩ ⟨node spec⟩ ⟨connector⟩ ...⟨connector⟩
    > ⟨node spec⟩`;`

    Here, the ⟨node spec⟩ are node specifications as described above,
    the ⟨connector⟩ is one of the four connectors `->`, `<-`, `–`, and
    `<->` (the connector `-!-` is not allowed since the `simple` option
    is also not allowed). Each connector may be followed by options in
    square brackets. The semicolon may be replaced by a comma.

4.  Every group is of the form

    > `{ [`⟨options⟩`]` ⟨chains and groups⟩ `};`

    The ⟨options⟩ are compulsory. The semicolon can, again, be replaced
    by a comma.

5.  The `number nodes` option will work as expected.

Here is a typical way this syntax might be used:

    \tikz \graph [quick] { "a" --["foo"] "b"[x=1] };

    \tikz \graph [quick] {
      "a"/"$a$" -- "b"[x=1] --[red] "c"[x=2];
      { [nodes=blue] "a" -- "d"[y=1]; };
    };

Let us now have a look at the most important things that will *not* work
when the `quick` option is used:

-   Connecting a node and a group as in `a->{b,c}`.

-   Node names without quotation marks as in `a–b`.

-   Everything described in subsequent subsections, which includes
    subgraphs (graph macros), graph sets, graph color classes, anonymous
    nodes, the `fresh nodes` option, sublayouts, simple graphs, edge
    annotations.

-   Placement strategies -- you either have to define all node positions
    explicitly using `at=` or `x=` and `y=` or you must use a graph
    drawing algorithm like `layered layout`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/quick"
    },
    radius = {
      details = [[
This is an initial value that is added to the total computed radius when
the polar shift of a node has been calculated. Essentially, this key
allows you to set the ⟨radius⟩ of the innermost circle.

    \tikz \graph [circular placement, radius=5mm] { a, b, c, d };

    \tikz \graph [circular placement, radius=1cm] { a, b, c, d };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/radius",
      meta = "⟨dimension⟩"
    },
    ["recolor ⟨color class name⟩ by"] = {
      details = [[
Causes all keys having color ⟨color class name⟩ to get ⟨new color⟩
instead. They loose having color ⟨color class name⟩, but other colors
are not affected.

    \tikz \graph [color class=red, color class=green,
                  math nodes, clockwise, n=5] {
      [complete bipartite={red}{green}]
      { [red]   r_1, r_2 },
      { [green] g_1, g_2, g_3 },
      g_2 [recolor green by=red]
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/recolor:⟨color:class:name⟩:by",
      meta = "⟨new color⟩"
    },
    ["right anchor"] = {
      details = [[
Works like `left anchor`, only for `\tikzgraphrightanchor`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/right:anchor",
      meta = "⟨anchor⟩"
    },
    simple = {
      details = [[
In contrast a multi-graph, in a simple graph, at most one edge gets
created for every pair of vertices:

    \tikz \graph [simple]{
      a ->[bend left,  red]  b;
      a ->[bend right, blue] b;
    };

As can be seen, the second edge "wins" over the first edge. The general
rule is as follows: In a simple graph, whenever an edge between two
vertices is specified multiple times, only the very last specification
and its options will actually be executed.

The real power of the `simple` option lies in the fact that you can
first create a complicated graph and then later redirect and otherwise
modify edges easily:

    \tikz \graph [simple, grow right=2cm] {
      {a,b,c,d} ->[complete bipartite] {e,f,g,h};

      { [edges={red,thick}] a -> e -> d -> g -> a };
    };

One particularly interesting kind of edge specification for a simple
graph is `-!-`. Recall that this is used to indicate that "no edge"
should be added between certain nodes. In a multi-graph, this key
usually has no effect (unless the key `new -!-` has been redefined) and
is pretty superfluous. In a simple graph, however, it counts as an edge
kind and you can thus use it to remove an edge that been added
previously:

    \tikz \graph [simple] {
      subgraph K_n [n=8, clockwise];
      % Get rid of the following edges:
      1 -!- 2;
      3 -!- 4;
      6 -!- 8;
      % And make one edge red:
      1 --[red] 3;
    };

Creating a graph such as the above in other fashions is pretty awkward.

For every unordered pair $\{u,v\}$ of vertices at most one edge will be
created in a simple graph. In particular, when you say `a -> b` and
later also `a <- b`, then only the edge `a <- b` will be created.
Similarly, when you say `a -> b` and later `b -> a`, then only the edge
`b -> a` will be created.

The power of the `simple` command comes at a certain cost: As the graph
is being constructed, a (sparse) array is created that keeps track for
each edge of the last edge being specified. Then, at the end of the
scope containing the `simple` command, for every pair of vertices the
edge is created. This is implemented by two nested loops iterating over
all possible pairs of vertices -- which may take quite a while in a
graph of, say, 1000 vertices. Internally, the `simple` command is
implemented as an operator that adds the edges when it is called, but
this should be unimportant in normal situations.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/simple"
    },
    ["source edge clear"] = {
      details = [[
Works like `target edge clear`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/source:edge:clear",
      meta = "⟨node specification⟩"
    },
    ["source edge node"] = {
      details = [[
Works like `source edge style` and `target edge node`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/source:edge:node",
      meta = "⟨node specification⟩"
    },
    ["source edge style"] = {
      details = [[
Works exactly like `target edge style`, only now the ⟨options⟩ are only
added when the node is a source of a newly created edge:

    \tikz \graph {
      { a, b } ->
      { c [source edge style=red], d } ->
      { e, f }
    };

If both for the source and also for the target of an edge ⟨options⟩ have
been specified, the options are applied in the following order:

1.  First come the options from the edge itself.

2.  Then come the options contributed by the source node using this key.

3.  Then come the options contributed by the target node using
    `target node style`.

&nbsp;

    \tikz \graph {
      a [source edge style=red] ->[green]
      b [target edge style=blue]  % blue wins
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/source:edge:style",
      meta = "⟨options⟩"
    },
    ["target edge clear"] = {
      details = [[
Clears all ⟨options⟩ for edges with the node as a target and also edge
labels (see below) for this node.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/target:edge:clear"
    },
    ["target edge node"] = {
      details = [[
This key works like `target edge style`, only the ⟨node specification⟩
will not be added as options to any newly created edges with the current
node as their target, but rather it will be added as a node
specification.

    \tikz \graph {
      { a, b } ->
      { c [target edge node=node{X}], d } ->
      { e, f }
    };

As for `target edge style` multiple uses of this key accumulate and the
key `target edge clear` will (also) clear all target edge nodes that
have been set for a node earlier on.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/target:edge:node",
      meta = "⟨node specification⟩"
    },
    ["target edge style"] = {
      details = [[
This key can (only) be used with a *node* inside a graph specification.
When used, the ⟨options⟩ will be added to every edge that is created by
a connector like `->` in which the node is a *target*. Consider the
following example:

    \tikz \graph {
      { a, b } ->
      { c [target edge style=red], d } ->
      { e, f }
    };

In the example, only when the edge from `a` to `c` is created, `c` is
the "target" of the edge. Thus, only this edge becomes red.

When an edge already has options set directly, the ⟨options⟩ are
executed after these direct options, thus, they "overrule" them:

    \tikz \graph {
      { a, b } -> [blue, thick]
      { c [target edge style=red], d } ->
      { e, f }
    };

The ⟨options⟩ set in this way will stay attached to the node, so also
for edges created later on that lead to the node will have these options
set:

    \tikz \graph {
      { a, b } ->
      { c [target edge style=red], d } ->
      { e, f },
      b -> c
    };

Multiple uses of this key accumulate. However, you may sometimes also
wish to "clear" these options for a key since at some later point you no
longer wish the ⟨options⟩ to be added when some further edges are added.
This can be achieved using the following key:

    \tikz \graph {
      { a, b } ->
      { c [target edge style=red], d },
      b -> c[target edge clear]
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/target:edge:style",
      meta = "⟨options⟩"
    },
    trie = {
      details = [[
If this key is set to `true`, after a node has been created on a chain,
the `name` key is executed with the node's ⟨node name⟩. Thus, all nodes
later on this chain have the "path" of nodes leading to this node as
their name. This means, in particular, that

1.  two nodes of the same name but in different parts of a chain will be
    different,

2.  while if another chain starts with the same nodes, no new nodes get
    created.

In total, this is exactly the behavior you would expect of a trie:

    \tikz \graph [trie] {
      a -> {
        a,
        c -> {a, b},
        b
      }
    };

You can even "reiterate" over a path in conjunction with the `simple`
option. However, in this case, the default placement strategies will not
work and you will need options like `layered layout` from the graph
drawing libraries, which need LuaTeX.

    \tikz \graph [trie, simple, layered layout] {
      a -> b -> a,
      a -> b -> c,
      a -> {d,a}
    };

In the following example, we setup the `typeset` key so that it shows
the complete names of the nodes:

    \tikz \graph [trie, simple, layered layout,
                  typeset=\tikzgraphnodefullname] {
      a -> b -> a,
      a -> b -> c,
      a -> {d,a}
    };

You can also use the `trie` key locally and later reference nodes using
their full name:

    \tikz \graph {
      { [trie, simple]
        a -> {
          b,
          c -> a
        }
      },
      a b ->[red] a c a
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/trie",
      meta = "⟨true or false⟩"
    },
    typeset = {
      details = [[
The macro or code stored in this key is used as the ⟨text⟩ of the node.
Inside the ⟨code⟩, the following macros are available:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/typeset",
      meta = "⟨code⟩"
    },
    ["use existing nodes"] = {
      details = [[
When this key is set to `true`, all nodes will be considered to the
referenced, no node will be fresh. This option is useful if you have
already created all the nodes of a graph prior to using the `graph`
command and you now only wish to connect the nodes. It also implies that
an error is raised if you reference a node which has not been defined
previously.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/use:existing:nodes",
      meta = "⟨true or false⟩"
    },
    ["wrap after"] = {
      details = [[
Defines the number of nodes placed in a single row of the grid. This
value implicitly defines the number of grid columns as well. In the
following example a `grid placement` is used to visualize the edges
created between the nodes of a `Grid_ n` `subgraph` using different
values for `wrap after`.

    \tikz \graph [grid placement] { subgraph Grid_n [n=3,wrap after=1] };
    \tikz \graph [grid placement] { subgraph Grid_n [n=3,wrap after=3] };

    \tikz \graph [grid placement] { subgraph Grid_n [n=4,wrap after=2] };
    \tikz \graph [grid placement] { subgraph Grid_n [n=4] };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/wrap:after",
      meta = "⟨number⟩"
    },
    x = {
      details = [[
When you use this key, it will have the same effect as if you had
written `at={(`⟨x dimension⟩`,`⟨y dimension⟩`)}`, where ⟨y dimension⟩ is
a value set using the `y` key:

    \tikz \graph [no placement]
    {
      a[x=0,y=0] -> b[x=1,y=0] -> c[x=0,y=1];
    };

Note that you can specify an `x` or a `y` key for a whole scope and then
vary only the other key:

    \tikz \graph [no placement]
    {
      a ->
      { [x=1] % group option
        b [y=0] -> c[y=1]
      };
    };

Note that these keys have the path `/tikz/graphs/`, so they will be
available inside `graph`s and will not clash with the usual `x` and `y`
keys of TikZ, which are used to specify the basic lengths of vectors.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/x",
      meta = "⟨x dimension⟩"
    },
    y = {
      details = [[
See above.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/y",
      meta = "⟨y dimension⟩"
    },
    ["⟨color class name⟩"] = {
      details = [[
This key internally uses the `operator` command to setup an operator
that will cause all nodes of the current group to get the "logical
color" ⟨color class name⟩. Nodes retain this color in all encompassing
scopes, unless it is explicitly changed (see below) or unset (again, see
below).

    \tikz \graph [color class=red] {
      [cycle=red]  % causes all "logically" red nodes to be connected in
                   % a cycle
      a,
      b [red],
      { [red] c ->[bend right] d },
      e
    };

    \tikz \graph [color class=red, color class=green,
                  math nodes, clockwise, n=5] {
      [complete bipartite={red}{green}]
      { [red]   r_1, r_2 },
      { [green] g_1, g_2, g_3 }
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/⟨color:class:name⟩"
    }
  },
  tikz = {
    ["'"] = {
      details = [[
This is a very short alias for `swap`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/'"
    },
    ["3d view"] = {
      details = [[
With the `3d view` option, the projection of the 3D coordinates on the
2D page is defined. It is determined by rotating the coordinate system
by $-⟨azimuth⟩$ around the $z$-axis, and by ⟨elevation⟩ around the (new)
$x$-axis, as shown below.

For example, when both ⟨azimuth⟩ and ⟨elevation⟩ are 0$^\circ$, $+z$
will be pointing upward, and $+x$ will be pointing right. The default is
as shown below.

    \begin{tikzpicture}[3d view]
      \draw[->] (-1,0,0) -- (1,0,0) node[pos=1.1]{x};
      \draw[->] (0,-1,0) -- (0,1,0) node[pos=1.1]{y};
      \draw[->] (0,0,-1) -- (0,0,1) node[pos=1.1]{z};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/3d:view",
      meta = "{azimuth}{elevation}"
    },
    [">"] = {
      details = [[
This is a short way of saying `<->/.tip=`⟨end arrow specification⟩.

    \begin{tikzpicture}[scale=2,ultra thick]
      \begin{scope}[>=Latex]
        \draw[>->]    (0pt,3ex) -- (1cm,3ex);
        \draw[|<->>|] (0pt,2ex) -- (1cm,2ex);
      \end{scope}
      \begin{scope}[>=Stealth]
        \draw[>->]    (0pt,1ex) -- (1cm,1ex);
        \draw[|<<.<->|] (0pt,0ex) -- (1cm,0ex);
      \end{scope}
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/>",
      meta = "⟨end arrow specification⟩"
    },
    above = {
      details = [[
With the `positioning` library loaded, the `above` option does not take
a simple ⟨dimension⟩ as its parameter. Rather, it can (also) take a more
elaborate ⟨specification⟩ as parameter. This ⟨specification⟩ has the
following general form: It starts with an optional ⟨shifting part⟩ and
is followed by an optional ⟨of-part⟩. Let us start with the ⟨shifting
part⟩, which can have three forms:

1.  It can simply be a ⟨dimension⟩ (or a mathematical expression that
    evaluates to a dimension) like `2cm` or `3cm/2+4cm`. In this case,
    the following happens: the node's anchor is set to `south` and the
    node is vertically shifted upwards by ⟨dimension⟩.

        \begin{tikzpicture}
          \draw[help lines] (0,0) grid (2,2);
          \node at (1,1) [above=2pt+3pt,draw] {above};
        \end{tikzpicture}

    This use of the `above` option is the same as if the `positioning`
    library were not loaded.

2.  It can be a ⟨number⟩ (that is, any mathematical expression that does
    not include a unit like `pt` or `cm`). Examples are `2` or
    `3+sin(60)`. In this case, the anchor is also set to `south` and the
    node is vertically shifted by the vertical component of the
    coordinate `(0,`⟨number⟩`)`.

        \begin{tikzpicture}
          \draw[help lines] (0,0) grid (2,2);
          \node at (1,1) [above=.2,draw] {above};
          % south border of the node is now 2mm above (1,1)
        \end{tikzpicture}

3.  It can be of the form ⟨number or dimension 1⟩` and `⟨number or
    dimension 2⟩. This specification does not make particular sense for
    the `above` option, it is much more useful for options like
    `above left`. The reason it is allowed for the `above` option is
    that it is sometimes automatically used, as explained later.

    The effect of this option is the following. First, the point
    `(`⟨number or dimension 2⟩`,`⟨number or dimension 1⟩`)` is computed
    (note the inverted order), using the normal rules for evaluating
    such a coordinate, yielding some position. Then, the node is shifted
    by the vertical component of this point. The anchor is set to
    `south`.

        \begin{tikzpicture}
          \draw[help lines] (0,0) grid (2,2);
          \node at (1,1) [above=.2 and 3mm,draw] {above};
          % south border of the node is also 2mm above (1,1)
        \end{tikzpicture}

The ⟨shifting part⟩ can optionally be followed by a ⟨of-part⟩, which has
one of the following forms:

1.  The ⟨of-part⟩ can be `of`` `⟨coordinate⟩, where ⟨coordinate⟩ is
    *not* in parentheses and it is *not* just a node name. An example
    would be `of somenode.north` or `of {2,3}`. In this case, the
    following happens: First, the node's `at` parameter is set to the
    ⟨coordinate⟩. Second, the node is shifted according to the
    ⟨shift-part⟩. Third, the anchor is set to `south`.

    Here is a basic example:

        \begin{tikzpicture}[every node/.style=draw]
          \draw[help lines] (0,0) grid (2,2);
          \node (somenode) at (1,1) {some node};

          \node [above=5mm of somenode.north east] {\tiny 5mm of somenode.north east};
          \node [above=1cm of somenode.north]      {\tiny 1cm of somenode.north};
        \end{tikzpicture}

    As can be seen the `above=5mm of somenode.north east` option does,
    indeed, place the node 5mm above the north east anchor of
    `somenode`. The same effect could have been achieved writing
    `above=5mm` followed by `at=(somenode.north east)`.

    If the ⟨shifting-part⟩ is missing, the shift is not zero, but rather
    the value of the `node distance` key is used, see below.

2.  The ⟨of-part⟩ can be `of `⟨node name⟩. An example would be
    `of somenode`. In this case, the following usually happens:

    -   The anchor is set to `south`.

    -   The node is shifted according to the ⟨shifting part⟩ or, if it
        is missing, according to the value of `node distance`.

    -   The node's `at` parameter is set to ⟨node name⟩`.north`.

    The net effect of all this is that the new node will be placed in
    such a way that the distance between its south border and ⟨node
    name⟩'s north border is exactly the given distance.

        \begin{tikzpicture}[every node/.style=draw]
          \draw[help lines] (0,0) grid (2,2);
          \node (some node) at (1,1) {some node};

          \node (other node) [above=1cm of some node] {\tiny above=1cm of some node};

          \draw [<->] (some node.north) -- (other node.south)
                                        node [midway,right,draw=none] {1cm};
        \end{tikzpicture}

    It is possible to change the behavior of this ⟨specification⟩ rather
    drastically, using the following key:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/above",
      meta = "⟨specification⟩"
    },
    ["above delimiter"] = {
      details = [[
This option allows you to add a delimiter above the node. It is
implemented by rotating a left delimiter.

    \begin{tikzpicture}
      \matrix [matrix of math nodes,%
               left delimiter=\|,right delimiter=\rmoustache,%
               above delimiter=(,below delimiter=\}]
      {
        a_8 & a_1 & a_6 \\
        a_3 & a_5 & a_7 \\
        a_4 & a_9 & a_2 \\
      };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/above:delimiter",
      meta = "⟨delimiter⟩"
    },
    ["above left"] = {
      details = [[
Does the same as `anchor=south east`. Note that giving both `above` and
`left` options does not have the same effect as `above left`, rather
only the last `left` "wins". Actually, this option also takes an
⟨offset⟩ parameter, but using this parameter without using the
`positioning` library is deprecated. (The `positioning` library changes
the meaning of this parameter to something more sensible.)

    \tikz \fill (0,0) circle (2pt) node[above left] {above left};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/above:left"
    },
    ["above left of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/above:left:of",
      meta = "⟨node⟩"
    },
    ["above of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/above:of",
      meta = "⟨node⟩"
    },
    ["above right"] = {
      details = [[
Works similar to `above left`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/above:right",
      meta = "⟨specification⟩"
    },
    ["above right of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/above:right:of",
      meta = "⟨node⟩"
    },
    absolute = {
      details = [[
When this key is set, the ⟨angle⟩ is interpreted differently: We still
use a point on the border of the `main node`, but the angle is measured
"absolutely", that is, an angle of `0` refers to the point on the border
that lies on a straight line from the `main node`'s center to the right
(relative to the paper, not relative to the local coordinate system of
either the node or the scope).

The difference can be seen in the following example:

    \tikz [rotate=-80,every label/.style={draw,red}]
      \node [transform shape,rectangle,draw,label=right:label] {main node};

    \tikz [rotate=-80,every label/.style={draw,red},absolute]
      \node [transform shape,rectangle,draw,label=right:label] {main node};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/absolute",
      meta = "⟨true or false⟩"
    },
    accepting = {
      details = [[
This style is used to draw accepting states. You can replace this by the
style `accepting by arrow` to get accepting states with an arrow leaving
them.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/accepting"
    },
    ["accepting above"] = {
      details = [[
This is a shorthand for `accepting by arrow,accepting where=above`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:above"
    },
    ["accepting below"] = {
      details = [[
Works similarly to the previous option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:below"
    },
    ["accepting by arrow"] = {
      details = [[
This style causes an arrow and, possibly, some text to be added to the
node. The arrow points to the text from the node.

The same options as for initial states can be used, only with `initial`
replaced by `accepting`:

    \begin{tikzpicture}
      [shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},initial text=,
       every state/.style={draw=blue!50,very thick,fill=blue!20},
       accepting/.style=accepting by arrow]

      \node[state,initial]  (q_0)                      {$q_0$};
      \node[state]          (q_1) [above right=of q_0] {$q_1$};
      \node[state]          (q_2) [below right=of q_0] {$q_2$};
      \node[state,accepting](q_3) [below right=of q_1] {$q_3$};

      \path[->] (q_0) edge              node [above left]  {0} (q_1)
                      edge              node [below left]  {1} (q_2)
                (q_1) edge              node [above right] {1} (q_3)
                      edge [loop above] node               {0} ()
                (q_2) edge              node [below right] {0} (q_3)
                      edge [loop below] node               {1} ();
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:by:arrow"
    },
    ["accepting by double"] = {
      details = [[
This style causes a double line to be drawn around a state.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:by:double"
    },
    ["accepting left"] = {
      details = [[
Works similarly to the previous option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:left"
    },
    ["accepting right"] = {
      details = [[
Works similarly to the previous option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:right"
    },
    ["accepting text"] = {
      details = [[
This key sets the text to be used.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:text",
      meta = "⟨text⟩"
    },
    ["accepting where"] = {
      details = [[
Set the place where the text should be shown. Allowed values are
`above`, `below`, `left`, and `right`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:where",
      meta = "⟨direction⟩"
    },
    alias = {
      details = [[
This option allows you to provide another name for the node. Giving this
option multiple times will allow you to access the node via several
aliases. Using the `node also` syntax, you can also assign an alias name
to a node at a later point, see Section ??.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/alias",
      meta = "⟨another node name⟩"
    },
    align = {
      details = [[
This key is used to set up an alignment for multi-line text inside a
node. If `text width` is set to some width (let us call this *alignment
with line breaking*), the `align` key will setup the `\leftskip` and the
`\rightskip` in such a way that the text is broken and aligned according
to ⟨alignment option⟩. If `text width` is not set (that is, set to the
empty string; let us call this *alignment without line breaking*), then
a different mechanism is used internally, namely the key
`node halign header`, is set to an appropriate value. While this key,
which is documented below, is not to be used by beginners, the net
effect is simple: When `text width` is not set, you can use `\\` to
break lines and align them according to ⟨alignment option⟩ and the
resulting node's width will be minimal to encompass the resulting lines.

In detail, you can set ⟨alignment option⟩ to one of the following
values:

`align=``left`  
For alignment without line breaking, the different lines are simply
aligned such that their left borders are below one another.

    \tikz \node[fill=yellow!80!black,align=left]
      {This is a\\ demonstration text for\\ alignments.};

For alignment with line breaking, the same will happen; only the lines
will now, additionally, be broken automatically:

    \tikz \node[fill=yellow!80!black,text width=3cm,align=left]
      {This is a demonstration text for showing how line breaking works.};

`align=``flush left`  
For alignment without line breaking this option has exactly the same
effect as `left`. However, for alignment with line breaking, there is a
difference: While `left` uses the original plain TeX definition of a
ragged right border, in which TeX will try to balance the right border
as well as possible, `flush left` causes the right border to be ragged
in the LaTeX-style, in which no balancing occurs. This looks ugly, but
it may be useful for very narrow boxes and when you wish to avoid
hyphenations.

    \tikz \node[fill=yellow!80!black,text width=3cm,align=flush left]
      {This is a demonstration text for showing how line breaking works.};

`align=``right`  
Works like `left`, only for right alignment.

    \tikz \node[fill=yellow!80!black,align=right]
      {This is a\\ demonstration text for\\ alignments.};

    \tikz \node[fill=yellow!80!black,text width=3cm,align=right]
      {This is a demonstration text for showing how line breaking works.};

`align=``flush right`  
Works like `flush left`, only for right alignment.

    \tikz \node[fill=yellow!80!black,text width=3cm,align=flush right]
      {This is a demonstration text for showing how line breaking works.};

`align=``center`  
Works like `left` or `right`, only for centered alignment.

    \tikz \node[fill=yellow!80!black,align=center]
      {This is a\\ demonstration text for\\ alignments.};

    \tikz \node[fill=yellow!80!black,text width=3cm,align=center]
      {This is a demonstration text for showing how line breaking works.};

There is one annoying problem with the `center` alignment (but not with
`flush center` and the other options): If you specify a large line width
and the node text fits on a single line and is, in fact, much shorter
than the specified `text width`, an underfull horizontal box will
result. Unfortunately, this cannot be avoided, due to the way TeX works
(more precisely, I have thought long and hard about this and have not
been able to figure out a sensible way to avoid this). For this reason,
TikZ switches off horizontal badness warnings inside boxes with
`align=center`. Since this will also suppress some "wanted" warnings,
there is also an option for switching the warnings on once more:

`align=``flush center`  
Works like `flush left` or `flush right`, only for center alignment.
Because of all the trouble that results from the `center` option in
conjunction with narrow lines, I suggest picking this option rather than
`center` *unless* you have longer text, in which case `center` will give
the typographically better results.

    \tikz \node[fill=yellow!80!black,text width=3cm,align=flush center]
      {This is a demonstration text for showing how line breaking works.};

`align=``justify`  
For alignment without line breaking, this has the same effect as `left`.
For alignment with line breaking, this causes the text to be
"justified". Use this only with rather broad nodes.

    \tikz \node[fill=yellow!80!black,text width=3cm,align=justify]
      {This is a demonstration text for showing how line breaking works.};

In the above example, TeX complains (rightfully) about three very badly
typeset lines. (For this manual I asked TeX to stop complaining by using
`\hbadness=10000`, but this is a foul deed, indeed.)

`align=``none`  
Disables all alignments and `\\` will not be redefined.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/align",
      meta = "⟨alignment option⟩"
    },
    ["allow upside down"] = {
      details = [[
If set to `true`, TikZ will not "righten" upside down text.

    \tikz [allow upside down]
      \draw (0,0) .. controls +(up:2cm) and +(left:2cm) .. (1,3)
        node foreach \p in {0,0.25,...,1} [sloped,above,pos=\p]{\p};

    \begin{tikzpicture}[->,allow upside down]
      \draw (0,0)   -- (2,0.5) node[midway,sloped,above] {$x$};
      \draw (2,-.5) -- (0,0)   node[midway,sloped,below] {$y$};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/allow:upside:down",
      meta = "⟨boolean⟩"
    },
    ["ampersand replacement"] = {
      details = [[
If a macro name is provided, this macro will be defined to be equal to
`\pgfmatrixnextcell` inside matrices and `& ` will not be made active.
For instance, you could say `ampersand replacement=\& ` and then use
`\& ` to separate columns as in the following example:

    \tikz
      \matrix [ampersand replacement=\&]
      {
        \draw (0,0)   circle (4mm); \& \node[rotate=10] {Hello};        \\
        \draw (0.2,0) circle (2mm); \& \fill[red]   (0,0) circle (3mm); \\
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ampersand:replacement",
      meta = "⟨macro name or empty⟩"
    },
    anchor = {
      details = [[
Causes the node to be shifted such that its anchor ⟨anchor name⟩ lies on
the current coordinate.

The only anchor that is present in all shapes is `center`. However, most
shapes will at least define anchors in all "compass directions".
Furthermore, the standard shapes also define a `base` anchor, as well as
`base west` and `base east`, for placing things on the baseline of the
text.

The standard shapes also define a `mid` anchor (and `mid west` and
`mid east`). This anchor is half the height of the character "x" above
the base line. This anchor is useful for vertically centering multiple
nodes that have different heights and depth. Here is an example:

    \begin{tikzpicture}[scale=3,transform shape]
      % First, center alignment -> wobbles
      \draw[anchor=center] (0,1)  node{x} -- (0.5,1)  node{y} -- (1,1)  node{t};
      % Second, base alignment -> no wobble, but too high
      \draw[anchor=base]   (0,.5) node{x} -- (0.5,.5) node{y} -- (1,.5) node{t};
      % Third, mid alignment
      \draw[anchor=mid]    (0,0)  node{x} -- (0.5,0)  node{y} -- (1,0)  node{t};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/anchor",
      meta = "⟨anchor name⟩"
    },
    ["and gate"] = {
      details = [[
This key should be passed to a `node` command. It will cause the node to
"look like" an `and gate`, where the exact appearance of the gate is
dictated by the which circuit environment is used. To further configure
the appearance of the `and gate`, see Section ??.

    \tikz [circuit logic IEC] \node [and gate] {$A$};

    \tikz [circuit logic US]
    {
      \node [and gate,point down] {$A$};
      \node [and gate,point down,info=center:$A$] at (1,0) {};
    }

**Inputs.** Multiple inputs can be specified for a logic gate (provided
they support multiple inputs: a not gate -- also known as an inverter --
does not). However, there is an upper limit for the number of inputs
which has been set to 1024, which should be *way* more than would ever
be needed.

The following key is used to configure the inputs. It is available only
inside a `circuit logic` environment.

(This key is just a shorthand for `logic gate inputs`, described in
detail on page ??. There you will also find descriptions of how to
configure the size of the inverted circles and the way the symbol size
increases when there are too many inputs.)

**Output.** Every logic gate has one anchor called `output`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/and:gate"
    },
    ["angle eccentricity"] = {
      details = [[
    \tikz \draw (2,0) coordinate (A) -- (0,0) coordinate (B)
             -- (1,1) coordinate (C)
      pic ["$\alpha$", draw, ->] {angle};

    \tikz \draw (2,0) coordinate (A) -- (0,0) coordinate (B)
             -- (1,1) coordinate (C)
      pic ["$\alpha$", draw, angle eccentricity=1] {angle};

    \tikz {
      \draw (2,0) coordinate (A) -- (0,0) coordinate (B)
         -- (1,1) coordinate (C)
          pic (alpha) ["$\alpha$", draw] {angle};

      \draw (alpha) circle [radius=5pt];
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/angle:eccentricity",
      meta = "⟨factor⟩"
    },
    ["angle radius"] = {
      details = [[
The length of the sides of the angle's wedge:

    \tikz \draw (2,0) coordinate (A) -- (0,0) coordinate (B)
             -- (-1,-1) coordinate (C)
               pic [fill=black!50]                      {angle = A--B--C}
               pic [draw,->,red,thick,angle radius=1cm] {angle = C--B--A};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/angle:radius",
      meta = "⟨dimension⟩"
    },
    animate = {
      details = [[
You must place all specifications of animations inside uses of
`animate`. You can, and usually should, place the specification of all
timelines of a single picture inside a single use of this key since it
will reset the time and the fork time (explained in Section ??). You
can, however, use this key several times, in principle. Note that if you
animate the same attribute of the same object in two different uses of
`animate`, two separate timelines will result (and complicated rules are
used to determine which one "wins" in case they specify conflicting
values for the attribute at different times).

The key can be used at all places where a TikZ key is used; typically
you will use it with a `{scope}` environment, inside the options of a
node, or directly with the `\tikz` command:

    \tikz \node [fill, text = white, animate = {
      myself:fill = {0s = "red", 2s = "blue", begin on = click }}] {Click me};

    \tikz [animate = {a node:fill = {0s = "red", 2s = "blue",
                                     begin on = click}}]
      \node (a node) [fill, text = white] {Click me};

The details of what, exactly, happens in the ⟨animation specification⟩
will be described in the rest of this section. However, basically, an
⟨animation specification⟩ is just a sequence of normal TikZ key--value
pairs that get executed with the path prefix `/tikz/animate` and with
some special syntax handlers installed. In particular, you can define
styles for this key path and use them. For instance, we can define a
`shake` animation like this:

    \tikzset{
      animate/shake/.style = {myself:xshift = { begin on=click,
          0s = "0mm", 50ms = "#1", 150ms = "-#1", 250ms = "#1", 300ms = "0mm" }}}
    \tikz \node [fill = blue!20, draw=blue, very thick, circle,
      animate = {shake = 1mm}] {Shake};
    \tikz \node [fill = blue!20, draw=blue, very thick, circle,
      animate = {shake = 2mm}] {SHAKE};

Note that, as stressed earlier, you can only use the `animate` key to
specify animations for objects that do not yet exist. The node and
object names mentioned in a specification always refer to "upcoming"
objects; already existing objects of the same name are not influenced.

You can use the `name` key inside `animate` to "name" the animation.
Once named, you can later reference the animation in other animations;
for instance, you can say that another animation should start when the
present animation has ended.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate",
      meta = "⟨animation specification⟩"
    },
    ["animate/arrows"] = {
      details = [[
This key only has an effect on `:path` animations. It causes the arrow
tips specified in ⟨arrow spec⟩ to be added to the path during the
animation (the syntax is the same as for the normal `arrows` key). If
you have several different animations for a paths, these may contain
different arrow tips, but each animation must stick to one kind of arrow
tips.

What happens internally when this key is used is the following: The
specified arrow tips are rendered internally as so-called *markers,*
which are small graphics that can be placed at the beginning and ends of
paths and which "rotate along" as a path changes. Note that these
markers are used *only* in the context of animated paths, the arrow tips
of normal, "static" paths are drawn without the use of markers.
Normally, there is no visual difference between an arrow tip drawn using
markers or those drawn for static paths, but in rare cases there may be
differences. You should only add arrows to open path consisting of a
single segment with sufficiently long first and last segments (so that
TikZ can shorten these segments correctly when necessary).

As pointed out earlier, the only way to add arrow tips to a path that is
animated is using this key, you can *not* say something like

    \draw :path = { 1s = "{(0,0) -- (1,0)}", 2s = "{(0,1) -- (1,0)}" }
      [->] (0,0) -- (1,0);

This will raise an error since you try to animate a path (`:path = ...`)
that has normal arrow tips attached (`[->]`).

Instead, you must specify the arrow tips inside the animation command:

    \draw :path = { 1s = "{(0,0) -- (1,0)}", 2s = "{(0,1) -- (1,0)}", arrows = -> }
      (0,0) -- (1,0);

However, the above code now has a big shortcoming: While the animation
is *not* running, *no* arrow tip is shown (the `arrows` key only applies
to the animation.

The trick is to use the `base` key. It allows you to install a path as
the "base" path that is used when no animation is running and the arrows
specified for the animation will also be used for the base. All told,
the "correct" way to specify the animation is the following (note that
no static path is specified, any specified path would be overruled by
the `base` path anyway):

    \draw :path = { 1s = "{(0,0) -- (1,0)}" base, 2s = "{(0,1) -- (1,0)}", arrows = -> };

Here is an example:

    \tikz [very thick] {
      \node (node) at (-2,0)
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
      \draw :path = {
        0s = "{(0,0) to[out=90, in=180] (.5,1) to[out=0, in=90] (.5,.5)}" base,
        2s = "{(1,0) to[out=180, in=180] (.25,.5) to[out=0, in=180] (1,.5)}",
        arrows = <.<->, begin on = {click, of=node} }; }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/arrows",
      meta = "⟨arrow spec⟩"
    },
    ["animate/attribute"] = {
      details = [[
The list of attributes must be a comma-separated list of attribute
names. The timelines specified later will apply to all of these
attributes (and to all objects previously selected using `object`).
Possible attributes include colors, positions, line width, but even the
paths themselves. The exact list of possible attributes is documented in
Section ??.

    \tikz [animate = {attribute = fill, n: = { 0s = "red", 2s = "blue",
                                               begin on = click } }]
      \node (n) [fill, text = white] {The node};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/attribute",
      meta = "⟨list of attributes⟩"
    },
    ["animate/base"] = {
      details = [[
A "base" value is a value that is used for the attribute whenever the
timeline is *not* active:

    \tikz \node [fill = green, text = white] :fill =
        { 1s = "red", 2s = "blue", base = "orange", begin on = click }
      {Click me};

Syntactically, the `base` key works much like special time syntax: It
sets up a local `sync` scope and executes the ⟨options⟩ in it and
creates an `entry`. However, instead of setting the `time` attribute to
a time, it sets it to a special value that tells TikZ that when the
entry is created, the current ⟨value⟩ should be used as the `base`
value.

This means that you can write `base = "orange"` as in the above example
to set the base. However, you can also use the `base` key in other ways;
most noticeably, you can use it *after* some value:

    \tikz \node [fill = green, text = white] :fill =
        { 1s = {"red" = base}, 2s = "blue", begin on = click }
      {Click me};

Instead of using `base` as a key, you can also add `base` directly after
the quotes of a value. This is particularly useful for setting up a base
value that is also used in a timeline:

    \tikz \node [fill = green, text = white] :fill =
        { 1s = "red" base, 2s = "blue", begin on = click }
      {Click me};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/base",
      meta = "⟨options⟩"
    },
    ["animate/entry"] = {
      details = [[
Each time this key is used in the options of `animate`, TikZ checks
whether the five keys `object`, `attribute`, `id`, `time`, and `value`
are set. If one of them is not set, nothing happens. (The `id` key is
set to the value `default` by default, all other keys must be set
explicitly.)

If all of these keys are set, a *time--value* pair is created and added
to the timeline of attribute of the object. Additionally, all options
starting with `/tikz/animate/options/`, which also influence the
timeline like `begin on`, are also added to the timeline of the
object--attribute pair.

    \tikz [animate = {
      object = node, attribute = fill, time = 0s, value = red, entry,
      object = node, attribute = fill, time = 2s, value = blue, entry,
      object = node, attribute = fill, begin on = click, entry}]
      \node (node) [fill, text=white] { Click me };

In the above example, it would not have been necessary the specify the
object and the attribute in each line, they retain their values unless
they are overwritten. Thus, we could also have written:

    \tikz [animate = {
      object = node, attribute = fill, time = 0s, value = red, entry,
                                       time = 2s, value = blue, entry,
                                       begin on = click, entry}]
      \node (node) [fill, text=white] { Click me };

Note, however, that in both examples we actually add the time--value
pair $(2\mathrm{s}, \mathrm{blue})$ twice since the `time` and `value`
keys also retain their settings and, thus, for the third `entry` they
have the same values as before and a new pair is added. While this
superfluous pair is not a problem in the example (it has no visual
effect), we will see later on how such pairs can be avoided by using the
`scope` key.

A sequence of calls of `entry` can freely switch between objects and
attributes (that is, between timelines), but the times for any given
timeline must be given in non-decreasing order:

    \tikz [animate = {
      object = node,  attribute = fill, time = 0s, value = red, entry,
      object = node2, attribute = draw, entry,
      object = node,  attribute = fill, time = 2s, value = blue, entry,
      object = node2, attribute = draw, entry,
      object = node,  attribute = fill, begin on = click, entry,
      object = node2, attribute = draw, begin on = click, entry}] {
      \node (node)  [fill, text=white]            { Node 1 };
      \node (node2) [draw, ultra thick] at (0,-1) { Node 2 };
    }

In the above example, we could not have exchanged the first two lines of
the `animate` options with the third and fourth line since the values
for time `0s` must come before the values for time `2s`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/entry"
    },
    ["animate/fork"] = {
      details = [[
Sets the fork time for the local scope to ⟨t⟩ and sets the current time
to `0s`. In this scope, when you use "absolute" times like `0s` or `2s`,
you actually refer to later times that have started as ⟨t⟩.

One application of forks is in the definition of keys that add a certain
part to a longer animation. Consider for instance the definition of a
`highlight` key:

    \tikz [animate/highlight/.style = {
        scope = { fork = #1,
                  :fill = { 0s = "black", 0.1s = "white", 0.2s = "black"} }
      }]
      \node [animate = { myself: = {
                :fill = { 0s = "black", begin on = click },
                          highlight = 1s, highlight = 2s } },
             fill = blue, text=white, very thick, circle] { Click me };

In the above example, we could also have written `0.1s later` instead of
`0.2s` and, indeed, the whole style could have been defined using only
times with `later`, eliminating the need for the `fork` key. However,
using forks you can specify absolute times for things happening in a
conceptual "subprocess" and also relative times. The name `fork` for the
key is also borrowed from operating system theory, where a "fork" is the
spawning of an independent process.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/fork",
      meta = "⟨t⟩"
    },
    ["animate/id"] = {
      details = [[
Timelines are use to defined how the values of an attribute of an object
change over time. In many cases, you will have at most one timeline for
each object--attribute pair, but, sometimes, you may wish to have more
than one timeline for the same object and the same attribute. For
instance, you might have a timeline that specifies a changing `shift` of
a node in some direction and, at the same time, another timeline that
specifies an additional `shift` in some other direction(s). The problem
is that there is only one `shift` attribute and it would be difficult to
compute the joint effect of the two timelines.

For this purpose, timelines are actually identified not only by the
object--attribute pair but, in reality, by the triple consisting of the
object, the attribute, and the value of this key. We can now specify two
separate timelines:

    \tikz [animate = {
      id = 1, n:shift = { 0s = "{(0,0)}", 2s = "{(0,5mm)}", begin on = click },
      id = 2, n:shift = { 0s = "{(0,0)}", 2s = "{(5mm,0)}", begin on = click }
    }]
      \node (n) [fill = blue!20, draw=blue, very thick] {The node};

The default value of `id` is `default`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/id",
      meta = "⟨id⟩"
    },
    ["animate/object"] = {
      details = [[
The ⟨list of objects⟩ is a comma-separated list of strings of the form
⟨object⟩`.`⟨type⟩. All of the objects in the list are selected as
to-be-animate object for the next use of the `entry` key. The objects
referred to by ⟨object⟩ will be the *next* objects with the `name` key
set to ⟨object⟩. You can apply the `name` key to nodes (where you can
also use the special parentheses-syntax and put the name in parentheses,
it has the same effect), but also to scopes and paths. (The `name path`
key is not the same as `name`; it is an older key from the intersections
package and not related.)

    \tikz [animate = { object = b, :fill = {0s = "red", 2s = "blue",
                                            begin on = click }}] {
      \node (a) [fill, text = white, minimum width=1.5cm] at (0,1cm) {a};
      \node (b) [fill, text = white, minimum width=1.5cm] at (0,5mm) {b};
      \node (c) [fill, text = white, minimum width=1.5cm] at (0,0mm) {c}; }

    \tikz [animate = { object = b, :fill = {0s = "red", 2s = "blue",
                                            begin on = click },
                       object = c, :fill = {0s = "green", 2s = "blue",
                                            begin on = click } }] {
      \scoped [name = a, yshift=1cm] \fill (0,0) rectangle (1.5cm,2mm);
      \scoped [name = b, yshift=5mm] \fill (0,0) rectangle (1.5cm,2mm);
      \scoped [name = c, yshift=0mm] \fill (0,0) rectangle (1.5cm,2mm); }

If the ⟨object⟩ name is never used later in the file, no animation is
created.

The ⟨object⟩ may also be the special text `myself`. In this case, the
referenced object is the scope or object to which the `animate` key is
given. If an object is named `myself` (as in `\node (myself) ...`), you
cannot reference this node using the `object` key, `myself` *always*
refers to the object where the `animate` key is given (of course, you
can animate the node named `myself` by placing the `animate` key inside
the options of this node; you only cannot "remotely" add an animation to
it).

The ⟨object⟩ may be followed by a dot and a *type*. This is need in rare
cases where you want to animate only a special "part" of an object that
is not accessible in other ways. Normally, TikZ takes care of choosing
these types automatically, you only need to set these "if you know what
you are doing".
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/object",
      meta = "⟨list of objects⟩"
    },
    ["animate/options/along"] = {
      details = [[
Use this key with a `:shift` (or a `:position`) to make TikZ shift the
object by the coordinates along the ⟨path⟩. When this key is used, the
values may no longer be coordinates, but must be fractions of the
distance along the path. A value of `"0"` refers to the beginning of the
path and `"1"` refers to the end:

    \tikz {
      \draw [help lines] (-0.2,-0.2) grid (2.2,1.2);
      \draw (1,.5) circle [radius=1mm];
      \node :shift = {
                along = {(0,0) circle[radius=5mm]} upright,
                0s="0", 2s=".25", begin on=click }
        at (1,.5) [fill = blue, opacity=.5, circle] {Click};
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/along",
      meta = "{path}⟨sloped or upright⟩ in⟨time⟩"
    },
    ["animate/options/begin"] = {
      details = [[
This key specifies when the "moment `0s`" should be relative to the
moment when the current graphic is first displayed. You can use this key
multiple times, in this case the timeline is restarted for each of the
times specified (if it is already running, it will be reset). If no
`begin` key is given at all, the effect is the same as if `begin=0s` had
been specified.

It is permissible to set ⟨time⟩ to a negative value.

Note that this key has no effect for snapshots.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/begin",
      meta = "⟨time⟩"
    },
    ["animate/options/begin on"] = {
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/begin:on",
      meta = "⟨options⟩"
    },
    ["animate/options/begin snapshot"] = {
      details = [[
Use this key on a timeline to specify that, only for purposes of taking
snapshots, the timeline starts at ⟨start time⟩ rather than at "moment
zero". (Think of this as saying that the animation starts when a virtual
user clicks on the animation and this click occurs ⟨start time⟩ seconds
after the general "moment zero", causing the animation to "lag behind"
by this amount of time.) Computationally, for the timeline the ⟨start
time⟩ is subtracted from the snapshot's ⟨time⟩ when the value needs to
be determined:

    \tikz [make snapshot of = 1s] {
      \fill :fill = { 0s = "black", 2s = "white",
                      begin snapshot = 1s }        (0,0) rectangle ++(1,1);
      \fill :fill = { 1s = "black", 3s = "white" } (2,0) rectangle ++(1,1);
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/begin:snapshot",
      meta = "⟨start time⟩"
    },
    ["animate/options/ease"] = {
      details = [[
A shorthand for `ease in=`⟨fraction⟩`, ease out=`⟨fraction⟩.

Note that since for the first time the entry control is ignored and,
similarly, for the last time the exit control is ignored, using the
`ease` key with an animation having only two times is particularly easy,
since we only need to set `ease` once:

    \tikz {
      \foreach \i in {0,0.1,...,1} \draw (-0.9,.9-\i) -- ++(1.8,0);
      \node :yshift = { begin on = click, ease, 0s = "0cm", 2s = "-10mm" }
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/ease",
      meta = "{fraction}"
    },
    ["animate/options/ease in"] = {
      details = [[
A shorthand for `entry control={1-`⟨fraction⟩`}{1}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/ease:in",
      meta = "{fraction}"
    },
    ["animate/options/ease out"] = {
      details = [[
A shorthand for `exit control={`⟨fraction⟩`}{1}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/ease:out",
      meta = "{fraction}"
    },
    ["animate/options/end"] = {
      details = [[
This key will truncate the timeline so that it ends ⟨time⟩ after the
display of the graphic, provided the timeline begins before the
specified end time. For instance, if you specify a timeline starting at
2 s and ending at 5 s and you set `begin` to 1 s and `end` to 4 s, the
timeline will run, relative to the moment when the graphic is displayed
from 3 s to 4 s.

    \tikz \node [fill = green!50!black, text = white]
        :rotate = { 1s = "0", 5s = "90", begin = 2s, end = 4s }
      {Click me};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/end",
      meta = "⟨time⟩"
    },
    ["animate/options/end on"] = {
      details = [[
Works exactly like `begin on`, one possible end of the timeline is
specified using the ⟨options⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/end:on",
      meta = "⟨options⟩"
    },
    ["animate/options/entry control"] = {
      details = [[
Works like `exit control`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/entry:control",
      meta = "{time fraction}{value fraction}"
    },
    ["animate/options/exit control"] = {
      details = [[
Specifies an exit control using two values as above. The spline from
above would be specified as follows:

    exit control={0.5}{0},
    entry control={0.9}{1},
    0s = "50",
    10s = "100"

Note that the curve specified using exit and entry controls must be
"well-behaved" in the sense that exactly one value must be specified for
each point in time in the time interval.

In the next three example, we first specify a "smooth" exit from the
start position, then a smooth arrival at the end position, and, finally
both.

    \tikz {
      \foreach \i in {0,0.1,...,1} \draw (-0.9,.9-\i) -- ++(1.8,0);
      \node :yshift = { begin on = click,
                        0s = { exit control = {1}{0}, "0cm" },
                        1s = "-5mm",
                        2s = "-10mm" }
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
    }

    \tikz {
      \foreach \i in {0,0.1,...,1} \draw (-0.9,.9-\i) -- ++(1.8,0);
      \node :yshift = { begin on = click,
                        0s = "0cm",
                        1s = "-5mm",
                        2s = { entry control = {0}{1}, "-10mm" } }
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
    }

    \tikz {
      \foreach \i in {0,0.1,...,1} \draw (-0.9,.9-\i) -- ++(1.8,0);
      \node :yshift = { begin on = click,
                        0s = { exit control = {1}{0}, "0cm" },
                        1s = "-5mm",
                        2s = { entry control = {0}{1}, "-10mm" } }
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/exit:control",
      meta = "{time fraction}{value fraction}"
    },
    ["animate/options/forever"] = {
      details = [[
This key causes the timeline to continue "forever" after the last time
with the last value. You can also think of this as having the animation
"freeze" at the end.

    \tikz \node :fill = { 1s="red", 2s="blue", forever, begin on=click}
      [fill = green!50!black, text = white] {Click me};

    \tikz \node [fill = green!50!black, text = white]
        :fill = { 1s = "red", 2s = "blue", begin on = click }
      {Click me};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/forever"
    },
    ["animate/options/freeze"] = {
      details = [[
An alias for `forever`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/freeze"
    },
    ["animate/options/jump"] = {
      details = [[
Works like the `stay` key, but will cause the value to "jump to" the new
value right at the beginning of the time interval. It is similar to an
entry control specifying a "flat" curve.

    \tikz {
      \foreach \i in {0,0.1,...,1} \draw (-0.9,.9-\i) -- ++(1.8,0);
      \node :yshift = { begin on = click,
                        0s = "0cm",
                        1s = {jump, "-5mm"},
                        2s = "-10mm" }
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/jump"
    },
    ["animate/options/origin"] = {
      details = [[
Shifts the animation coordinate system by ⟨coordinate⟩. This has the
effect that the "origin" for scalings and rotations gets shifted by this
amount. In the following example, the point around which the rotation is
done is the right border at `(2,1)` since the origin of the animation is
at `(1,1)` relative to the picture's origin and the `origin` key shifts
it one centimeter to the right.

    \tikz {
      \draw [help lines] (-0.2,-0.2) grid (2.2,2.2);
      \node :rotate = { 0s="0", 2s="45", begin on=click,
                        origin = {(1,0)}}
        at (1,1) [fill = blue!20, draw = blue, ultra thick] {Click me};
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/origin",
      meta = "⟨coordinate⟩"
    },
    ["animate/options/repeat"] = {
      details = [[
An alias for `repeats`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/repeat",
      meta = "⟨specification⟩"
    },
    ["animate/options/repeats"] = {
      details = [[
Use this key to specify that the timeline animation should repeat at the
end. The ⟨specification⟩ must consist of two parts, each of which may be
empty. The first part is one of the following:

-   Empty, in which case the timeline repeats forever.

        \tikz \node :rotate = { 0s = "0", 2s = "90",
                                repeats, begin on = click }
            [fill = blue!20, draw = blue, ultra thick, circle] {Click me!};

-   A ⟨number⟩ (like `2` or `3.25`), in which case the timeline repeats
    ⟨number⟩ times.

        \tikz \node :rotate = { 0s = "0", 2s = "90",
                                repeats = 1.75, begin on = click }
            [fill = blue!20, draw = blue, ultra thick, circle] {Click me!};

-   The text "`for` ⟨time⟩" (like `for 2s` or `for 300ms`), in which
    case the timeline repeats however often necessary so that it stops
    exactly after ⟨time⟩.

        \tikz \node :rotate = { 0s = "0", 2s = "90",
                                repeats = for 3.5s, begin on = click }
            [fill = blue!20, draw = blue, ultra thick, circle] {Click me!};

The second part of the specification must be one of the following:

-   Empty, in which case each time the timeline is restarted, the
    attribute's value undergoes the same series of values it did
    previously.

-   The text `accumulating`. This has the effect that each time the
    timeline is restarted, the last values specified by the timeline is
    *added* to the value from the previous iteration(s). A typical
    example is an animation that shifts a scope by, say, 1 cm over a
    time of 1 s. Now, if you repeat this five times, normally the scope
    will shift 1 cm for 1 s then "jump back", shift again, jump back,
    and so on for five times. In contrast, when the repeats are
    accumulating, the scope will move by 5 cm over 5 s in total.

        \tikz \node :rotate = { 0s = "0", 2s = "90", begin on = click,
                                repeats = accumulating }
            [fill = blue!20, draw = blue, ultra thick, circle] {Click me!};

        \tikz \node :rotate = { 0s = "0", 2s = "90", begin on = click,
                                repeats = for 4s accumulating }
            [fill = blue!20, draw = blue, ultra thick, circle] {Click me!};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/repeats",
      meta = "⟨specification⟩"
    },
    ["animate/options/restart"] = {
      details = [[
You can set ⟨choice⟩ to one of the following:

-   `true` means that the animation will restart each time the event is
    triggered. If the animation is already running, it will be reset to
    its beginning.

-   `false` means that once the animation has started once, it will
    never be restarted.

        \tikz \node :rotate = { 0s="0", 2s="90",
                                restart = false, begin on = {click}}
            [fill = blue!20, draw = blue, circle, ultra thick] {Here!};

-   `never` means the same as `false`.

-   `when not active` means that the animation will restart when the
    event is triggered, but *not* while the animation is running.

        \tikz \node :rotate = { 0s="0", 2s="90",
                                restart = when not active, begin on = {click}}
            [fill = blue!20, draw = blue, circle, ultra thick] {Here!};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/restart",
      meta = "⟨choice⟩"
    },
    ["animate/options/stay"] = {
      details = [[
Specifies that inside the time interval the value "stays put" at the
first value till the end of the interval, where it will jump to the
second value. This is similar to an exit control where the curve is
"infinitely flat".

    \tikz {
      \foreach \i in {0,0.1,...,1} \draw (-0.9,.9-\i) -- ++(1.8,0);
      \node :yshift = { begin on = click,
                        0s = "0cm",
                        1s = {stay, "-5mm"},
                        2s = "-10mm" }
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/stay"
    },
    ["animate/options/transform"] = {
      details = [[
While the `origin` key does only a shift, the `transform` key allows you
to add an arbitrary transformation to the animation coordinate system
using keys like `shift`, `rotate` or even `reset cm` and `cm`. In
particular, `origin=`⟨c⟩ has the same effect as `transform` `=`
`{shift=`⟨c⟩`}`. Note that the transformation only influences the
animation, not the object itself.

As an example, when you say `transform={scale=2}`, an `:xshift` with a
value of `"1cm"` will actually shift the object by 2cm. Similarly, after
you say `transform={rotate=90,scale=2}`, the same `:xshift` of `"1cm"`
will actually shift the object by 2cm upwards.

Note that, internally, TikZ has to invert the transformation matrix
resulting from the ⟨transformation keys⟩ (plus the original animation
transformation matrix), which can by numerically instable when you use
ill-conditioned transformations.

    \tikz {
      \draw [help lines] (-0.2,-0.2) grid (2.2,2.2);
      \node :xshift = { 0s="0cm", 2s="5mm", begin on=click,
                        transform = {rotate=-90} }
        at (1,1) [fill = blue!20, draw = blue, ultra thick] {Click me};
    }

    \tikz {
      \draw [help lines] (-0.2,-0.2) grid (2.2,2.2);
      \node :xshift = { 0s="0cm", 2s="5mm", begin on=click,
                        transform = {rotate=-45, scale=2} }
        at (1,1) [fill = blue!20, draw = blue, ultra thick] {Click me};
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/transform",
      meta = "⟨transformation keys⟩"
    },
    ["animate/remember"] = {
      details = [[
This key stores the current time (the time of the last use of the `time`
key) globally in the macro ⟨macroname⟩. This time will include the
offset of the fork time:

    time = 2s,
    fork = 2s later,    % fork time is now 4s
    time = 1s,          % local time is 1s, absolute time is 5s (1s + fork time)
    time = 1s later,    % local time is 2s, absolute time is 6s (2s + fork time)
    remember = \mytime  % \mytime is now 6s
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/remember",
      meta = "⟨macroname⟩"
    },
    ["animate/resume"] = {
      details = [[
The ⟨absolute time⟩ is evaluated using `\pgfparsetime` and, then, the
current time is set to the resulting time minus the fork time. When the
⟨absolute time⟩ is a macro previously set using `remember`, the net
effect of this is that we return to the exact "moment" in the global
time line when `remember` was used.

    fork = 4s,
    time = 1s,
    remember = \mytime  % \mytime is now 5s
    fork = 2s,          % fork time is now 2s, local time is 0s
    resume   = \mytime  % fork time is still 2s, local time is 3s

Using resume you can easily implement a "join" operation for forked
times. You simply remember the times at the ends of the forks and then
resume the maximum time of these remembered times:

    scope = {
      fork,
      time = 1s later,
      ...
      remember = \forka
    },
    scope = {
      fork,
      time = 5s later,
      ...
      remember = \forkb
    },
    scope = {
      fork,
      time = 2s later,
      ...
      remember = \forkc
    },
    resume = {max(\forka,\forkb,\forkc)} % "join" the three forks
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/resume",
      meta = "⟨absolute time⟩"
    },
    ["animate/scope"] = {
      details = [[
Executed the ⟨options⟩ inside a TeX scope. In particular, all settings
made inside the scope have no effect after the end of the `scope`.

    \tikz \node [animate = { myself: = { begin on = click,
        scope = { attribute = fill, repeats = 3, 0s = "red", 2s = "red!50" },
        scope = { attribute = draw,              0s = "red", 2s = "red!50" }
      }},
      fill=blue!20, draw=blue, very thick, circle] {Click me};

Without the use of the `scope` key, the `repeats` key would also affect
the draw attribute.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/scope",
      meta = "⟨options⟩"
    },
    ["animate/shorten < "] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/shorten:<:",
      meta = " ⟨dimension⟩"
    },
    ["animate/shorten > "] = {
      details = [[
For animated paths, just as the key `arrows` has to be passed to the
animation (to `:path`) instead of to the static path, the keys
`shorten >` and `shorten <` also have to be passed to the `:path` key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/shorten:>:",
      meta = " ⟨dimension⟩"
    },
    ["animate/sync"] = {
      details = [[
A shorthand for `scope={` ⟨options⟩ `, remember=\temp},resume=\temp`
where `\temp` is actually an internal name. The effect is that after a
`sync` the local time just continues as if the scope where not present
-- but regarding everything else the effects are local to the `sync`
scope.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/sync",
      meta = "⟨options⟩"
    },
    ["animate/time"] = {
      details = [[
Sets the time for the next time--value pair in a call of `entry` to
⟨time⟩ plus the current fork time. The text `later` is optional. Both
"fork times" and the optional `later` will be explained in a moment.

**Time Parsing.** The ⟨time⟩ is parsed using the command
`\pgfparsetime`, which is essentially the same as the usual math parser
of TikZ, and the result is interpreted as a time in seconds. Thus, a
⟨time⟩ of `2+3` means "5 seconds" and a ⟨time⟩ of `2*(2.1)` means "4.2
seconds". (You could even specify silly times like `1in`, which results
in the time "72.27 seconds". Please do not do that.) The "essentially"
refers to the fact that some extras are installed when the time parser
is running:

-   The postfix operator `s` is added, which has no effect. Thus, when
    you write `5s` you get the same results as `5`, which is exactly 5
    seconds as desired.

-   The postfix operator `ms` is added, which divides a number by 1000,
    so `2ms` equals 0.002s.

-   The postfix operator `min` is added, which multiplies a number
    by 60.

-   The postfix operator `h` is added, which multiplies a number
    by 3600.

-   The infix operator `:` is redefined, so that it multiplies its first
    argument by 60 and adds the second. This implies that `1:20` equals
    80s and `01:00:00` equals 3600s.

-   The parsing of octal numbers is switched off to allow things like
    `01:08` for 68s.

Note that you cannot use the colon syntax for times in things like
`01:20 = "0"` would (falsely) be interpreted as: "For the object named
`01` and its attribute named `20`, do something." You can, however, use
`01:20` in arguments to the `time` key, meaning that you would have to
write instead: `time = 1:20, "0"`, possibly surround by a `scope`.

**Relative Times.** You can suffix a `time` key with "`later`". In this
case, the ⟨time⟩ is interpreted as an offset to the time in the previous
use of the time key:

    \tikz \node :fill = { begin on = click,
        0s = "white",
        500ms later = "red",
        500ms later = "green",  % same as 1s   = "-5mm"
        500ms later = "blue"} % same as 1.5s = "-2.5mm"
      [fill=blue!20, draw=blue, very thick, circle] {Click me};

In reality, the offset is not taken to just any previous use of the
`time` key, but to the most recent use of this key or of the `resume`
key in the current local TeX scope. Here is an example:

    time = 2s,
    time = 1s later,    % same as time = 3s
    time = 500ms later, % same as time = 3.5s
    time = 4s,
    time = 1s later,    % same as time = 5s
    scope = {           % opens a local scope
      time = 1s later,  % same as time = 6s
      time = 10s
      time = 1s later   % same as time = 11s
    },                  % closes the scope, most recent time is 5s once more
    time = 2s later     % same as time = 7s

**Fork Times.** The time meant by the value ⟨time⟩ passed to the `time`
key is not used directly. Rather, TikZ adds the current *fork time* to
it, which is `0s` by default. You can change the fork time using the
following key:

**Remembering and Resuming Times.** When you have a complicated
animation with a long timeline, you will sometimes wish to start some
animation when some other animation has reached a certain moment; but
this moment is only reached through heavy use of `later` times and/or
forks. In such situations, the following keys are useful:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/time",
      meta = "⟨time⟩later"
    },
    ["animate/value"] = {
      details = [[
This key sets the value of the next time--value pair created by `entry`
to ⟨value⟩. The syntax of the ⟨value⟩ is not fixed, it depends on the
type of the attribute. For instance, for an attribute like `opacity` the
⟨value⟩ must be an expression that can be evaluated to a number between
0 and 1; for the attribute `color` the ⟨value⟩ must, instead, be a
color; and so on. Take care that when a value contains a comma, you must
surround it by braces as in `"{(1,1)}"`.

The allowed texts for the ⟨value⟩ is always the same as the one you
would pass to the TikZ option of the same name. For instance, since the
TikZ option `shift` expects a coordinate, you use coordinates as ⟨value⟩
with the usual TikZ syntax (including all sorts of extensions, the
animation system calls the standard TikZ parsing routines). The same is
true of dimensions, scalar values, colors, and so on.

In addition to the values normally use for setting the attribute, you
can also (sometimes) use the special text `current value` as ⟨value⟩.
This means that the value of the point in the timeline should be
whatever the value the attribute has at the beginning of the timeline.
For instance, when you write

    animate = { obj:color = { 0s = "current value", 2s = "white" } }

the color of `obj` will change from whatever color it currently has to
white in two seconds. This is especially useful when several animations
are triggered by user events and the current color of `obj` cannot be
determined beforehand.

There are several limitations on the use of the text `current value`,
which had to be imposed partly because of the limited support of this
feature in SVG:

-   You can use `current value` only with the first time in a timeline.

-   You can only have two times in a timeline that starts with
    `current value`.

-   You cannot use `current value` for timelines of which you wish to
    take a snapshot.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animate/value",
      meta = "⟨value⟩"
    },
    ["animations/base"] = {
      details = [[
The syntax of the ⟨value⟩ is the same as for the `entry` key. The
⟨value⟩ is installed as the value of the object's attribute whenever the
timeline is not active. This makes it easy to specify the value of an
attribute when the animation is "not running".

    \tikz {
      \pgfanimateattribute{rotate}{
        whom = node, begin on = {click},
        entry = {0s}{90}, entry = {2s}{180},
        base  = 45
      }
      \node (node) [fill = blue!20, draw = blue, very thick, circle] {Click me!};
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animations/base",
      meta = "⟨value⟩"
    },
    ["animations/begin snapshot"] = {
      details = [[
When this key is used inside the options of `\pgfanimateattribute`, with
respect to snapshots, the timeline begins at ⟨begin time⟩. This means
that, if the snapshot time is set to ⟨time⟩ and the beginning of the
snapshot's timeline is set to ⟨begin time⟩, the attribute is set to the
value of the timeline at time $⟨time⟩ -
        ⟨begin time⟩$.

The idea is that when you make a snapshot of several animations and all
of them have started at different times because of different events, you
use `begin snapshot` with each object and attribute to directly specify
when these different events have happened.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/animations/begin:snapshot",
      meta = "⟨begin time⟩"
    },
    annotation = {
      details = [[
This style indicates that a node is an annotation node. It includes the
style `every annotation`, which allows you to change this style in a
convenient fashion.

    \begin{tikzpicture}
      [mindmap,concept color=blue!80,
      every annotation/.style={fill=red!20}]
      \node [concept] (root)  {Root concept};

      \node [annotation,right] at (root.east)
      {The root concept is, in general, the most important concept.};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/annotation"
    },
    ["annotation arrow"] = {
      details = [[
This style should set the default `>` arrow to some nice value.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/annotation:arrow"
    },
    ["append after command"] = {
      details = [[
Some of the path commands described in the following sections take
optional arguments. For these commands, when you use this key inside
these options, the ⟨path⟩ will be inserted *after* the path command is
done. For instance, when you give this command in the option list of a
node, the ⟨path⟩ will be added after the node. This is used by, for
instance, the `label` option to allow you to specify a label in the
option list of a node, but have this `label` cause a node to be added
after another node.

    \tikz \draw node [append after command={(foo)--(1,1)},draw] (foo){foo};

If this key is called multiple times, the effects accumulate, that is,
all of the paths are added in the order to keys were found.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/append:after:command",
      meta = "⟨path⟩"
    },
    arrows = {
      details = [[
The `arrows` key, which is normally used to set the arrow tips for the
current scope, can also be used to set some arrow keys for the current
scope. When the argument to `arrows` starts with an opening bracket and
only otherwise contains one further closing bracket at the very end,
this semantic of the `arrow` key is assumed.

The ⟨arrow keys⟩ will be set for the rest of current scope. This is
useful for generally setting some design parameters or for generally
switching on, say, bending as in:

    \tikz [arrows={[bend]}] ... % Bend all arrows
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/arrows",
      meta = "[⟨arrow keys⟩]"
    },
    at = {
      details = [[
If this option is explicitly set inside the ⟨options⟩ (or indirectly via
the `every circle` style), the ⟨coordinate⟩ is used as the center of the
circle instead of the current point. Setting `at` to some value in an
enclosing scope has no effect.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/at",
      meta = "⟨coordinate⟩"
    },
    ["at end"] = {
      details = [[
Set to `pos=1`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/at:end"
    },
    ["at start"] = {
      details = [[
Set to `pos=0`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/at:start"
    },
    attribute = {
      details = [[
This style is used to indicate that a node is an attribute. To connect
an attribute to its entity, you can use, for example, the `child`
command or the `pin` option.

    \begin{tikzpicture}
      \node[entity] (sheep)  {Sheep}
        child {node[attribute] {name}}
        child {node[attribute] {color}};
    \end{tikzpicture}

    \begin{tikzpicture}[every pin edge/.style=draw]
      \node[entity,pin={[attribute]60:name},pin={[attribute]120:color}] {Sheep};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/attribute"
    },
    auto = {
      details = [[
This option causes an anchor position to be calculated automatically
according to the following rule. Consider a line between two points. If
the ⟨direction⟩ is `left`, then the anchor is chosen such that the node
is to the left of this line. If the ⟨direction⟩ is `right`, then the
node is to the right of this line. Leaving out ⟨direction⟩ causes
automatic placement to be enabled with the last value of `left` or
`right` used. A ⟨direction⟩ of `false` disables automatic placement.
This happens also whenever an anchor is given explicitly by the `anchor`
option or by one of the `above`, `below`, etc. options.

This option only has an effect for nodes that are placed on lines or
curves.

    \begin{tikzpicture}
      [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
      \node (a) at (-1,-2) {a};
      \node (b) at ( 1,-2) {b};
      \node (c) at ( 2,-1) {c};
      \node (d) at ( 2, 1) {d};
      \node (e) at ( 1, 2) {e};
      \node (f) at (-1, 2) {f};
      \node (g) at (-2, 1) {g};
      \node (h) at (-2,-1) {h};

      \foreach \from/\to in {a/b,b/c,c/d,d/e,e/f,f/g,g/h,h/a}
        \draw [->] (\from) -- (\to)
                   node[midway,fill=red!20] {\from--\to};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/auto",
      meta = "⟨direction⟩"
    },
    ["background grid"] = {
      details = [[
This style dictates how the background grid path is drawn.

    \begin{tikzpicture}
      [background grid/.style={thick,draw=red,step=.5cm},
       show background grid]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/background:grid"
    },
    ["background rectangle"] = {
      details = [[
This style dictates how the background rectangle is drawn or filled. The
default setting causes the path of the background rectangle to be drawn
in the usual way. Setting this style to, say, `fill=blue!20` causes a
light blue background to be added to the picture. You can also use more
fancy settings as shown in the following example:

    \begin{tikzpicture}
      [background rectangle/.style=
         {double,ultra thick,draw=red,top color=blue,rounded corners},
       show background rectangle]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}

Naturally, no one in their right mind would use the above, but here is a
nice background:

    \begin{tikzpicture}
      [background rectangle/.style=
         {draw=blue!50,fill=blue!20,rounded corners=1ex},
       show background rectangle]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/background:rectangle"
    },
    ["background top"] = {
      details = [[
    \tikzset{background rectangle/.style={fill=blue!20},
             background top/.style={draw=blue!50,line width=1ex}}
    \begin{tikzpicture}[framed,show background top]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/background:top"
    },
    ["badness warnings for centered text"] = {
      details = [[
If set to true, normal badness warnings will be issued for centered
boxes. Note that you may get annoying warnings for perfectly normal
boxes, namely whenever the box is very large and the contents is not
long enough to fill the box sufficiently.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/badness:warnings:for:centered:text",
      meta = "⟨true or false⟩"
    },
    ["ball color"] = {
      details = [[
This option sets the color used for the ball shading. It sets the
`shade` and `shading=ball` options. Note that the ball will never
"completely" have the color ⟨color⟩. At its "highlight" spot a certain
amount of white is mixed in, at the border a certain amount of black.
Because of this, it also makes sense to say `ball color=white` or
`ball color=black`

    \begin{tikzpicture}
      \shade[ball color=white] (0,0) circle (2ex);
      \shade[ball color=red] (1,0) circle (2ex);
      \shade[ball color=black] (2,0) circle (2ex);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ball:color",
      meta = "⟨color⟩"
    },
    ["base left"] = {
      details = [[
This key works like the `left` key, only instead of the `east` anchor,
the `base east` anchor is used and, when the second form of an ⟨of-part⟩
is used, the corresponding `base west` anchor.

This key is useful for chaining together nodes so that their base lines
are aligned.

    \begin{tikzpicture}[node distance=1ex]
      \draw[help lines] (0,0) grid (3,1);
      \huge
      \node (X) at (0,1)     {X};
      \node (a) [right=of X] {a};
      \node (y) [right=of a] {y};

      \node (X) at (0,0)          {X};
      \node (a) [base right=of X] {a};
      \node (y) [base right=of a] {y};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/base:left",
      meta = "⟨specification⟩"
    },
    ["base right"] = {
      details = [[
Works like `base left`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/base:right",
      meta = "⟨specification⟩"
    },
    baseline = {
      details = [[
Normally, the lower end of the picture is put on the baseline of the
surrounding text. For example, when you give the code
`\tikz\draw(0,0)circle(.5ex);`, PGF will find out that the lower end of
the picture is at $-.5\mathrm{ex} - 0.2\mathrm{pt}$ (the 0.2pt are half
the line width, which is 0.4pt) and that the upper end is at
$.5\mathrm{ex}+.5\mathrm{pt}$. Then, the lower end will be put on the
baseline, resulting in the following: \[PICTURE\].

Using this option, you can specify that the picture should be raised or
lowered such that the height ⟨dimension⟩ is on the baseline. For
example, `\tikz[baseline=0pt]\draw(0,0)circle(.5ex);` yields \[PICTURE\]
since, now, the baseline is on the height of the $x$-axis.

This options is often useful for "inlined" graphics as in

    $A \mathbin{\tikz[baseline] \draw[->>] (0pt,.5ex) -- (3ex,.5ex);} B$

Instead of a ⟨dimension⟩ you can also provide a coordinate in
parentheses. Then the effect is to put the baseline on the
$y$-coordinate that the given ⟨coordinate⟩ has *at the end of the
picture*. This means that, at the end of the picture, the ⟨coordinate⟩
is evaluated and then the baseline is set to the $y$-coordinate of the
resulting point. This makes it easy to reference the $y$-coordinate of,
say, the baseline of nodes.

    Hello
    \tikz[baseline=(X.base)]
      \node [cross out,draw] (X) {world.};

    Top align:
    \tikz[baseline=(current bounding box.north)]
      \draw (0,0) rectangle (1cm,1ex);

Use `baseline=default` to reset the `baseline` option to its initial
configuration.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/baseline",
      meta = "⟨dimension or coordinate or default⟩"
    },
    ["behind path"] = {
      details = [[
When this key is set, either as a local option for the node or some
surrounding scope, the node will be drawn behind the current path. For
this, TikZ collects all nodes defined on the current path with this
option set and then inserts all of them, in the order they appear, just
before it draws the path. Thus, several nodes with this option set may
obscure one another, but never the path itself. "Just before it draws
the path" actually means that the nodes are inserted into the page
output just before any pre-actions are applied to the path (see below
for what pre-actions are).

    \tikz \fill [fill=blue!50, draw=blue, very thick]
          (0,0)   node [behind path, fill=red!50]   {first node}
       -- (1.5,0) node [behind path, fill=green!50] {second node}
       -- (1.5,1) node [behind path, fill=brown!50] {third node}
       -- (0,1)   node [             fill=blue!30]  {fourth node};

Note that `behind path` only applies to the current path; not to the
current scope or picture. To put a node "behind everything" you need to
use layers and options like `on background layer`, see the `backgrounds`
library in Section ??.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/behind:path"
    },
    below = {
      details = [[
This key is redefined in the same manner as `above`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/below",
      meta = "⟨specification⟩"
    },
    ["below delimiter"] = {
      details = [[
Works as above.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/below:delimiter",
      meta = "⟨delimiter⟩"
    },
    ["below left"] = {
      details = [[
Similar to `above left`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/below:left"
    },
    ["below left of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/below:left:of",
      meta = "⟨node⟩"
    },
    ["below of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/below:of",
      meta = "⟨node⟩"
    },
    ["below right"] = {
      details = [[
Similar to `above left`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/below:right"
    },
    ["below right of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/below:right:of",
      meta = "⟨node⟩"
    },
    bend = {
      details = [[
Has the same effect as saying `bend`⟨coordinate⟩ outside the ⟨options⟩.
The option specifies that the bend of the parabola should be at the
given ⟨coordinate⟩. You have to take care yourself that the bend
position is a "valid" position; which means that if there is no parabola
of the form $f(x) = a x^2 + b x + c$ that goes through the old current
point, the given bend, and the new current point, the result will not be
a parabola.

There is one special property of the ⟨coordinate⟩: When a relative
coordinate is given like `+(0,0)`, the position relative to this
coordinate is "flexible". More precisely, this position lies somewhere
on a line from the old current point to the new current point. The exact
position depends on the next option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/bend",
      meta = "⟨coordinate⟩"
    },
    ["bend angle"] = {
      details = [[
Sets the angle to be used by the `bend left` or `bend right`, but
without actually selecting the `curve to` or the `relative` option. This
is useful for globally specifying a `bend angle` for a whole picture.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/bend:angle",
      meta = "⟨angle⟩"
    },
    ["bend at end"] = {
      details = [[
This places the bend at the end of a parabola.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/bend:at:end"
    },
    ["bend at start"] = {
      details = [[
This places the bend at the start of a parabola. It is a shortcut for
the following options: `bend pos=0,bend={+(0,0)}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/bend:at:start"
    },
    ["bend left"] = {
      details = [[
This option sets `out=`⟨angle⟩`,in=`$180-⟨angle⟩$`,relative`. If no
⟨angle⟩ is given, the last given `bend left` or `bend right` angle is
used.

    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid]
      \node[state,initial]  (q_0)                {$q_0$};
      \node[state]          (q_1) [right=of q_0] {$q_1$};
      \node[state,accepting](q_2) [right=of q_1] {$q_2$};

      \path[->] (q_0) edge              node [above]  {0} (q_1)
                      edge [loop above] node          {1} ()
                      edge [bend left]  node [above]  {1} (q_2)
                      edge [bend right] node [below]  {0} (q_2)
                (q_1) edge              node [above]  {1} (q_2);
    \end{tikzpicture}

    \begin{tikzpicture}
      \foreach \angle in {0,45,...,315}
        \node[rectangle,draw=black!50] (\angle) at (\angle:2) {\angle};

      \foreach \from/\to in {0/45,45/90,90/135,135/180,
                             180/225,225/270,270/315,315/0}
        \path (\from) edge [->,bend right=22,looseness=0.8] (\to)
                      edge [<-,bend left=22,looseness=0.8] (\to);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/bend:left",
      meta = "⟨angle⟩"
    },
    ["bend pos"] = {
      details = [[
Specifies where the "previous" point is relative to which the bend is
calculated. The previous point will be at the ⟨fraction⟩th part of the
line from the old current point to the new current point.

The idea is the following: If you say `bend pos=0` and `bend +(0,0)`,
the bend will be at the old current point. If you say `bend pos=1` and
`bend +(0,0)`, the bend will be at the new current point. If you say
`bend pos=0.5` and `bend +(0,2cm)` the bend will be 2cm above the middle
of the line between the start and end point. This is most useful in
situations such as the following:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw (-1,0) parabola[bend pos=0.5] bend +(0,2) +(3,0);
    \end{tikzpicture}

In the above example, the `bend +(0,2)` essentially means "a parabola
that is 2cm high" and `+(3,0)` means "and 3cm wide". Since this
situation arises often, there is a special shortcut option:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/bend:pos",
      meta = "⟨fraction⟩"
    },
    ["bend right"] = {
      details = [[
Works like the `bend left` option, only the bend is to the other side.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/bend:right",
      meta = "⟨angle⟩"
    },
    ["blend group"] = {
      details = [[
This key can only be used with a scope (like `transparency group`). It
will cause the current scope to become a transparency group and, inside
this group, the blend mode will be set to ⟨mode⟩.

    \tikz [blend group=screen] {
      \fill[red!90!black]   ( 90:.6) circle (1);
      \fill[green!80!black] (210:.6) circle (1);
      \fill[blue!90!black]  (330:.6) circle (1);
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/blend:group",
      meta = "⟨mode⟩"
    },
    ["blend mode"] = {
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/blend:mode",
      meta = "⟨mode⟩"
    },
    ["bottom color"] = {
      details = [[
This option works like `top color`, only for the bottom color.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/bottom:color",
      meta = "⟨color⟩"
    },
    ["callout absolute pointer"] = {
      details = [[
The TikZ version of the `callout absolute pointer` key. Here,
⟨coordinate⟩ can be specified using the TikZ format for coordinates.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/callout:absolute:pointer",
      meta = "⟨coordinate⟩"
    },
    ["callout relative pointer"] = {
      details = [[
The TikZ version of the `callout relative pointer` key. Here,
⟨coordinate⟩ can be specified using the TikZ format for coordinates.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/callout:relative:pointer",
      meta = "⟨coordinate⟩"
    },
    ["canvas is plane"] = {
      details = [[
Perform the transformation into the new canvas plane using the units
above. Note that you have to set the units *before* calling
`canvas is plane`.

    \begin{tikzpicture}[
        ->,
        plane x={(0.707,-0.707)},
        plane y={(0.707,0.707)},
        canvas is plane,
    ]
        \draw (0,0) -- (1,0);
        \draw (0,0) -- (0,1);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:plane"
    },
    ["canvas is xy plane at z"] = {
      details = [[
A plane with

-   `plane origin={(0,0,`⟨dimension⟩`)}`,

-   `plane x={(1,0,`⟨dimension⟩`)}`, and

-   `plane y={(0,1,`⟨dimension⟩`)}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:xy:plane:at:z",
      meta = "⟨dimension⟩"
    },
    ["canvas is xz plane at y"] = {
      details = [[
A plane with

-   `plane origin={(0,`⟨dimension⟩`,0)}`,

-   `plane x={(1,`⟨dimension⟩`,0)}`, and

-   `plane y={(0,`⟨dimension⟩`,1)}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:xz:plane:at:y",
      meta = "⟨dimension⟩"
    },
    ["canvas is yx plane at z"] = {
      details = [[
A plane with

-   `plane origin={(0,0,`⟨dimension⟩`)}`,

-   `plane x={(0,1,`⟨dimension⟩`)}`, and

-   `plane y={(1,0,`⟨dimension⟩`)}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:yx:plane:at:z",
      meta = "⟨dimension⟩"
    },
    ["canvas is yz plane at x"] = {
      details = [[
A plane with

-   `plane origin={(`⟨dimension⟩`,0,0)}`,

-   `plane x={(`⟨dimension⟩`,1,0)}`, and

-   `plane y={(`⟨dimension⟩`,0,1)}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:yz:plane:at:x",
      meta = "⟨dimension⟩"
    },
    ["canvas is zx plane at y"] = {
      details = [[
A plane with

-   `plane origin={(0,`⟨dimension⟩`,0)}`,

-   `plane x={(0,`⟨dimension⟩`,1)}`, and

-   `plane y={(1,`⟨dimension⟩`,0)}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:zx:plane:at:y",
      meta = "⟨dimension⟩"
    },
    ["canvas is zy plane at x"] = {
      details = [[
A plane with

-   `plane origin={(`⟨dimension⟩`,0,0)}`,

-   `plane x={(`⟨dimension⟩`,0,1)}`, and

-   `plane y={(`⟨dimension⟩`,1,0)}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:zy:plane:at:x",
      meta = "⟨dimension⟩"
    },
    cells = {
      details = [[
This key adds the ⟨options⟩ to the style `every cell`. It is mainly just
a shorthand for the code `every cell/.append style=`⟨options⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cells",
      meta = "⟨options⟩"
    },
    centered = {
      details = [[
A shorthand for `anchor=center`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/centered"
    },
    ["chain default direction"] = {
      details = [[
This ⟨direction⟩ is used in a `chain` option, if no other ⟨direction⟩ is
specified.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/chain:default:direction",
      meta = "⟨direction⟩"
    },
    ["child anchor"] = {
      details = [[
Specifies the anchor where the edge from parent meets the child node by
setting the macro `\tikzchildanchor` to `.`⟨anchor⟩.

If you specify `border` as the ⟨anchor⟩, then the macro
`\tikzchildanchor` is set to the empty string. The effect of this is
that the edge from the parent will meet the child on the border at an
automatically calculated position.

    \begin{tikzpicture}
      \node {root}
        [child anchor=north]
        child {node {left} edge from parent[dashed]}
        child {node {right}
          child {node {child}}
          child {node {child} edge from parent[draw=none]}
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/child:anchor",
      meta = "⟨anchor⟩"
    },
    ["children are tokens"] = {
      details = [[
The idea behind this style is to use trees mechanism for placing tokens.
Every token lying on a place is treated as a child of the node. Normally
this would have the effect that the tokens are placed below the place
and they would be connected to the place by an edge. The
`children are tokens` style, however, redefines the growth function of
trees such that it places the children next to each other inside (or,
rather, on top) of the place node. Additionally, the edge from the
parent node is not drawn.

    \begin{tikzpicture}
      \node[place,label=above:$p_1$] {}
      [children are tokens]
      child {node [token] {1}}
      child {node [token] {2}}
      child {node [token] {3}};
    \end{tikzpicture}

In detail, what happens is the following: Tree growth functions tell
TikZ where it should place the children of nodes. These functions get
passed the number of children that a node has an the number of the child
that should be placed. The special tree growth function for tokens has a
special mapping for each possible number of children up to nine
children. This mapping decides for each child where it should be placed
on top of the place. For example, a single child is placed directly on
top of the place. Two children are placed next to each other, separated
by the `token distance`. Three children are placed in a triangle whose
side lengths are `token distance`; and so on up to nine tokens. If you
wish to place more than nice tokens on a place, you will have to write
your own placement code.

    \begin{tikzpicture}
      \node[place,label=above:$p_2$] {}
      [children are tokens]
      child {node [token] {1}}
      child {node [token,fill=red] {2}}
      child {node [token,fill=red] {2}}
      child {node [token] {1}};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/children:are:tokens"
    },
    ["circle connection bar"] = {
      details = [[
This style installs a rather involved to-path. Unlike normal to-paths,
this path requires that the start and the target of the to-path are
named nodes of shape `circle` -- if this is not the case, this path will
produce errors.

Assuming that the start and the target are circles, the to-path will
first compute the radii of these circles (by measuring the distance from
the `center` anchor to some anchor on the border) and will set the
`start circle` keys accordingly. Next, the `fill` option is set to the
`concept color` while `draw=none` is set. The decoration is set to
`circle connection bar`. Finally, the following style is included:

    \begin{tikzpicture}[concept color=blue!50,blue!50,outer sep=0pt]
      \node (n1) at (0,0)   [circle,minimum size=2cm,fill,draw,thick] {};
      \node (n2) at (2.5,0) [circle,minimum size=1cm,fill,draw,thick] {};

      \path (n1) to[circle connection bar] (n2);
    \end{tikzpicture}

Note that it is not a good idea to have more than one `to` operation
together with the option `circle connection bar` in a single `\path`.
Use the `edge` operation, instead, for creating multiple connections and
this operation creates a new scope for each edge.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circle:connection:bar"
    },
    ["circle connection bar switch color"] = {
      details = [[
This style works similarly to the `circle connection bar`. The only
difference is that instead of filling the path with a single color a
shading is used.

    \begin{tikzpicture}[outer sep=0pt]
      \node (n1) at (0,0)    [circle,minimum size=2cm,fill,draw,thick,red] {};
      \node (n2) at (30:2.5) [circle,minimum size=1cm,fill,draw,thick,blue] {};

      \path (n1) to[circle connection bar switch color=from (red) to (blue)] (n2);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circle:connection:bar:switch:color",
      meta = "from (⟨first color⟩) to (⟨second color⟩)"
    },
    ["circle through"] = {
      details = [[
When this key is given as an option to a node, the following happens:

1.  The `inner sep` and the `outer sep` are set to zero.

2.  The shape is set to `circle`.

3.  The `minimum size` is set such that the circle around the center of
    the node (which is specified using `at`), goes through ⟨coordinate⟩.

&nbsp;

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \node (a) at (2,1.5) {$a$};
      \node [draw] at (1,1) [circle through={(a)}] {$c$};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circle:through",
      meta = "⟨coordinate⟩"
    },
    ["circuit declare annotation"] = {
      details = [[
This key is used to declare an annotation named ⟨name⟩. Once declared,
it can be used as an argument of a symbol and will add the drawing in
⟨path⟩ to the symbol. In detail, the following happens:

**The Main Keys.** Two keys called ⟨name⟩ and ⟨name⟩`’` are defined. The
second causes the annotation to be "mirrored and placed on the other
side" of the symbol. Both of these keys may also take further keys as
parameter like `info` keys. Whenever the ⟨name⟩ key is used, a local
scope is opened and in this scope the following things are done:

1.  The style `every` ⟨name⟩ is executed.

2.  The following style is executed and then `arrows=->`:

3.  The coordinate system is shifted such that the origin is at the
    north anchor of the symbol. (For the ⟨name⟩`’` key the coordinate
    system is flipped and shifted such that the origin is at the south
    anchor of the symbol.)

4.  The `label distance` is locally set to ⟨distance⟩.

5.  The parameter options given to the ⟨name⟩ key are executed.

6.  The ⟨path⟩ is executed.

**Usage.** What all of the above amounts to is best explained by an
example. Suppose we wish to create an annotation that looks like a
little circular arrow (like \[PICTURE\]). We could then say:

    \tikzset{circuit declare annotation=
      {circular annotation}
      {9pt}
      {(0pt,8pt) arc (-270:80:3.5pt)}
    }

We can then use it like this:

    \tikz[circuit ee IEC]
      \draw (0,0) to [resistor={circular annotation}]   (3,0);

Well, not very impressive since we do not see anything. This is due to
the fact that the ⟨path⟩ becomes part of a path that contains the symbol
node an nothing else. This path is not drawn or filled, so we do not see
anything. What we must do is to use an `edge` path operation:

    \tikzset{circuit declare annotation={circular annotation}{9pt}
      {(0pt,8pt) edge[to path={arc(-270:80:3.5pt)}] ()}
    }
    \tikz[circuit ee IEC]
      \draw (0,0) to [resistor={circular annotation}]   (3,0)
                  to [capacitor={circular annotation'}] (3,2);

The ⟨distance⟩ is important for the correct placement of additional
`info` labels. When an annotation is present, the info labels may need
to be moved further away from the symbol, but not always. For this
reason, an annotation defines an additional ⟨distance⟩ that is applied
to all info labels given as parameters to the annotation. Here is an
example, that shows the difference:

    \tikz[circuit ee IEC]
      \draw (0,0) to [resistor={circular annotation,ohm=5}]   (2,0)
                  to [resistor={circular annotation={ohm=5}}] (4,0);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:declare:annotation",
      meta = "{name}{distance}{path}"
    },
    ["circuit declare symbol"] = {
      details = [[
This key is used to declare a symbol. It does not cause this symbol to
be shown nor does it set a graphic to be used for the symbol, it simply
"prepares" several keys that can later be used to draw a symbol and to
configure it.

In detail, the first key that is defined is just called ⟨name⟩. This key
should be given as an option to a `node` or on a `to` path, as explained
below. The key will take options, which can be used to influence the way
the symbol graphic is rendered.

Let us have a look at an example. Suppose we want to define a symbol
called `foo`, which just looks like a simple rectangle. We could then
say

    \tikzset{circuit declare symbol=foo}

The symbol could now be used like this:

      \node [foo]       at (1,1) {};
      \node [foo={red}] at (2,1) {};

However, in the above example we would not actually see anything since
we have not yet set up the graphic to be used by `foo`. For this, we
must use a key called `set foo graphic` or, generally, `set` ⟨name⟩
`graphic`. This key gets graphic options as parameter that will be set
when a symbol `foo` should be shown:

    \begin{tikzpicture}
      [circuit declare symbol=foo,
       set foo graphic={draw,shape=rectangle,minimum size=5mm}]

      \node [foo]       at (1,1) {};
      \node [foo={red}] at (2,1) {};
    \end{tikzpicture}

In detail, when you use the key ⟨name⟩=⟨options⟩ with a node, the
following happens:

1.  The `inner sep` is set to `0.5pt`.

2.  The following style is executed:

3.  The graphic options that have been set using `set` ⟨name⟩ `graphic`
    are set.

4.  The style `every `⟨name⟩ is executed. You can use it to configure
    the symbol further.

5.  The ⟨options⟩ are executed.

The key ⟨name⟩ will have a different effect when it is used on a `to`
path command inside a `circuit` environment (the `circuit` environment
sets up `to` paths in such a way that the use of a key declared using
`circuit declare symbol` is automatically detected). When ⟨name⟩ is used
on a `to` path, the above actions also happen (setting the inner
separation, using the symbol graphic, and so on), but they are passed to
the key `circuit handle symbol`, which is explained next.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:declare:symbol",
      meta = "⟨name⟩"
    },
    ["circuit declare unit"] = {
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:declare:unit",
      meta = "{name}{unit}"
    },
    ["circuit ee"] = {
      details = [[
This style calls the keys `circuit` (which internally calls
`every circuit` and the following style:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:ee"
    },
    ["circuit ee IEC"] = {
      details = [[
This style calls `circuit ee` and installs the IEC-like graphics for the
logical symbols like `resistor`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:ee:IEC"
    },
    ["circuit handle symbol"] = {
      details = [[
This key is mostly used internally. Its purpose is to render a symbol.
The effect of this key differs, depending on whether it is used as the
optional argument of a `to` path command or elsewhere.

If the key is not used as an argument of a `to` path command, the
⟨options⟩ are simply executed.

The more interesting case happens when the key is given on a `to` path
command. In this case, several things happen:

1.  The `to` path is locally changed and set to an internal path (which
    you should not try to change) that consists mostly of a single
    straight line.

2.  The ⟨options⟩ are tentatively executed with filtering switched on.
    Everything is filtered out, except for the key `pos` and also the
    styles `at start`, `very near start`, `near start`, `midway`,
    `near end`, `very near end`, and `at end`. If none of them is found,
    `midway` is used.

3.  The filtered option is used to determine a position for the symbol
    on the path. At the given position (with `pos=0` representing the
    start and `pos=1` representing the end), a node will be added to the
    path (in a manner to be described presently).

4.  This node gets ⟨options⟩ as its option list.

5.  The node is added by virtue of a special `markings` decoration. This
    means that a `mark` command is executed that causes the node to be
    placed as a mark on the path.

6.  The marking decoration will automatically subdivide the path and
    cause a line to be drawn from the start of the path to the node's
    border (at the position that lies on a line from the node's center
    to the start of the path) and then from the node's border (at a
    position on the other side of the node) to the end of the path.

7.  The marking decoration will also take care of the case that multiple
    marks are present on a path, in this case the lines from and to the
    borders of the nodes are only between consecutive nodes.

8.  The marking decoration will also rotate the coordinate system in
    such a way that the $x$-axis points along the path. Thus, if you use
    the `transform shape` option, the node will "point along" the path.

9.  In case a node is at `pos=0` or at `pos=1` some special code will
    suppress the superfluous lines to the start or end of the path.

The net effect of all of the above is that a node will be placed "on the
path" and the path will have a "gap" just large enough to encompass the
node. Another effect is that you can use this key multiple times on a
path to add several node to a path, provided they do not overlap.

    \begin{tikzpicture}[circuit]
      \draw (0,0) to [circuit handle symbol={draw,shape=rectangle,near start},
                      circuit handle symbol={draw,shape=circle,near end}] (3,2);
      \end{tikzpicture}

    \begin{tikzpicture}[transform shape,circuit]
      \draw (0,0) to [circuit handle symbol={draw,shape=rectangle,at start},
                      circuit handle symbol={draw,shape=circle,near end}] (3,2);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:handle:symbol",
      meta = "⟨options⟩"
    },
    ["circuit logic"] = {
      details = [[
This style calls the keys `circuit` (which internally calls
`every circuit`, then it defines the `inputs` key and it calls the
`every circuit logic` key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:logic"
    },
    ["circuit logic CDH"] = {
      details = [[
This key calls `circuit logic US` and installs the two special and- and
nand-gates, that is, it uses `set and gate graphic` with
`and gate CDH graphic` and likewise for nand-gates.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:logic:CDH"
    },
    ["circuit logic IEC"] = {
      details = [[
This key calls `circuit logic` and installs the IEC-like graphics for
the logical symbols like `and gate`.

As explained in Section ??, for each graphic symbol of the library there
is also a style that stores this particular appearance. These keys are
called `and gate IEC graphic`, `or gate IEC graphic`, and so on.

    \begin{tikzpicture}[circuit logic IEC,
                        every circuit symbol/.style={
                          logic gate IEC symbol color=black,
                          fill=blue!20,draw=blue,very thick}]
      \matrix[column sep=7mm]
      {
        \node (i0) {0}; &                            & \\
                        & \node [and gate] (a1) {};  & \\
        \node (i1) {0}; &                            & \node [or gate] (o) {};\\
                        & \node [nand gate] (a2) {}; & \\
        \node (i2) {1}; &                            & \\
      };
      \draw (i0.east) -- ++(right:3mm) |- (a1.input 1);
      \draw (i1.east) -- ++(right:3mm) |- (a1.input 2);
      \draw (i1.east) -- ++(right:3mm) |- (a2.input 1);
      \draw (i2.east) -- ++(right:3mm) |- (a2.input 2);
      \draw (a1.output) -- ++(right:3mm) |- (o.input 1);
      \draw (a2.output) -- ++(right:3mm) |- (o.input 2);
      \draw (o.output) -- ++(right:3mm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:logic:IEC"
    },
    ["circuit logic US"] = {
      details = [[
This style calls `circuit logic` and installs US-like graphics for the
logical symbols like `and gate`. For instance, it says

    set and gate graphic = and gate US graphic

Here is an example:

    \begin{tikzpicture}[circuit logic CDH,
                        tiny circuit symbols,
                        every circuit symbol/.style={
                          fill=white,draw}]
      \matrix[column sep=7mm]
      {
        \node (i0) {0}; &                            & \\
                        & \node [and gate] (a1) {};  & \\
        \node (i1) {0}; &                            & \node [or gate] (o) {};\\
                        & \node [nand gate] (a2) {}; & \\
        \node (i2) {1}; &                            & \\
      };
      \draw (i0.east) -- ++(right:3mm) |- (a1.input 1);
      \draw (i1.east) -- ++(right:3mm) |- (a1.input 2);
      \draw (i1.east) -- ++(right:3mm) |- (a2.input 1);
      \draw (i2.east) -- ++(right:3mm) |- (a2.input 2);
      \draw (a1.output) -- ++(right:3mm) |- (o.input 1);
      \draw (a2.output) -- ++(right:3mm) |- (o.input 2);
      \draw (o.output) -- ++(right:3mm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:logic:US"
    },
    ["circuit symbol filled"] = {
      details = [[
This style is used with symbols that are completely filled. For
instance, the variant IEC version of an inductor is a filled, black
rectangle.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:filled"
    },
    ["circuit symbol lines"] = {
      details = [[
This style is used with symbols that consist only of lines that do not
surround anything. Examples are a capacitor.

    \tikz [circuit ee IEC,
           circuit symbol lines/.style={thick,draw=red}]
      \draw (0,0) to [capacitor] ++(right:3) to [resistor] ++(up:2);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:lines"
    },
    ["circuit symbol open"] = {
      details = [[
This style is used with symbols that consist of lines that surround some
area. For instance, the IEC version of a resistor is an open symbol.

    \tikz [circuit ee IEC,
           circuit symbol open/.style={thick,draw,fill=yellow}]
      \draw (0,0) to [inductor] ++(right:3) to [resistor] ++(up:2);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:open"
    },
    ["circuit symbol size"] = {
      details = [[
This key sets `minimum height` to ⟨height⟩ times the current value of
the circuit symbol unit and the `minimum width` to ⟨width⟩ times this
value. Thus, this option can be used with a node command to set the size
of the node as a multiple of the circuit symbol unit.

    \begin{tikzpicture}[circuit ee IEC]
      \draw (0,1) to [resistor] (2,1) to[inductor] (4,1);

      \begin{scope}
        [every resistor/.style={circuit symbol size=width 3 height 1}]
        \draw (0,0) to [resistor] (2,0) to[inductor] (4,0);
      \end{scope}
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:size",
      meta = "width ⟨width⟩ height ⟨height⟩"
    },
    ["circuit symbol unit"] = {
      details = [[
This dimension is a "unit" for the size of symbols. The libraries
generally define the sizes of symbols relative to this dimension. For
instance, the longer side of an inductor is, by default, in the IEC
library equal to five times this ⟨dimension⟩. When you change this
⟨dimension⟩, the size of all symbols will automatically change
accordingly.

Note, that it is still possible to overwrite the size of any particular
symbol. These settings apply only to the default sizes.

    \begin{tikzpicture}[circuit ee IEC]
      \draw (0,1) to [resistor] (3.5,1);
      \draw[circuit symbol unit=14pt]
            (0,0) to [resistor] (3.5,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:unit",
      meta = "⟨dimension⟩"
    },
    ["circuit symbol wires"] = {
      details = [[
This style is used for symbols that consist only of "wires". The
difference to the previous style is that a symbol consisting of wires
will look strange when the lines are thicker than the lines of normal
wires, while for symbols consisting of lines (but not wires) it may look
nice to make them thicker. An example is the `make contact` symbol.

Compare

    \tikz [circuit ee IEC,circuit symbol lines/.style={draw,very thick}]
      \draw (0,0) to [capacitor={near start},
                      make contact={near end}] (3,0);

to

    \tikz [circuit ee IEC,circuit symbol wires/.style={draw,very thick}]
      \draw (0,0) to [capacitor={near start},
                      make contact={near end}] (3,0);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:wires"
    },
    circuits = {
      details = [[
This key should be passed as an option to a picture or a scope that
contains a circuit. It will do some internal setups. This key is
normally called by more specialized keys like `circuit ee IEC`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circuits"
    },
    ["circular drop shadow"] = {
      details = [[
This shadow works like a drop shadow, only it adds a circular fading to
the shadow. This means that the shadow will fade out at the border. The
following options are preset for this shadow:

      shadow scale=1.1, shadow xshift=.3ex, shadow yshift=-.3ex,
      fill=black, path fading={circle with fuzzy edge 15 percent},
      every shadow,

    \begin{tikzpicture}
      \foreach \i in {1,...,8}
        \node[circle,circular drop shadow,draw=blue,fill=blue!20,thick]
          at (\i*45:1) {Circle \i};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circular:drop:shadow",
      meta = "⟨shadow options⟩"
    },
    ["circular glow"] = {
      details = [[
This shadow works much like the `circular shadow`, only it is not
shifted. This creates a visual effect of a "glow" behind the circle. The
following options are preset for this shadow:

      shadow scale=1.25, shadow xshift=0pt, shadow yshift=0pt,
      fill=black, path fading={circle with fuzzy edge 15 percent},
      every shadow,

    \begin{tikzpicture}
      \foreach \i in {1,...,8}
      \node[circle,circular glow,fill=red!20,draw=red,thick]
        at (\i*45:1) {Circle \i};
    \end{tikzpicture}

    \begin{tikzpicture}
      \foreach \i in {1,...,8}
      \node[circle,circular glow={fill=white},fill=red!20,draw=red,thick]
        at (\i*45:1) {Circle \i};
    \end{tikzpicture}

    \begin{tikzpicture}
      \foreach \i in {1,...,8}
      \node[circle,circular glow={fill=green},fill=black,text=green!50!black]
        at (\i*45:1) {Circle \i};
    \end{tikzpicture}

An especially interesting effect can be achieved by only using the glow
and not filling the path:

    \begin{tikzpicture}
      \foreach \i in {1,...,8}
      \node[circle,circular glow={fill=red!\i0}]
        at (\i*45:1) {Circle \i};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/circular:glow",
      meta = "⟨shadow options⟩"
    },
    clip = {
      details = [[
This option causes all subsequent drawings to be clipped against the
current path and the size of subsequent paths will not be important for
the picture size. If you clip against a self-intersecting path, the
even-odd rule or the nonzero winding number rule is used to determine
whether a point is inside or outside the clipping region.

The clipping path is a graphic state parameter, so it will be reset at
the end of the current scope. Multiple clippings accumulate, that is,
clipping is always done against the intersection of all clipping areas
that have been specified inside the current scopes. The only way of
enlarging the clipping area is to end a `{scope}`.

    \begin{tikzpicture}
      \draw[clip] (0,0) circle (1cm);
      \fill[red] (1,0) circle (1cm);
    \end{tikzpicture}

It is usually a *very* good idea to apply the `clip` option only to the
first path command in a scope.

If you "only wish to clip" and do not wish to draw anything, you can use
the `\clip` command, which is a shorthand for `\path[clip]`.

    \begin{tikzpicture}
      \clip (0,0) circle (1cm);
      \fill[red] (1,0) circle (1cm);
    \end{tikzpicture}

To keep clipping local, use `{scope}` environments as in the following
example:

    \begin{tikzpicture}
      \draw (0,0) -- ( 0:1cm);
      \draw (0,0) -- (10:1cm);
      \draw (0,0) -- (20:1cm);
      \draw (0,0) -- (30:1cm);
      \begin{scope}[fill=red]
        \fill[clip] (0.2,0.2) rectangle (0.5,0.5);

        \draw (0,0) -- (40:1cm);
        \draw (0,0) -- (50:1cm);
        \draw (0,0) -- (60:1cm);
      \end{scope}
      \draw (0,0) -- (70:1cm);
      \draw (0,0) -- (80:1cm);
      \draw (0,0) -- (90:1cm);
    \end{tikzpicture}

There is a slightly annoying catch: You cannot specify certain graphic
options for the command used for clipping. For example, in the above
code we could not have moved the `fill=red` to the `\fill` command. The
reasons for this have to do with the internals of the PDF specification.
You do not want to know the details. It is best simply not to specify
any options for these commands.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/clip"
    },
    ["clockwise from"] = {
      details = [[
This option also causes children to be arranged on a circle. However,
the rule for placing children is simpler than with the `grow cyclic`
style: The first child is placed at ⟨angle⟩ at a distance of
`\tikzleveldistance`. The second child is placed at the same distance
from the parent, but at angle ⟨angle⟩${}-{}$`\tikzsiblingangle`. The
third child is displaced by another `\tikzsiblingangle` in a clockwise
fashion, and so on.

Note that this function will not rotate the coordinate system.

    \begin{tikzpicture}
      \node {root}
      [clockwise from=30,sibling angle=30]
      child {node {$30$}}
      child {node {$0$}}
      child {node {$-30$}}
      child {node {$-60$}};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/clockwise:from",
      meta = "⟨angle⟩"
    },
    cm = {
      details = [[
applies the following transformation to all coordinates: Let $(x,y)$ be
the coordinate to be transformed and let ⟨coordinate⟩ specify the point
$(t_x,t_y)$. Then the new coordinate is given by
$\left(\begin{smallmatrix} a & c \\ b & d\end{smallmatrix}\right)
    \left(\begin{smallmatrix} x \\ y \end{smallmatrix}\right) +
    \left(\begin{smallmatrix} t_x \\ t_y \end{smallmatrix}\right)$.
Usually, you do not use this option directly.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                             (0,0) -- (1,1) -- (1,0);
      \draw[cm={1,1,0,1,(0,0)},blue]    (0,0) -- (1,1) -- (1,0);
      \draw[cm={0,1,1,0,(1cm,1cm)},red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cm",
      meta = "{⟨$a$⟩,⟨$b$⟩,⟨$c$⟩,⟨$d$⟩,⟨coordinate⟩}"
    },
    color = {
      details = [[
This option sets the color that is used for fill, drawing, and text
inside the current scope. Any special settings for filling colors or
drawing colors are immediately "overruled" by this option.

The ⟨color name⟩ is the name of a previously defined color. For
LaTeX users, this is just a normal "LaTeX-color" and the `xcolor`
extensions are allowed. Here is an example:

    \tikz \fill[color=red!20] (0,0) circle (1ex);

It is possible to "leave out" the `color=` part and you can also write:

    \tikz \fill[red!20] (0,0) circle (1ex);

What happens is that every option that TikZ does not know, like
`red!20`, gets a "second chance" as a color name.

For plain TeX users, it is not so easy to specify colors since plain
TeX has no "standardized" color naming mechanism. Because of this,
PGF emulates the `xcolor` package, though the emulation is *extremely
basic* (more precisely, what I could hack together in two hours or so).
The emulation allows you to do the following:

-   Specify a new color using `\definecolor`. Only the color models
    `gray`, `rgb`, and `RGB` are supported[1].
    `\definecolor{orange}{rgb}{1,0.5,0}`

-   Use `\colorlet` to define a new color based on an old one. Here, the
    `!` mechanism is supported, though only "once" (use multiple
    `\colorlet` for more fancy colors). `\colorlet{lightgray}{black!25}`

-   Use `\color``{color name}` to set the color in the current
    TeX group. `\aftergroup`-hackery is used to restore the color after
    the group.

[1] ConTeXt users should be aware that `\definecolor` has a different
meaning in ConTeXt. There is a low-level equivalent named
`\pgfutil@definecolor` which can be used instead.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/color",
      meta = "⟨color name⟩"
    },
    ["colored tokens"] = {
      details = [[
This option, which must also be given when a place node is being
created, gets a list of colors as parameter. It will then add as many
tokens to the place as there are colors in this list, each filled
correspondingly.

    \tikz  \node[place,colored tokens={black,black,red,blue}] {};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/colored:tokens",
      meta = "⟨color list⟩"
    },
    ["column sep"] = {
      details = [[
This option sets a default space that is added between every two
columns. This space can be positive or negative and is zero by default.
The ⟨spacing list⟩ normally contains a single dimension like `2pt`.

    \begin{tikzpicture}
      \matrix [draw,column sep=1cm,nodes=draw]
      {
        \node(a) {123}; & \node (b) {1};   & \node {1}; \\
        \node    {12};  & \node     {12};  & \node {1}; \\
        \node(c) {1};   & \node (d) {123}; & \node {1}; \\
      };
      \draw [red,thick]  (a.east) -- (a.east |- c)
                         (d.west) -- (d.west |- b);
      \draw [<->,red,thick] (a.east) -- (d.west |- b)
        node [above,midway] {1cm};
    \end{tikzpicture}

More generally, the ⟨spacing list⟩ may contain a whole list of numbers,
separated by commas, and occurrences of the two key words
`between origins` and `between borders`. The effect of specifying such a
list is the following: First, all numbers occurring in the list are
simply added to compute the final spacing. Second, concerning the two
keywords, the last occurrence of one of the keywords is important. If
the last occurrence is `between borders` or if neither occurs, then the
space is inserted between the two columns normally. However, if the last
occurs is `between origins`, then the following happens: The distance
between the columns is adjusted such that the difference between the
origins of all the cells in the first column (remember that they all lie
on straight line) and the origins of all the cells in the second column
is exactly the given distance.

*The* `between origins` *option can only be used for columns mentioned
in the first row, that is, you cannot specify this option for columns
introduced only in later rows.*

    \begin{tikzpicture}
      \matrix [draw,column sep={1cm,between origins},nodes=draw]
      {
        \node(a) {123}; & \node (b) {1};   & \node {1}; \\
        \node    {12};  & \node     {12};  & \node {1}; \\
        \node    {1};   & \node     {123}; & \node {1}; \\
      };
      \draw [<->,red,thick] (a.center) -- (b.center) node [above,midway] {1cm};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/column:sep",
      meta = "⟨spacing list⟩"
    },
    ["column ⟨number⟩"] = {
      details = [[
This style is used for every cell in column ⟨number⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/column:⟨number⟩"
    },
    concept = {
      details = [[
This style should be used with all nodes that are concepts, although
some styles like `extra concept` install this style automatically.

Basically, this style makes the concept node circular and installs a
uniform color called `concept color`, see below. Additionally, the style
`every concept` is called.

    \tikz[mindmap,concept color=red!50] \node [concept] {Some concept};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/concept"
    },
    ["concept color"] = {
      details = [[
We saw already that this option is used to change the color of concepts.
We now have a look at its effect when used on child nodes of a concept.
Normally, this option simply changes the color of the children. However,
when the option is given as an option to the `child` operation (and not
to the `node` operation and also not as an option to all children via
the `level 1` style), TikZ will smoothly change the concept color from
the parent's color to the color of the child concept.

Here is an example:

    \tikz[mindmap,concept color=blue!80]
      \node [concept] {Root concept}
        child[concept color=red,grow=30] {node[concept] {Child concept}}
        child[concept color=orange,grow=0]  {node[concept] {Child concept}};

In order to have a concept color which changes with the hierarchy level,
a tiny bit of magic is needed:

    \tikz[mindmap,text=white,
          root concept/.style={concept color=blue},
          level 1 concept/.append style=
            {every child/.style={concept color=blue!50}}]
      \node [concept] {Root concept}
        child[grow=30] {node[concept] {child}}
        child[grow=0 ] {node[concept] {child}};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/concept:color",
      meta = "⟨color⟩"
    },
    ["concept connection"] = {
      details = [[
This style can be used for lines between two concepts. Feel free to
redefine this style.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/concept:connection"
    },
    ["connect spies"] = {
      details = [[
Causes the spy-in and the spy-on nodes to be connected by a thin line.

    \begin{tikzpicture}
      [spy using overlays={circle, magnification=3, size=1cm}]

      \draw [decoration=Koch curve type 2]
        decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

      \spy [green] on (1.6,0.1) in node at (3,1);
      \spy [red,connect spies] on (0.5,0.4) in node at (1,1.5);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/connect:spies"
    },
    ["const plot"] = {
      details = [[
This option causes the points on the path to be connected using
piecewise constant series of lines:

    \tikz\draw plot[const plot] file{plots/pgfmanual-sine.table};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/const:plot"
    },
    ["const plot mark left"] = {
      details = [[
Just an alias for `/tikz/const plot`.

    \tikz\draw plot[const plot mark left,mark=*] file{plots/pgfmanual-sine.table};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/const:plot:mark:left"
    },
    ["const plot mark mid"] = {
      details = [[
A variant of `/tikz/const plot` which places its mark in the middle of
the horizontal lines:

    \tikz\draw plot[const plot mark mid,mark=*] file{plots/pgfmanual-sine.table};

More precisely, it generates vertical lines in the middle between each
pair of consecutive points. If the mesh width is constant, this leads to
symmetrically placed marks ("middle").
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/const:plot:mark:mid"
    },
    ["const plot mark right"] = {
      details = [[
A variant of `/tikz/const plot` which places its mark on the right ends:

    \tikz\draw plot[const plot mark right,mark=*] file{plots/pgfmanual-sine.table};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/const:plot:mark:right"
    },
    ["continue branch"] = {
      details = [[
This option works like the `continue chain` option, only ⟨current
chain⟩`/`⟨branch name⟩ is used as the chain name, rather than just
⟨branch name⟩.

    \begin{tikzpicture}[every on chain/.style=join,every join/.style=->,
                        node distance=2mm and 1cm]
      { [start chain=trunk]
        \node [on chain] {A};
        \node [on chain] {B};
        { [start branch=numbers going below] } % just a declaration,
        { [start branch=greek   going above] } % we will come back later
        \node [on chain] {C};

        % Now come the branches...
        { [continue branch=numbers]
          \node [on chain] {1};
          \node [on chain] {2};
        }
        { [continue branch=greek]
          \node [on chain] {$\alpha$};
          \node [on chain] {$\beta$};
        }
      }
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/continue:branch",
      meta = "⟨branch name⟩⟨direction⟩"
    },
    ["continue chain"] = {
      details = [[
This option allows you to (re)activate an existing chain and to possibly
change the default direction. If the `chain name` is missing, the name
of the innermost activated chain is used. If no chain is activated,
`chain` is used.

Let us have a look at the two different applications of this option. The
first is to change the direction of a chain as it is being constructed.
For this, just give this option somewhere inside the scope of the chain.

    \begin{tikzpicture}[start chain=going right,node distance=5mm]
      \node [draw,on chain] {Hello};
      \node [draw,on chain] {World};
      \node [draw,continue chain=going below,on chain] {,};
      \node [draw,on chain] {this};
      \node [draw,on chain] {is};
    \end{tikzpicture}

The second application is to reactivate a chain after it "has already
been closed down".

    \begin{tikzpicture}[node distance=5mm,
                        every node/.style=draw]
      { [start chain=1]
        \node [on chain] {A};
        \node [on chain] {B};
        \node [on chain] {C};
      }

      { [start chain=2 going below]
        \node [on chain=2] at (0.5,-.5) {0};
        \node [on chain=2] {1};
        \node [on chain=2] {2};
      }

      { [continue chain=1]
        \node [on chain] {D};
      }
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/continue:chain",
      meta = "⟨chain name⟩⟨direction⟩"
    },
    controls = {
      details = [[
This option causes the ⟨coordinate⟩s to be used as control points.

    \tikz \draw (0,0) to [controls=+(90:1) and +(90:1)] (3,0);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/controls",
      meta = "⟨coordinate⟩ and ⟨coordinate⟩"
    },
    ["copy shadow"] = {
      details = [[
This shadow installs the following default options:

      shadow scale=1, shadow xshift=.5ex, shadow yshift=-.5ex, every shadow

Furthermore, the options `fill=`⟨fill color⟩ and `draw=`⟨draw color⟩ are
also set, where the ⟨fill color⟩ and ⟨draw color⟩ are the fill and draw
colors used for the main path.

    \begin{tikzpicture}
      \node [copy shadow,fill=blue!20,draw=blue,thick] {Hello World!};

      \node at (0,-1) [copy shadow={shadow xshift=1ex,shadow yshift=1ex},
                       fill=blue!20,draw=blue,thick]
        {Hello World!};

      \node at (0,-2) [copy shadow={opacity=.5},tape,
                       fill=blue!20,draw=blue,thick]
        {Hello World!};

      % We have to repeat the left color since shadings are not
      % automatically applied to shadows
      \node at (0,-3) [copy shadow={left color=blue!50},
                       left color=blue!50,draw=blue,thick]
        {Hello World!};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/copy:shadow",
      meta = "⟨shadow options⟩"
    },
    ["counterclockwise from"] = {
      details = [[
Works the same way as `clockwise from`, but sibling angles are added
instead of subtracted.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/counterclockwise:from",
      meta = "⟨angle⟩"
    },
    ["cs/angle"] = {
      details = [[
Same as `longitude`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/angle",
      meta = "⟨degrees⟩"
    },
    ["cs/first line"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/first:line",
      meta = "{(⟨first % coordinate⟩)--(⟨second coordinate⟩)}"
    },
    ["cs/first node"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/first:node",
      meta = "⟨node⟩"
    },
    ["cs/horizontal line through"] = {
      details = [[
Specifies that one line is a horizontal line that goes through the given
coordinate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/horizontal:line:through",
      meta = "{(⟨coordinate⟩)}"
    },
    ["cs/latitude"] = {
      details = [[
Angle of the coordinate between the $y$- and $z$-vector, measured from
the $y$-vector.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/latitude",
      meta = "⟨degrees⟩"
    },
    ["cs/longitude"] = {
      details = [[
Angle of the coordinate between the $x$- and $y$-vector, measured from
the $y$-vector.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/longitude",
      meta = "⟨degrees⟩"
    },
    ["cs/name"] = {
      details = [[
Specifies the node that you wish to use to specify a coordinate. The
⟨node name⟩ is the name that was previously used to name the node using
the `name=`⟨node name⟩ option or the special node name syntax.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/name",
      meta = "⟨node name⟩"
    },
    ["cs/node"] = {
      details = [[
This key specifies the node on whose border the tangent should lie.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/node",
      meta = "⟨node⟩"
    },
    ["cs/point"] = {
      details = [[
This key specifies the point through which the tangent should go.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/point",
      meta = "⟨point⟩"
    },
    ["cs/radius"] = {
      details = [[
Factor by which the $x$-, $y$-, and $z$-vector are multiplied.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/radius",
      meta = "⟨number⟩"
    },
    ["cs/second line"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/second:line",
      meta = "{(⟨first % coordinate⟩)--(⟨second coordinate⟩)}"
    },
    ["cs/second node"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/second:node",
      meta = "⟨node⟩"
    },
    ["cs/solution"] = {
      details = [[
Specifies which solution should be used if there are more than one.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/solution",
      meta = "⟨number⟩"
    },
    ["cs/vertical line through"] = {
      details = [[
Specifies that the other line is vertical and goes through the given
coordinate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/vertical:line:through",
      meta = "{(⟨coordinate⟩)}"
    },
    ["cs/x"] = {
      details = [[
The $x$ component of the coordinate. Should be given *without* unit.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/x",
      meta = "⟨number⟩"
    },
    ["cs/x radius"] = {
      details = [[
A specific factor by which only the $x$-vector is multiplied.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/x:radius",
      meta = "⟨dimension⟩"
    },
    ["cs/y"] = {
      details = [[
Distance by which the coordinate is above the origin.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/y",
      meta = "⟨dimension⟩"
    },
    ["cs/y radius"] = {
      details = [[
Works like `x radius`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/y:radius",
      meta = "⟨dimension⟩"
    },
    ["cs/z"] = {
      details = [[
Works like `x`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/cs/z",
      meta = "⟨factor⟩"
    },
    ["current point is local"] = {
      details = [[
Normally, the scope path operation has no effect on the current point.
That is, curly braces on a path have no effect on the current position:

    \begin{tikzpicture}
      \draw      (0,0) -- ++(1,0)   -- ++(0,1)   -- ++(-1,0);
      \draw[red] (2,0) -- ++(1,0) { -- ++(0,1) } -- ++(-1,0);
    \end{tikzpicture}

If you set this key to `true`, this behavior changes. In this case, at
the end of a group created on a path, the last current position reverts
to whatever value it had at the beginning of the scope. More precisely,
when TikZ encounters `}` on a path, it checks whether at this particular
moment the key is set to `true`. If so, the current position reverts to
the value it had when the matching `{` was read.

    \begin{tikzpicture}
      \draw      (0,0) -- ++(1,0)   -- ++(0,1)   -- ++(-1,0);
      \draw[red] (2,0) -- ++(1,0)
         { [current point is local] -- ++(0,1) } -- ++(-1,0);
    \end{tikzpicture}

In the above example, we could also have given the option outside the
scope, for instance as a parameter to the whole scope.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/current:point:is:local",
      meta = "⟨boolean⟩"
    },
    ["curve to"] = {
      details = [[
Specifies that the `to path` should be a curve. This curve will leave
the start coordinate at a certain angle, which can be specified using
the `out` option. It reaches the target coordinate also at a certain
angle, which is specified using the `in` option. The control points of
the curve are at a certain distance that is computed in different ways,
depending on which options are set.

All of the following options implicitly cause the `curve to` style to be
installed.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/curve:to"
    },
    dash = {
      details = [[
Sets the dashing pattern and phase at the same time.

    \begin{tikzpicture}
      \draw [dash=on 20pt off 10pt phase  0pt] (0pt,3pt) -- (3.5cm,3pt);
      \draw [dash=on 20pt off 10pt phase 10pt] (0pt,0pt) -- (3.5cm,0pt);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/dash",
      meta = "⟨dash pattern⟩phase⟨dash phase⟩"
    },
    ["dash dot"] = {
      details = [[
Shorthand for setting a dashed and dotted dash pattern.

    \tikz \draw[dash dot] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/dash:dot"
    },
    ["dash dot dot"] = {
      details = [[
Shorthand for setting a dashed and dotted dash pattern with more dots.

    \tikz \draw[dash dot dot] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/dash:dot:dot"
    },
    ["dash expand off"] = {
      details = [[
Makes the `off` part of a dash pattern expandable such that it can
stretch. This only works when there is a single `on` and a single `off`
field and requires the `decorations` library. Right now this option has
to be specified on the path where it is supposed to take effect after
the `dash pattern` option because the dash pattern has to be known at
the point where it is applied.

    \begin{tikzpicture}[|-|, dash pattern=on 4pt off 2pt]
      \draw [dash expand off] (0pt,30pt) -- (26pt,30pt);
      \draw [dash expand off] (0pt,20pt) -- (24pt,20pt);
      \draw [dash expand off] (0pt,10pt) -- (22pt,10pt);
      \draw [dash expand off] (0pt, 0pt) -- (20pt, 0pt);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/dash:expand:off"
    },
    ["dash pattern"] = {
      details = [[
Sets the dashing pattern. The syntax is the same as in METAFONT. For
example following pattern `on 2pt off 3pt on 4pt off 4pt` means "draw
2pt, then leave out 3pt, then draw 4pt once more, then leave out 4pt
again, repeat".

    \begin{tikzpicture}[dash pattern=on 2pt off 3pt on 4pt off 4pt]
      \draw (0pt,0pt) -- (3.5cm,0pt);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/dash:pattern",
      meta = "⟨dash pattern⟩"
    },
    ["dash phase"] = {
      details = [[
Shifts the start of the dash pattern by ⟨phase⟩.

    \begin{tikzpicture}[dash pattern=on 20pt off 10pt]
      \draw[dash phase=0pt] (0pt,3pt) -- (3.5cm,3pt);
      \draw[dash phase=10pt] (0pt,0pt) -- (3.5cm,0pt);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/dash:phase",
      meta = "⟨dash phase⟩"
    },
    dashed = {
      details = [[
Shorthand for setting a dashed dash pattern.

    \tikz \draw[dashed] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/dashed"
    },
    ["data visualizers/visualize as line"] = {
      details = [[
Creates a new visualizer named ⟨visualizer name⟩. Basically, this
visualizer connects all data points for which the `/data point/set`
attribute equals ⟨visualizer name⟩ by a line that is styled by the
visualizer's style.

In more detail, the following happens:

1.  A new object is created (of class `plot handler visualizer`) that is
    configured to collect the canvas positions of all data points whose
    `set` attribute equals ⟨visualizer name⟩.

2.  During the end of the data visualization, PGF's plotting mechanism
    (see Section ??) is used to plot the stream of recorded data points.

    This means that, in principle, all of the plot handlers available in
    TikZ could be used for the visualization (such as the `smooth`
    handler). However, some plot handlers such as, say, the `xcomb` are
    unsuitable as plot handlers since they do not support the advanced
    axis handling done by the data visualization engine. Because of this
    (and also for other reasons), you cannot set the plot handler
    directly, but must use one of the options like `straight line`,
    `smooth line` and others, documented in a moment.

3.  Additionally, plot marks can be drawn at the collected data points.
    Here, all of the options available to TikZ for drawing plot marks
    are available. To configure them, all options offered by TikZ for
    configuring marks are available such as `mark repeat`:

        \tikz \datavisualization
         [scientific axes=clean,
          visualize as line=my data,
          my data={style={mark=x, mark repeat=3}}]
        data [format=function] {
          var x : interval [0:pi] samples 10;
          func y = sin(\value x r);
        };

The line visualizer also provides a method of dealing with gaps in a
line. Take for instance the function $f(x) = \tan x$. When this function
is plotted over the interval $[0,\pi]$, then the function will go to
$\pm
    \infty$ at $\pi/2$. When we plot this, we might plot the function in
the interval $[0,\frac{\pi}{2}-\epsilon]$ and then continue in the
interval $[\frac{\pi}{2}+\epsilon,\pi]$. However, we do not want the
point at coordinate $\bigl(\frac{\pi}{2}- \epsilon, \tan(\frac{\pi}{2}-
    \epsilon)\bigr)$ to be connected to the coordinate
$\bigl(\frac{\pi}{2}+
    \epsilon, \tan(\frac{\pi}{2}+ \epsilon)\bigr)$ by a line. Rather,
there should be a "gap" or a "jump" between these coordinates. To
achieve this, the following key can be used:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualizers/visualize:as:line",
      meta = "⟨visualizer name⟩"
    },
    ["data visualizers/visualize as scatter"] = {
      details = [[
A shorthand `visualize as line=`⟨visualizer name⟩ followed ⟨visualizer
name⟩`=no lines` and setting the `style` of the visualizer so that is
will use `mark=x` (plus some size adjustments) to draw marks at the data
points.

    \tikz \datavisualization
     [scientific axes=clean,
      visualize as scatter]
    data [format=function] {
      var x : interval [0:pi] samples 10;
      func y = sin(\value x r);
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualizers/visualize:as:scatter",
      meta = "⟨visualizer name⟩"
    },
    ["data visualizers/visualize as smooth line"] = {
      details = [[
A shorthand `visualize as line=`⟨visualizer name⟩ followed ⟨visualizer
name⟩`=smooth line`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualizers/visualize:as:smooth:line",
      meta = "⟨visualizer name⟩"
    },
    dates = {
      details = [[
This option specifies the date range. Both the start and end date are
specified and described on page ??. In short: You can provide ISO-format
type dates like `2006-01-02`, you can replace the day of month by `last`
to refer to the last day of a month (so `2006-02-last` is the same as
`2006-02-28`), and you can add a plus sign followed by a number to
specify an offset (so `2006-01-01+-1` is the same as `2005-12-31`).
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/dates",
      meta = "⟨start date⟩ to ⟨end date⟩"
    },
    ["day code"] = {
      details = [[
This option allows you to change the code that is executed for each day.
The default is to create a node with an appropriate name, but you can
change this:

    \tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,
                    day code={\fill[blue] (0,0) circle (2pt);}];

The default code is the following:

    \node[name=\pgfcalendarsuggestedname,every day]{\tikzdaytext};

The first part causes the day nodes to be accessible via the following
names: If ⟨name⟩ is the name given to the calendar via a `name=` option
or via the specification element `(`⟨name⟩`)`, then
`\pgfcalendarsuggestedname` will expand to ⟨name⟩`-`⟨date⟩, where ⟨date⟩
is the date of the day that is currently being processed in ISO format.

For example, if January 1, 2006 is being processed and the calendar has
been named `mycal`, then the node containing the `1` for this date will
be names `mycal-2006-01-01`. You can later reference this node.

    \begin{tikzpicture}
      \calendar (mycal) [dates=2000-01-01 to 2000-01-31,week list];

      \draw[red] (mycal-2000-01-20) circle (4pt);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/day:code",
      meta = "⟨code⟩"
    },
    ["day list downward"] = {
      details = [[
This style causes the days of a month to be typeset one below the other.
The shift between days is given by `day yshift`. Between month an
additional shift of `month yshift` is added.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list downward,month yshift=1em];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/day:list:downward"
    },
    ["day list left"] = {
      details = [[
As above, but the list grows left.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/day:list:left"
    },
    ["day list right"] = {
      details = [[
This style also works as before, but the list of days grows to the
right. Instead of `day yshift` and `month yshift`, the values of
`day xshift` and `month xshift` are used.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list right,month xshift=1em];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/day:list:right"
    },
    ["day list upward"] = {
      details = [[
Works as above, only the list grows upward instead of downward.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list upward,month yshift=1em];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/day:list:upward"
    },
    ["day text"] = {
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/day:text",
      meta = "⟨text⟩"
    },
    ["day xshift"] = {
      details = [[
Specifies the horizontal shift between days. This is not the gap between
days, but the shift between the anchors of their nodes.

    \tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,day xshift=3ex];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/day:xshift",
      meta = "⟨dimension⟩"
    },
    ["day yshift"] = {
      details = [[
Specifies the vertical shift between days. Again, this is the shift
between the anchors of their nodes.

    \tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,day yshift=2ex];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/day:yshift",
      meta = "⟨dimension⟩"
    },
    decorate = {
      details = [[
When this key is set, the whole path is decorated after it has been
finished. The decoration used for decorating the path is set via the
`decoration` way, in exactly the same way as for the `decorate` path
command. Indeed, the following two commands have the same effect:

1.  `\path decorate[`⟨options⟩`] {`⟨path⟩`};`

2.  `\path [decorate,`⟨options⟩`] `⟨path⟩`;`

The main use or the `decorate` option is the you can also use it with
the nodes. It then causes the background path of the node to be
decorated. Note that you can decorate a background path only once in
this manner. That is, in contrast to the `decorate` path command you
cannot apply this option twice (this would just set it to `true`, once
more).

    \begin{tikzpicture}[decoration=zigzag]
      \draw [help lines] (0,0) grid (3,5);

      \draw [fill=blue!20,decorate] (1.5,4) circle (1cm);

      \node at (1.5,2.5) [fill=red!20,decorate,ellipse] {Ellipse};

      \node at (1.5,1) [inner sep=6mm,fill=red!20,decorate,ellipse,decoration=
        {text along path,text={This is getting silly}}] {Ellipse};
    \end{tikzpicture}

In the last example, the `text along path` decoration removes the path.
In such cases it is useful to use a pre- or postaction to cause the
decoration to be applied only before or after the main path has been
used. Incidentally, this is another application of the `decorate` option
that you cannot achieve with the decorate path command.

    \begin{tikzpicture}[decoration=zigzag]
      \node at (1.5,1) [inner sep=6mm,fill=red!20,ellipse,
        postaction={decorate,decoration=
        {text along path,text={This is getting silly}}}] {Ellipse};
    \end{tikzpicture}

Here is more useful example, where a postaction is used to add the path
after the main path has been drawn.

    \begin{tikzpicture}
    \draw [help lines] grid (3,2);
    \fill [draw=red,fill=red!20,
             postaction={decorate,decoration={raise=2pt,text along path,
               text=around and around and around and around we go}}]
      (0,1) arc (180:-180:1.5cm and 1cm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/decorate",
      meta = "⟨boolean⟩"
    },
    ["delta angle"] = {
      details = [[
Sets the delta angle.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/delta:angle",
      meta = "⟨degrees⟩"
    },
    ["densely dash dot"] = {
      details = [[
Shorthand for setting a densely dashed and dotted dash pattern.

    \tikz \draw[densely dash dot] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/densely:dash:dot"
    },
    ["densely dash dot dot"] = {
      details = [[
Shorthand for setting a densely dashed and dotted dash pattern with more
dots.

    \tikz \draw[densely dash dot dot] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/densely:dash:dot:dot"
    },
    ["densely dashed"] = {
      details = [[
Shorthand for setting a densely dashed dash pattern.

    \tikz \draw[densely dashed] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/densely:dashed"
    },
    ["densely dotted"] = {
      details = [[
Shorthand for setting a densely dotted dash pattern.

    \tikz \draw[densely dotted] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/densely:dotted"
    },
    distance = {
      details = [[
Set the minimum and maximum distance to the same value ⟨distance⟩. Note
that this causes any computed distance $d$ to be ignored and ⟨distance⟩
to be used instead.

    \begin{tikzpicture}[out=45,in=135,distance=1cm]
      \draw (0,0) to (1,0)
            (0,0) to (2,0)
            (0,0) to (3,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/distance",
      meta = "⟨distance⟩"
    },
    domain = {
      details = [[
Sets the domain from which the samples are taken.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/domain",
      meta = "⟨start⟩:⟨end⟩"
    },
    dotted = {
      details = [[
Shorthand for setting a dotted dash pattern.

    \tikz \draw[dotted] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/dotted"
    },
    double = {
      details = [[
This option causes "two" lines to be drawn instead of a single one.
However, this is not what really happens. In reality, the path is drawn
twice. First, with the normal drawing color, secondly with the ⟨core
color⟩, which is normally `white`. Upon the second drawing, the line
width is reduced. The net effect is that it appears as if two lines had
been drawn and this works well even with complicated, curved paths:

    \tikz \draw[double]
      plot[smooth cycle] coordinates{(0,0) (1,1) (1,0) (0,1)};

You can also use the doubling option to create an effect in which a line
seems to have a certain "border":

    \begin{tikzpicture}
      \draw (0,0) -- (1,1);
      \draw[draw=white,double=red,very thick] (0,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/double",
      meta = "⟨core color⟩"
    },
    ["double copy shadow"] = {
      details = [[
This shadow works like a `copy shadow`, only the shadow is added twice,
the second time with the double `xshift` and `yshift`.

    \begin{tikzpicture}
      \node [double copy shadow,fill=blue!20,draw=blue,thick] {Hello World!};

      \node at (0,-1) [double copy shadow={shadow xshift=1ex,shadow yshift=1ex},
                       fill=blue!20,draw=blue,thick]
        {Hello World!};

      \node at (0,-2) [double copy shadow={opacity=.5},tape,
                       fill=blue!20,draw=blue,thick]
        {Hello World!};

      \node at (0,-3) [double copy shadow={left color=blue!50},
                       left color=blue!50,draw=blue,thick]
        {Hello World!};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/double:copy:shadow",
      meta = "⟨shadow options⟩"
    },
    ["double distance"] = {
      details = [[
Sets the distance the "two" lines are spaced apart. In reality, this is
the thickness of the line that is used to draw the path for the second
time. The thickness of the *first* time the path is drawn is twice the
normal line width plus the given ⟨dimension⟩. As a side-effect, this
option "selects" the `double` option.

    \begin{tikzpicture}
      \draw[very thick,double]              (0,0) arc (180:90:1cm);
      \draw[very thick,double distance=2pt] (1,0) arc (180:90:1cm);
      \draw[thin,double distance=2pt]       (2,0) arc (180:90:1cm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/double:distance",
      meta = "⟨dimension⟩"
    },
    ["double distance between line centers"] = {
      details = [[
This option works like `double distance`, only the distance is not the
distance between (inner) borders of the two main lines, but between
their centers. Thus, the thickness the *first* time the path is drawn is
the normal line width plus the given ⟨dimension⟩, while the line width
of the *second* line that is drawn is ⟨dimension⟩ minus the normal line
width. As a side-effect, this option "selects" the `double` option.

    \begin{tikzpicture}[double distance between line centers=3pt]
      \foreach \lw in {0.5,1,1.5,2,2.5}
        \draw[line width=\lw pt,double] (\lw,0) -- ++(4mm,0);
    \end{tikzpicture}

    \begin{tikzpicture}[double distance=3pt]
      \foreach \lw in {0.5,1,1.5,2,2.5}
        \draw[line width=\lw pt,double] (\lw,0) -- ++(4mm,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/double:distance:between:line:centers",
      meta = "⟨dimension⟩"
    },
    ["double equal sign distance"] = {
      details = [[
This style selects a double line distance such that it corresponds to
the distance of the two lines in an equal sign.

    \Huge $=\implies$\tikz[baseline,double equal sign distance]
                        \draw[double,thick,-{Implies[]}](0,0.55ex) --++(3ex,0);

    \normalsize $=\implies$\tikz[baseline,double equal sign distance]
                              \draw[double,-{Implies[]}](0,0.6ex) --++(3ex,0);

    \tiny $=\implies$\tikz[baseline,double equal sign distance]
                       \draw[double,very thin,-{Implies[]}](0,0.5ex) -- ++(3ex,0);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/double:equal:sign:distance"
    },
    draw = {
      details = [[
Causes the path to be drawn. "Drawing" (also known as "stroking") can be
thought of as picking up a pen and moving it along the path, thereby
leaving "ink" on the canvas.

There are numerous parameters that influence how a line is drawn, like
the thickness or the dash pattern. These options are explained below.

If the optional ⟨color⟩ argument is given, drawing is done using the
given ⟨color⟩. This color can be different from the current filling
color, which allows you to draw and fill a path with different colors.
If no ⟨color⟩ argument is given, the last usage of the `color=` option
is used.

If the special color name `none` is given, this option causes drawing to
be "switched off". This is useful if a style has previously switched on
drawing and you locally wish to undo this effect.

Although this option is normally used on paths to indicate that the path
should be drawn, it also makes sense to use the option with a `{scope}`
or `{tikzpicture}` environment. However, this will *not* cause all paths
to be drawn. Instead, this just sets the ⟨color⟩ to be used for drawing
paths inside the environment.

    \begin{tikzpicture}
      \path[draw=red] (0,0) -- (1,1) -- (2,1) circle (10pt);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/draw",
      meta = "⟨color⟩"
    },
    ["draw opacity"] = {
      details = [[
This option sets "how transparent" lines should be. A value of `1` means
"fully opaque" or "not transparent at all", a value of `0` means "fully
transparent" or "invisible". A value of `0.5` yields lines that are
semitransparent.

Note that when you use PostScript as your output format, this option
works only with recent versions of Ghostscript.

    \begin{tikzpicture}[line width=1ex]
      \draw (0,0) -- (3,1);
      \filldraw [fill=yellow!80!black,draw opacity=0.5] (1,0) rectangle (2,1);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/draw:opacity",
      meta = "⟨value⟩"
    },
    ["drop shadow"] = {
      details = [[
This option adds a drop shadow to a `\path` or a `node`. It uses the
`general shadow` and passes the ⟨shadow options⟩ to it, plus, before
them, the following extra options:

      shadow scale=1, shadow xshift=.5ex, shadow yshift=-.5ex,
      opacity=.5, fill=black!50, every shadow

    \tikz [even odd rule]
      \filldraw [drop shadow,fill=white] (0,0) circle (.5) (0.5,0) circle (.5);

    \begin{tikzpicture}
      \foreach \i in {1,...,4}
        \node[starburst,drop shadow,fill=white,draw] at (0,\i) {Burst \i};
    \end{tikzpicture}

    \begin{tikzpicture}
      \draw [help lines] (0,0) grid (3,2);
      \filldraw [drop shadow={opacity=1},fill=white]
        (1,2)  circle (.5) (1.5,2)  circle (.5);

      \filldraw [drop shadow={opacity=0.25},fill=white]
        (1,.5) circle (.5) (1.5,.5) circle (.5);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/drop:shadow",
      meta = "⟨shadow options⟩"
    },
    ["edge from parent"] = {
      details = [[
This style is inserted right before the `edge from parent path` and
before the ⟨options⟩ are inserted.

    \begin{tikzpicture}
      [edge from parent/.style={draw,red,thick}]
      \node {root}
        child {node {left} edge from parent[dashed]}
        child {node {right}
          child {node {child}}
          child {node {child} edge from parent[draw=none]}
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent"
    },
    ["edge from parent fork down"] = {
      details = [[
This style will draw a line from the parent downwards (for half the
level distance) and then on to the child using only horizontal and
vertical lines.

    \begin{tikzpicture}
      \node {root}
        [edge from parent fork down]
        child {node {left}}
        child {node {right}
          child[child anchor=north east] {node {child}}
          child {node {child}}
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:fork:down"
    },
    ["edge from parent fork left"] = {
      details = [[
Behaves similarly to the previous styles.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:fork:left"
    },
    ["edge from parent fork right"] = {
      details = [[
This style behaves similarly, only it will first draw its edge to the
right.

    \begin{tikzpicture}
      \node {root}
        [edge from parent fork right,grow=right]
        child {node {left}}
        child {node {right}
          child {node {child}}
          child {node {child}}
        };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:fork:right"
    },
    ["edge from parent fork up"] = {
      details = [[
Behaves similarly to the previous styles.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:fork:up"
    },
    ["edge from parent macro"] = {
      details = [[
The ⟨macro⟩ gets expanded each time the `edge from parent` path
operation is used. This ⟨macro⟩ must take two parameters and must expand
to some text that is subsequently parsed by the parser. The first
parameter will be the set of ⟨options⟩ that where passed to the
`edge from parent` command, the second parameter will be the ⟨node
specifications⟩ that following the command.

The standard behavior of drawing a straight line from the parent node to
the child node could be achieved by setting the ⟨macro⟩ to the
following:

    \def\mymacro#1#2{
      [style=edge from parent, #1]
      (\tikzparentnode\tikzparentanchor) -- #2 (\tikzchildnode\tikzchildanchor)
    }

Note that `# 2` is placed between `–` and the node to ensure that nodes
are put "on top" of the line.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:macro",
      meta = "⟨macro⟩"
    },
    ["edge from parent path"] = {
      details = [[
This option allows you to set the `edge from parent path` to a new path.
Initially, this path is the following:

    (\tikzparentnode\tikzparentanchor) -- (\tikzchildnode\tikzchildanchor)

The `\tikzparentnode` is a macro that will expand to the name of the
parent node. This works even when you have not assigned a name to the
parent node, in this case an internal name is automatically generated.
The `\tikzchildnode` is a macro that expands to the name of the child
node. The two `...anchor` macros are empty by default. So, what is
essentially inserted is just the path segment
`(\tikzparentnode) – (\tikzchildnode)`; which is exactly an edge from
the parent to the child.

You can modify this edge from parent path to achieve all sorts of
effects. For example, we could replace the straight line by a curve as
follows:

    \begin{tikzpicture}[level distance=15mm, sibling distance=15mm,
      edge from parent path=
      {(\tikzparentnode.south) .. controls +(0,-1) and +(0,1)
                               .. (\tikzchildnode.north)}]
      \node {root}
        child {node {left}}
        child {node {right}
          child {node {child}}
          child {node {child}}
        };
    \end{tikzpicture}

Further useful `edge from parent path`s are defined in the tree library,
see Section ??.

The nodes in a ⟨node specification⟩ following the `edge from parent`
path command get executed as if the `pos` option had been added to all
these nodes, see also Section ??.

As an example, consider the following code:

    \node (root) {} child {node (child) {} edge to parent node {label}};

The `edge to parent` operation and the following `node` operation will,
together, have the same effect as if we had said:

    (root) -- (child) node [pos=0.5] {label}

Here is a more complicated example:

    \begin{tikzpicture}
      \node {root}
        child {
          node {left}
          edge from parent
            node[left] {a}
            node[right] {b}
        }
        child {
          node {right}
            child {
              node {child}
              edge from parent
                node[left] {c}
            }
            child {node {child}}
          edge from parent
            node[near end] {x}
        };
    \end{tikzpicture}

As said before, the anchors in the default `edge from parent path` are
empty. However, you can set them using the following keys:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:path",
      meta = "⟨path⟩"
    },
    ["edge label"] = {
      details = [[
A shorthand for `edge node={node[auto]{`⟨text⟩`}}`.

    \tikz \draw (0,0) to [edge label=x] (3,2);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/edge:label",
      meta = "⟨text⟩"
    },
    ["edge label'"] = {
      details = [[
A shorthand for `edge node={node[auto,swap]{`⟨text⟩`}}`.

    \tikz \draw (0,0) to [edge label=x, edge label'=y] (3,2);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/edge:label'",
      meta = "⟨text⟩"
    },
    ["edge node"] = {
      details = [[
This key can be used inside the ⟨options⟩ of a `to` path command. It
will add the ⟨node specification⟩ to the list of nodes to be placed on
the connecting line, just as if you had written the ⟨node specification⟩
directly after the `to` keyword:

    \begin{tikzpicture}
      \draw (0,0) to [edge node={node [sloped,above] {x}}] (3,2);

      \draw (0,0) to [out=90,in=180,
                      edge node={node [sloped,above] {x}}] (3,2);
    \end{tikzpicture}

This key is mostly useful to create labels automatically using other
keys.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/edge:node",
      meta = "⟨node specification⟩"
    },
    ["end angle"] = {
      details = [[
Sets the end angle.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/end:angle",
      meta = "⟨degrees⟩"
    },
    entity = {
      details = [[
This style is to be used with nodes that represent entity types. It
causes the node's shape to be set to a rectangle that is drawn and whose
minimum size and width are set to sensible values.

Note that this style is called `entity` despite the fact that it is to
be used for nodes representing entity *types* (the difference between an
entity and an entity type is the same as the difference between an
object and a class in object-oriented programming). If this bothers you,
feel free to define a style `entity type` instead.

    \begin{tikzpicture}
      \node[entity] (sheep)                   {Sheep};
      \node[entity] (genome) [right=of sheep] {Genome};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/entity"
    },
    evaluate = {
      details = [[
This key simply executes `\tikzmath{`⟨statements⟩`}`.

    \tikz[x=0.25cm,y=0.25cm,
      evaluate={
        int \i, \j;
        for \i in {0,...,10} {
          for \j in {0,...,10} {
            \a{\i,\j} = (\i+\j)*5;
          };
        };
      }
    ]
    \foreach \i in {0,...,10}
      \foreach \j in {0,...,10}
        \fill [red!\a{\i,\j}!yellow]  (\i,\j) rectangle ++(1, 1);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/evaluate",
      meta = "{⟨statements⟩}"
    },
    ["even odd rule"] = {
      details = [[
This option causes a different method to be used for determining the
inside and outside of paths. While it is less flexible, it turns out to
be more intuitive.

With this method, we also shoot rays from the point for which we wish to
determine whether it is inside or outside the filling area. However,
this time we only count how often we "hit" the path and declare the
point to be "inside" if the number of hits is odd.

Using the even-odd rule, it is easy to "drill holes" into a path.

    \begin{tikzpicture}
      \filldraw[fill=yellow!80!black,even odd rule]
        (0,0) rectangle (1,1) (0.5,0.5) circle (0.4cm);
      \draw[->] (0.5,0.5) -- +(0,1) [above] node{crossings: $1+1 = 2$};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/even:odd:rule"
    },
    ["every above delimiter"] = {
      details = [[
Works as above.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:above:delimiter"
    },
    ["every accepting by arrow"] = {
      details = [[
Executed at the beginning of every path that contains the arrow and the
text.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:accepting:by:arrow"
    },
    ["every annotation"] = {
      details = [[
This style is included by `annotation`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:annotation"
    },
    ["every attribute"] = {
      details = [[
This style is used with every attribute, and therefore also for every
key attribute.

    \begin{tikzpicture}
      [text depth=1pt,
       every attribute/.style={fill=black!20,draw=black},
       every entity/.style={fill=blue!20,draw=blue,thick},
       every relationship/.style={fill=orange!20,draw=orange,thick,aspect=1.5}]

      \node[entity] (sheep)  at (0,0)   {Sheep}
        child {node  [key attribute] {name}};
      \node[entity] (genome) at (2,0)   {Genome};
      \node[relationship]    at (1,1.5) {has}
        edge (sheep)
        edge (genome);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:attribute"
    },
    ["every below delimiter"] = {
      details = [[
Works as above.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:below:delimiter"
    },
    ["every calendar"] = {
      details = [[
This style is used with every calendar.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:calendar"
    },
    ["every cell"] = {
      details = [[
This style is installed at the beginning of each cell picture with the
two parameters being the current ⟨row⟩ and ⟨column⟩ of the cell. Note
that setting this style to `draw` will *not* cause all nodes to be drawn
since the `draw` option has to be passed to each node individually.

Inside this style (and inside all cells), the current ⟨row⟩ and ⟨column⟩
number are also accessible via the counters `\pgfmatrixcurrentrow` and
`\pgfmatrixcurrentcolumn`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:cell",
      meta = "{row}{column}"
    },
    ["every child"] = {
      details = [[
This style is used at the beginning of each child, as if you had given
the style's contents as options to the `child` operation.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:child"
    },
    ["every child node"] = {
      details = [[
This style is used at the beginning of each child node in addition to
the `every node` style.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:child:node"
    },
    ["every circle"] = {
      details = [[
You can use this key to set up, say, a default radius for every circle.
The key will also be used with the `ellipse` operation.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:circle"
    },
    ["every circle connection bar"] = {
      details = [[
Redefine this style to change the appearance of circle connection bar
to-paths.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:circle:connection:bar"
    },
    ["every circuit ee"] = {
      details = [[
Use this key to configure the appearance of logical circuits.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:circuit:ee"
    },
    ["every circuit logic"] = {
      details = [[
Use this key to configure the appearance of logical circuits.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:circuit:logic"
    },
    ["every circuit symbol"] = {
      details = [[
Use this style to set up things in general.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:circuit:symbol"
    },
    ["every concept"] = {
      details = [[
In order to change the appearance of concept nodes, you should change
this style. Note, however, that the color of a concept should be uniform
for some of the connection bar stuff to work, so you should not change
the color or the draw/fill state of concepts using this option. It is
mostly useful for changing the text color and font.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:concept"
    },
    ["every cut"] = {
      details = [[
Executed for every line that should be cut using scissors.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:cut"
    },
    ["every data"] = {
      details = [[
This key is executed for every `data` command.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:data"
    },
    ["every day"] = {
      details = [[
This style is executed by the default node code for each day. The
`every day` style is useful for changing the way days look. For example,
let us make all days red:

    \tikz[every day/.style=red]
      \calendar[dates=2000-01-01 to 2000-01-31,week list];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:day"
    },
    ["every delimiter"] = {
      details = [[
This style is executed for every delimiter. You can use it to shift or
color delimiters or do whatever.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:delimiter"
    },
    ["every edge"] = {
      details = [[
Executed for each `edge`.

    \begin{tikzpicture}[every edge/.style={draw,dashed}]
      \path (0,0) edge (3,2);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:edge"
    },
    ["every edge quotes"] = {
      details = [[
This style is `auto` by default, which causes labels specified using the
quotes-syntax to be placed next to the edges. Unless the setting of
`auto` has been changed, they will be placed to the left.

    \tikz \draw (0,0) edge ["left", ->] (2,0);

In order to place all labels to the right by default, change this style
to `auto=right`:

    \tikz [every edge quotes/.style={auto=right}]
      \draw (0,0) edge ["right", ->] (2,0);

To place all nodes "on" the edge, just make this style empty (and,
possibly, make your labels opaque):

    \tikz [every edge quotes/.style={fill=white,font=\footnotesize}]
      \draw (0,0) edge ["mid", ->] (2,1);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:edge:quotes"
    },
    ["every entity"] = {
      details = [[
This style is evoked by the style `entity`. To change the appearance of
entities, you can change this style.

    \begin{tikzpicture}
      [every entity/.style={draw=blue!50,fill=blue!20,thick}]
      \node[entity] (sheep)                   {Sheep};
      \node[entity] (genome) [right=of sheep] {Genome};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:entity"
    },
    ["every even column"] = {
      details = [[
This style is used for every cell in an even column.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:even:column"
    },
    ["every even row"] = {
      details = [[
This style is used for every cell in an even row.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:even:row"
    },
    ["every extra concept"] = {
      details = [[
Change this style to change the appearance of extra concepts.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:extra:concept"
    },
    ["every fit"] = {
      details = [[
Set this style to change the appearance of a node that uses the `fit`
option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:fit"
    },
    ["every fold"] = {
      details = [[
Executed for every line that should be folded.

    \tikz \pic[
      every cut/.style=red,
      every fold/.style=dotted,
      folding line length=6mm
    ] { tetrahedron folding };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:fold"
    },
    ["every info"] = {
      details = [[
Set this style to configure the styling of info labels. Since this key
is *not* used with normal labels, it provides an easy way of changing
the way info labels look without changing other labels.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:info"
    },
    ["every initial by arrow"] = {
      details = [[
This style is executed at the beginning of every path that contains the
arrow and the text. You can use it to, say, make the text red or
whatever.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:initial:by:arrow"
    },
    ["every join"] = {
      details = [[
This style is executed each time this command is used.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:join"
    },
    ["every label"] = {
      details = [[
This style is used in every node created by the `label` option. The
default is `draw=none,fill=none`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:label"
    },
    ["every label quotes"] = {
      details = [[
    \tikz [every label quotes/.style=red]
      \node ["90:$90^\circ$", "left:$180^\circ$", circle, draw] {circle};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:label:quotes"
    },
    ["every left delimiter"] = {
      details = [[
This style is additionally executed for every left delimiter.

    \begin{tikzpicture}
      [every left delimiter/.style={red,xshift=1ex},
       every right delimiter/.style={xshift=-1ex}]
      \matrix [matrix of math nodes,left delimiter=(,right delimiter=\}]
      {
        a_8 & a_1 & a_6 \\
        a_3 & a_5 & a_7 \\
        a_4 & a_9 & a_2 \\
      };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:left:delimiter"
    },
    ["every loop"] = {
      details = [[
This style is installed at the beginning of every loop.

    \begin{tikzpicture}[every loop/.style={}]
      \draw (0,0) to [loop above] () to [loop right] ()
                  to [loop below] () to [loop left]  ();
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:loop"
    },
    ["every mark"] = {
      details = [[
This style is installed before drawing plot marks. For example, you can
scale (or otherwise transform) the plot mark or set its color.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:mark"
    },
    ["every matrix"] = {
      details = [[
This style is used in every matrix.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:matrix"
    },
    ["every mindmap"] = {
      details = [[
This style is included by the `mindmap` style. Change this style to add
special settings to your mindmaps.

    \tikz[large mindmap,concept color=red!50]
      \node [concept] {Root concept}
        child[grow=right] {node[concept] {Child concept}};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:mindmap"
    },
    ["every month"] = {
      details = [[
This style can be used to change the appearance of month labels.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:month"
    },
    ["every new --"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:new:--"
    },
    ["every new ->"] = {
      details = [[
This key gets executed by default for a `new ->`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:new:->"
    },
    ["every new <-"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:new:<-"
    },
    ["every new <->"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:new:<->"
    },
    ["every node"] = {
      details = [[
This style is installed at the beginning of every node.

    \begin{tikzpicture}[every node/.style={draw}]
      \draw (0,0) node {A} -- (1,1) node {B};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:node"
    },
    ["every odd column"] = {
      details = [[
This style is used for every cell in an odd column.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:odd:column"
    },
    ["every odd row"] = {
      details = [[
This style is used for every cell in an odd row.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:odd:row"
    },
    ["every on background layer"] = {
      details = [[
This style is executed at the beginning of each background layer. If you
have a global setup in `every picture`, you should consider putting that
part of it that concerns the graphics state into this style.

    \tikzset{
      every picture/.style={line width=1ex},
      every on background layer/.style={every picture}
    }
    \begin{tikzpicture}
      \draw [->] (0,0) -- (2,1);

      \scoped[on background layer]
        \draw[red] (0,1) -- (2,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:on:background:layer"
    },
    ["every on chain"] = {
      details = [[
This key is executed for every node on a chain, including the first one.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:on:chain"
    },
    ["every outer matrix"] = {
      details = [[
While the `every matrix` key also applies to the matrix contents, this
only applies to the outer node which holds the matrix.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:outer:matrix"
    },
    ["every path"] = {
      details = [[
This style is installed at the beginning of every path. This can be
useful for (temporarily) adding, say, the `draw` option to everything in
a scope.

    \begin{tikzpicture}
      [fill=yellow!80!black,      % only sets the color
       every path/.style={draw}]  % all paths are drawn
      \fill  (0,0) rectangle +(1,1);
      \shade (2,0) rectangle +(1,1);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:path"
    },
    ["every pic"] = {
      details = [[
This style is installed at the beginning of every pic.

     (0,0) to [bend left] (3mm,0);
      },
    }}]
    \begin{tikzpicture}[every pic/.style={scale=2,transform shape}]
      \pic foreach \x in {1,2,3} at (\x,0) {seagull};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:pic"
    },
    ["every pic quotes"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:pic:quotes"
    },
    ["every picture"] = {
      details = [[
This style is installed at the beginning of each picture.

    \tikzset{every picture/.style=semithick}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:picture"
    },
    ["every pin"] = {
      details = [[
This style is used in every node created by the `pin` option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:pin"
    },
    ["every pin edge"] = {
      details = [[
This style is used in every edge created by the `pin` options.

    \tikz [pin distance=15mm,
           every pin edge/.style={<-,shorten <=1pt,decorate,
                                  decoration={snake,pre length=4pt}}]
      \node [circle,draw,pin=right:X,
                         pin=above right:Y,
                         pin=above:Z]       {my circle};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:pin:edge"
    },
    ["every pin quotes"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:pin:quotes"
    },
    ["every place"] = {
      details = [[
This style is evoked by the style `place`. To change the appearance of
places, you can change this style.

    \begin{tikzpicture}
      [every place/.style={draw=blue,fill=blue!20,thick,minimum size=9mm}]
      \node[place,tokens=7,label=above:$p_1$]  (p1) {};
      \node[place,structured tokens={3,2,9},
            label=below:$p_2\ge1$,right=of p1] (p2) {};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:place"
    },
    ["every plot"] = {
      details = [[
This style is installed in each plot, that is, as if you always said

      plot[every plot,...]

This is most useful for globally setting a prefix for all plots by
saying:

    \tikzset{every plot/.style={prefix=plots/}}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:plot"
    },
    ["every relationship"] = {
      details = [[
Works like `every entity`.

    \begin{tikzpicture}
      [every entity/.style={fill=blue!20,draw=blue,thick},
       every relationship/.style={fill=orange!20,draw=orange,thick,aspect=1.5}]
      \node[entity] (sheep)  at (0,0)   {Sheep};
      \node[entity] (genome) at (2,0)   {Genome};
      \node[relationship]    at (1,1.5) {has}
        edge (sheep)
        edge (genome);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:relationship"
    },
    ["every right delimiter"] = {
      details = [[
Works as above.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:right:delimiter"
    },
    ["every scope"] = {
      details = [[
This style is installed at the beginning of every scope.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:scope"
    },
    ["every shadow"] = {
      details = [[
This style is executed in addition to any ⟨shadow options⟩ for each
shadow. Use this style to reconfigure the way shadows are drawn.

    \begin{tikzpicture}[every shadow/.style={opacity=.8,fill=blue!50!black}]
      \filldraw [drop shadow,fill=white] (0,0) circle (.5) (0.5,0) circle (.5);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:shadow"
    },
    ["every spy in node"] = {
      details = [[
This style is used with every spy-in node.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:spy:in:node"
    },
    ["every spy on node"] = {
      details = [[
This style is used with every spy-on node.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:spy:on:node"
    },
    ["every state"] = {
      details = [[
This style is used by `state with output` and also by
`state without output`. By default, it does nothing, but you can use it
to make your state look more fancy:

    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
        every state/.style={draw=blue!50,very thick,fill=blue!20}]

      \node[state,initial]  (q_0)                      {$q_0$};
      \node[state]          (q_1) [above right=of q_0] {$q_1$};
      \node[state]          (q_2) [below right=of q_0] {$q_2$};

      \path[->] (q_0) edge              node [above left]  {0} (q_1)
                      edge              node [below left]  {1} (q_2)
                (q_1) edge [loop above] node               {0} ()
                (q_2) edge [loop below] node               {1} ();
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:state"
    },
    ["every subgraph node"] = {
      details = [[
Set a subgraph node style.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:subgraph:node"
    },
    ["every to"] = {
      details = [[
This style is installed at the beginning of every to.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:to"
    },
    ["every token"] = {
      details = [[
Change this style to change the appearance of tokens.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:token"
    },
    ["every transition"] = {
      details = [[
This style is evoked by the style `transition`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:transition"
    },
    ["every year"] = {
      details = [[
Works like `every month`, only for years.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:year"
    },
    ["every ⟨part name⟩ node part"] = {
      details = [[
This style is installed at the beginning of every node part named ⟨part
name⟩.

    \tikz [every lower node part/.style={red}]
      \node [circle split,draw] {$q_1$ \nodepart{lower} $00$};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:⟨part:name⟩:node:part"
    },
    ["every ⟨shape⟩ node"] = {
      details = [[
These styles are installed at the beginning of a node of a given
⟨shape⟩. For example, `every rectangle node` is used for rectangle
nodes, and so on.

    \begin{tikzpicture}
      [every rectangle node/.style={draw},
       every circle node/.style={draw,double}]
      \draw (0,0) node[rectangle] {A} -- (1,1) node[circle] {B};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/every:⟨shape⟩:node"
    },
    ["execute after day scope"] = {
      details = [[
This is executed at the very end of the current date, outside the scope.
The accumulation is also in reverse.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:after:day:scope",
      meta = "⟨code⟩"
    },
    ["execute at begin cell"] = {
      details = [[
The code will be executed at the beginning of each nonempty cell.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:cell",
      meta = "⟨code⟩"
    },
    ["execute at begin day scope"] = {
      details = [[
This code is execute before everything else inside the scope of the
current date. Again, the effect is accumulative.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:day:scope",
      meta = "⟨code⟩"
    },
    ["execute at begin node"] = {
      details = [[
This option causes ⟨code⟩ to be executed at the beginning of a node.
Using this option multiple times will cause the code to accumulate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:node",
      meta = "⟨code⟩"
    },
    ["execute at begin picture"] = {
      details = [[
This option causes ⟨code⟩ to be executed at the beginning of the
picture. This option must be given in the argument of the
`{tikzpicture}` environment itself since this option will not have an
effect otherwise. After all, the picture has already "started" later on.
The effect of multiply setting this option accumulates.

This option is mainly used in styles like the `every picture` style to
execute certain code at the start of a picture.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:picture",
      meta = "⟨code⟩"
    },
    ["execute at begin scope"] = {
      details = [[
This option install some code that will be executed at the beginning of
the scope. This option must be given in the argument of the `{scope}`
environment.

The effect applies only to the current scope, not to subscopes.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:scope",
      meta = "⟨code⟩"
    },
    ["execute at begin to"] = {
      details = [[
The ⟨code⟩ is executed prior to the `to`. This can be used to draw one
or more additional paths or to do additional computations.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:to",
      meta = "⟨code⟩"
    },
    ["execute at empty cell"] = {
      details = [[
The code will be executed inside each empty cell.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:empty:cell",
      meta = "⟨code⟩"
    },
    ["execute at end cell"] = {
      details = [[
The code will be executed at the end of each nonempty cell.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:cell",
      meta = "⟨code⟩"
    },
    ["execute at end day scope"] = {
      details = [[
This code is executed just before the day scope is closed. The effect is
also accumulative, however, in reverse order. This is useful to pair,
say, `\scope` and `\endscope` commands in at-begin- and at-end-code.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:day:scope",
      meta = "⟨code⟩"
    },
    ["execute at end node"] = {
      details = [[
This option installs ⟨code⟩ that will be executed at the end of the
node. Using this option multiple times will cause the code to
accumulate.

    \begin{tikzpicture}
      [execute at begin node={A},
       execute at end node={D}]
      \node[execute at begin node={B}] {C};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:node",
      meta = "⟨code⟩"
    },
    ["execute at end picture"] = {
      details = [[
This option installs ⟨code⟩ that will be executed at the end of the
picture. Using this option multiple times will cause the code to
accumulate. This option must also be given in the optional argument of
the `{tikzpicture}` environment.

    \begin{tikzpicture}[execute at end picture=%
      {
        \begin{pgfonlayer}{background}
          \path[fill=yellow,rounded corners]
            (current bounding box.south west) rectangle
            (current bounding box.north east);
        \end{pgfonlayer}
      }]
      \node at (0,0) {X};
      \node at (2,1) {Y};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:picture",
      meta = "⟨code⟩"
    },
    ["execute at end scope"] = {
      details = [[
This option installs some code that will be executed at the end of the
current scope. Using this option multiple times will cause the code to
accumulate. This option must also be given in the optional argument of
the `{scope}` environment.

Again, the effect applies only to the current scope, not to subscopes.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:scope",
      meta = "⟨code⟩"
    },
    ["execute at end to"] = {
      details = [[
Works like the previous option, only this code is executed after the to
path has been added.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:to",
      meta = "⟨code⟩"
    },
    ["execute before day scope"] = {
      details = [[
The ⟨code⟩ is executed before everything else for each date. Multiple
calls of this option have an accumulative effect. Thus, if you use this
option twice, the code from the first use is used first for each day,
followed by the code given the second time.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/execute:before:day:scope",
      meta = "⟨code⟩"
    },
    ["external/aux in dpth"] = {
      details = [[
Allows to enable or disable the feature which handles references and
labels as part of image externalization. Disabling it will safe one
`\newwrite` command, i.e. a write register.

Also see the `disable dependency files` feature.

Here are some implementation details on how references within/from
external graphics work for those who would like to know the details:

For point a), a `\ref` inside of an externalized graphics works by
reading the main document's `.aux` file. To this end, the standard
`mode=convert with system call` detects such references and reschedules
the externalization to `\end{document}.`[1] Other values of `mode`
require just one attempt to externalize the picture.

Note that `\pageref` is not supported (sorry).

Point b) works as follows: a `\label` inside of an externalized graphics
causes the `external` library to generate separate auxiliary files for
every external image. These files are called ⟨imagename⟩`.dpth`. The
extension `.dpth` indicates that the file also contains the image's
depth (the `baseline` key of TikZ). Furthermore, anything which would
have been written to an `.aux` file will be redirected to the `.dpth`
file -- but only things which occur inside of the externalized
`tikzpicture` environment. When the main document loads the image, it
will copy the `.dpth` file into the main `.aux` file. Then, successive
compilations of the main document contain the external `\label`
information. In other words, a `\label` in an external graphics needs
the following work flow:

1.  The external graphics needs to be generated together with its
    `.dpth` (usually automatically by TikZ).

2.  The main document includes the external graphics and copies the
    `.dpth` content into its main `.aux` file.

3.  The main document needs to be translated once again to re-read its
    `.aux` file[2].

This does also work if a `\label`/`\ref` combination is implemented
itsself by a `tikzpicture` (a feature offered by `pgfplots`).

[1] Note that this requires the `atveryend` package. The purpose to
reschedule the externalization is to access the main job's aux file, but
only after it has been written completely.

[2] Note that it is not possible to activate the content of an auxiliary
file after `\ begin{document}` in LaTeX.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/aux:in:dpth",
      meta = "{boolean}"
    },
    ["external/disable dependency files"] = {
      details = [[
Allows to (irreversibly) disable the generation of file dependencies.
Disabling it will safe one `\newwrite` command, i.e. a write register.
Note that the write register is only allocated if the feature has been
used at all. This key needs to be provided as argument to
`\tikzexternalize` (or it needs to be set before calling
`\tikzexternalize`).

Also see the `aux in dpth` key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/disable:dependency:files"
    },
    ["external/export"] = {
      details = [[
A boolean which can be used to disable the export mechanism for all
pictures inside of the current TeX-scope.

    \begin{document}
    \begin{tikzpicture} % will be exported
        ...
    \end{tikzpicture}

    {
    \tikzset{external/export=false}
    \begin{tikzpicture} % won't be exported
        ...
    \end{tikzpicture}
    ...
    }

    \begin{tikzpicture} % will be exported
        ...
    \end{tikzpicture}
    \end{document}

For LaTeX, the feature lasts until the next `\end``{\cdot}` (this holds
for every call to `\tikzset`).
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/export",
      meta = "{boolean}"
    },
    ["external/export next"] = {
      details = [[
A boolean which can be used to disable the export mechanism for single
pictures.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/export:next",
      meta = "{boolean}"
    },
    ["external/figure list"] = {
      details = [[
A boolean which configures whether a figure list shall be generated. A
figure list is an output file named `{jobname}``.figlist` which is
filled with file names of each figure, one per line.

This file is not used by TeX anymore, its purpose is to issue the
required conversion commands `pdflatex -jobname ``{picture file name}`
`{main file}` manually (or in a script). See section ?? for the details
about the expected system call (or activate
`mode=convert with system call` and inspect your log file).

    \documentclass{article}
    % main document, called main.tex
    \usepackage{tikz}

    \usetikzlibrary{external}
    \tikzexternalize[
       mode=graphics if exists,
       figure list=true,
       prefix=figures/]

    \begin{document}

    \tikzsetnextfilename{trees}
    \begin{tikzpicture}
      \node {root}
        child {node {left}}
        child {node {right}
          child {node {child}}
          child {node {child}}
        };
    \end{tikzpicture}

    \tikzsetnextfilename{simple}
    A simple image is \tikz \fill (0,0) circle(5pt);.

    \begin{tikzpicture}
       \draw[help lines] (0,0) grid (5,5);
    \end{tikzpicture}
    \end{document}

    pdflatex main

generates `main.figlist` containing

    figures/trees
    figures/simple
    figures/main-figure0
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/figure:list",
      meta = "{boolean}"
    },
    ["external/figure name"] = {
      details = [[
Same as `\tikzsetfigurename``{name}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/figure:name",
      meta = "{name}"
    },
    ["external/force remake"] = {
      details = [[
A boolean which is used to customize the up-to-date checks of all
following figures. Every up-to-date check will fail, resulting in
automatic regeneration of every following figure.

    \tikzset{external/force remake}
    \begin{tikzpicture}
        \draw (0,0) circle(5pt);
    \end{tikzpicture}

You can also use `force remake` inside of a local TeX group to remake
only selected pictures. The example

    \tikz \draw (0,0) -- (1,1);

    {
    \tikzset{external/force remake}
    \begin{tikzpicture}
       \draw (0,0) circle(5pt);
    \end{tikzpicture}
    }

    \tikz \draw (0,0) -- (1,1);

will only apply `force remake` to the second figure.

Up-to-date checks are applied for `mode=convert with system call` and
the makefile generated by `mode=list and make`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/force:remake",
      meta = "{boolean}"
    },
    ["external/mode"] = {
      details = [[
Configures what to do with TikZ pictures (unless we are currently
externalizing one particular image, in that case, these modes are
ignored).

The preconfigured mode `convert with system call` checks whether
external graphics files are up-to-date and includes them if that is the
case. Any picture which is not up-to-date will be generated
automatically using a system call. The system call can be configured
using the `system call` template. The up-to-date check is applied
according to the `up to date check` key. As soon as
`convert with system call` is set, the `figure list` will be disabled --
such a file is not required. In case you still need or want it, you can
enable it after setting `mode`.

Please note that system calls may be disabled for security reasons. For
pdflatex, they can be enabled using

    pdflatex -shell-escape

while other TeX variants may need other switches. The feature is
sometimes called `\write18`.

The choice `only graphics` always tries to replace pictures with
external graphics. It is an error if the graphics file does not exist.

The choice `no graphics` (or, equivalently, `only pictures`) typesets
TikZ pictures without checking for external graphics.

A mixture is `graphics if exists`, it checks whether a suitable graphics
file exists and includes it if that is the case. If it does not exist,
the picture is typeset using TeX.

Mode `list only` skips every TikZ picture; it only generates the file
`{main file}``.figlist` containing file names for every picture, the
contents of any picture environment is thrown away and a replacement
text is shown. This implies `figure list=true`. See also the
`list and make` mode which includes available graphics.

The mode `list and make` is similar to `list only`: it generates the
same file `{main file}``.figlist`, but any images which exist already
are included as graphics instead of ignoring them. Furthermore, this
mode generates an additional file: `{main file}`.makefile. This allows
to use a work flow like

    % step 1: generate main.makefile:
    pdflatex main
    % step 2: generate ALL graphics on 2 processors:
    make -j 2 -f main.makefile
    % step 3: include the graphics:
    pdflatex main

This last make method is optional: `list and make` just assumes that
images are generated somehow (not necessarily with the generated
makefile). The generated makefile allows parallel externalization of
graphics on multi-core systems and it supports any file dependencies
configured with `\tikzpicturedependsonfile`. Furthermore, it respects
the `force remake` and `remake next` keys.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/mode",
      meta = "{choice}"
    },
    ["external/only named"] = {
      details = [[
If enabled, only pictures for which file names have been set explicitly
using `\tikzsetnextfilename` will be considered, no file names will be
generated automatically.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/only:named",
      meta = "{boolean}"
    },
    ["external/optimize"] = {
      details = [[
Configures whether the conversion process shall be optimized. This
affects only the case when `\jobname` differs from the main file name,
i.e. when single pictures are converted.

In that case, the main file is compiled as usual -- but everything
except the selected picture is thrown away. If optimization is enabled,
all other pictures won't be processed at all. Furthermore, expensive
commands which do not contribute to the selected picture will be thrown
away as well.

The default implementation discards `\includegraphics` commands which
are *not* inside of the selected picture to reduce conversion time.

It is possible to add commands which shall be optimized away, see below.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/optimize",
      meta = "{boolean}"
    },
    ["external/optimize command away"] = {
      details = [[
Installs commands to optimize ⟨\\command⟩ away. As is described above,
optimization applies to the case when single pictures are converted: one
usually doesn't need to process (probably expensive) commands which do
not contribute to the selected picture.

The argument `{required argument count}` is either empty or a
non-negative integer between $0$ and $9$. It denotes the number of
arguments which should be consumed after ⟨\\command⟩. In any case, one
argument in square brackets after the command will be recognized as
well. To be more precise, the following cases for arguments of
⟨\\command⟩ are supported:

1.  If `{required argument count}` is empty (the default), ⟨\\command⟩
    may take one optional argument in square brackets and one in curly
    braces (which is also optional).

2.  If `{required argument count}` is not empty, `{\command}` may take
    one optional argument in square brackets. Furthermore, it expects
    exactly `{required argument count}` following arguments.

Example:

    \tikzset{external/optimize command away=\includegraphics}

    \newcommand{\myExpensiveMacro}[1]{Very expensive!}

    \tikzset{external/optimize command away=\myExpensiveMacro}

    \newcommand{\myExpensiveMacroWithThreeArgs}[3]{Very expensive!}

    \tikzset{external/optimize command away={\myExpensiveMacroWithThreeArgs}{3}}

    % A command with optional argument:
    \newcommand{\aFurtherExample}[3][]{Very expensive!}

    % consume only two arguments: the first optional one will be processed
    % anyway:
    \tikzset{external/optimize command away={\myExpensiveMacroWithThreeArgs}{2}}

The argument ⟨\\command⟩ must be the name of a single macro. Any
occurrence of this macro, together with its arguments, will be removed.

    \begin{tikzpicture}
        % this picture is currently converted!
    \end{tikzpicture}

    This here is outside of the converted picture and contains \myExpensiveMacro. It will be discarded.

    This call: \myExpensiveMacro[argument=value]{Argument} as well.
    And this here: \myExpensiveMacro{Argument} also.

The default is to optimize `\includegraphics` away.

This key is actually a style which sets the `optimize/install` and
`optimize/restore` keys.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/optimize:command:away",
      meta = "⟨\\command⟩{required argument count}"
    },
    ["external/optimize/install"] = {
      details = [[
A command key which contains code to install optimizations. You can
append code here (or clear the macro) if you need to modify the
optimization.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/optimize/install"
    },
    ["external/optimize/restore"] = {
      details = [[
A command key which contains code to undo optimizations. You can append
code here (or clear the macro) if you need to modify the optimization.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/optimize/restore"
    },
    ["external/prefix"] = {
      details = [[
A shortcut for `\tikzsetexternalprefix``{file name prefix}`, see below.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/prefix",
      meta = "{file name prefix}"
    },
    ["external/remake next"] = {
      details = [[
A variant of `force remake` which applies only to the next image.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/remake:next",
      meta = "{boolean}"
    },
    ["external/shell escape"] = {
      details = [[
Contains the command line option for `latex` which enables the
`\write18` feature. For TeX-Live, this is `-shell-escape`. For MiKTeX,
you should use `\tikzexternalize[shell escape=-enable-write18]`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/shell:escape",
      meta = "{command-line arg}"
    },
    ["external/system call"] = {
      details = [[
\[extlib:systemcall:option\] A template string used to generate system
calls. Inside of `{template}`, the macro `\image` can be used as
placeholder for the image which is about to be generated while
`\texsource` contains the main file name (in truth, it contains
`\input``{main file name}`, but that doesn't matter).

The default depends on the value of `\pgfsysdriver`. For
`pgfsys-pdftex.def`, it is

    \tikzset{external/system call={pdflatex \tikzexternalcheckshellescape -halt-on-error
        -interaction=batchmode -jobname "\image" "\texsource"}}

where `\tikzexternalcheckshellescape` inserts the value of the
configuration key `shell escape` if and only if the current document has
been typeset with `-shell-escape`[1].

Other drivers result in slightly different calls. There is support for
`lualatex`, `xelatex`, and `dvips`. The precise values are written to
the `.log` file as soon as you attempt to compile a document.

The argument `{template}` will be expanded using `\edef`, so any control
sequences will be expanded. During this evaluation, '`\\`' will result
in a normal backslash, '`\`'. Furthermore, double quotes '`"`', single
quotes '`’`', semicolons and dashes '`-`' will be made to normal
characters if any package uses them as macros. This ensures
compatibility with the `german` package, for example.

[1] Note that this is always true for the default configuration. This
security consideration applies mainly for `mode=list and make` which
will also work *without* shell escapes.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/system:call",
      meta = "{template}"
    },
    ["external/up to date check"] = {
      details = [[
The `external` lib has to decide when some existing figure is
up-to-date. In such a case, it can be used without remaking it. Outdated
pictures will be remade.

The key `up to date check` allows to choose among a couple of heuristics
which are supposed to catch the most important reasons to remake a
figure.

The `up to date check` can be overrule by any of the `force remake` or
`remake next` keys: if one of them is true, the figure is not
up-to-date.

The choice simple is based on the existence of the file: the file is
up-to-date if and only if it exists.

The choice md5 generates an MD5 checksum of the picture for which the
up-to-date check is running. The MD5 is compared against the MD5 of the
previous run, which, in turn, will be written into an extra file with
the extension `.md5`. This file will be modified if and only if the MD5
comparison indicates a difference. The MD5 computation is based on the
pdfTeX method `\pdfmdfivesum`. If it is unavailable for some reason, the
choice `diff` will be used instead.

The choice diff is the same as MD5 -- except that it compares the
picture content as-is instead of a hash. The `.md5` file will be used to
compare an old version with the current one -- but its content is some
"normalized" version of the picture for internal use.

#### Attention:

the content--based strategies `md5` and `diff` operate on the picture
content -- and only on the picture content. Here, "picture content" only
includes the top--level tokens; no expansion is applied and no included
files are part of the strategies. If you change preamble styles, you
have to rebuild the figures manually (for example by deleting the
generated graphics files). If you have include files, consider using
`\tikzpicturedependsonfile` and its variants. Since this key provides
heuristics, you should always remake your figures before you finally
publish your document. Example: Suppose we have the following picture
which depends on a command `\mycommand`:

    \def\mycommand{My comment}

    \begin{tikzpicture}

    \node at (0,0) {\mycommand};

    \end{tikzpicture}

What happens if you change "My comment" to "My super comment"? Well,
`external` will *not* pick it up; you will need to handle this manually.
However, if you modify anything between `\begin{tikzpicture}` and
`\end{tikzpicture}`, the `external` library *will* pick it up and
regenerate the picture.

The `up to date check` is applied for `mode=convert with system call`
and `mode=list and make`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/up:to:date:check",
      meta = "{choice}"
    },
    ["external/verbose"] = {
      details = [[
Sets all verbosity flags to ⟨boolean⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/verbose",
      meta = "{boolean}"
    },
    ["external/verbose IO"] = {
      details = [[
A boolean which configures whether I/O operations shall be listed in the
logfile.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/verbose:IO",
      meta = "{boolean}"
    },
    ["external/verbose optimize"] = {
      details = [[
A boolean which configures whether optimization operations shall be
listed in the logfile.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/external/verbose:optimize",
      meta = "{boolean}"
    },
    ["extra concept"] = {
      details = [[
This style is intended for concepts that are not part of the "mindmap
tree", but stand beside it. Typically, they will have a subdued color or
be smaller. In order to have these concepts appear in a uniform way and
in order to indicate in the code that these concepts are additional, you
can use this style.

    \begin{tikzpicture}[mindmap,concept color=blue!80]
      \node [concept]                 {Root concept};
      \node [extra concept] at (10,0) {extra concept};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/extra:concept"
    },
    ["face 1"] = {
      details = [[
The ⟨code⟩ is executed for the first face of the dodecahedron. When it
is executed, the coordinate system will have been shifted and rotated
such that it lies at the middle of the first face of the dodecahedron.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/face:1",
      meta = "⟨code⟩"
    },
    ["face 2"] = {
      details = [[
Same as `face 1`, but for the second face.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/face:2",
      meta = "⟨code⟩"
    },
    ["face 3"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/face:3",
      meta = "⟨code⟩"
    },
    ["face 4"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/face:4",
      meta = "⟨code⟩"
    },
    ["fading angle"] = {
      details = [[
A shortcut for `fading transform={rotate=`⟨degree⟩`}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/fading:angle",
      meta = "⟨degree⟩"
    },
    ["fading transform"] = {
      details = [[
The ⟨transformation options⟩ are applied to the fading before it is
used. For instance, if ⟨transformation options⟩ is set to `rotate=90`,
the fading is rotated by 90 degrees.

    \begin{tikzpicture}[path fading=fade down]
      % Checker board
      \fill [black!20] (0,0) rectangle (4,1.5);
      \path [pattern=checkerboard,pattern color=black!30] (0,0) rectangle (4,1.5);

      \fill [red,path fading,fading transform={rotate=90}]
        (1,0.75) ellipse (.75 and .5);
      \fill [red,path fading,fading transform={rotate=30}]
        (3,0.75) ellipse (.75 and .5);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/fading:transform",
      meta = "⟨transformation options⟩"
    },
    fill = {
      details = [[
This option causes the path to be filled. All unclosed parts of the path
are first closed, if necessary. Then, the area enclosed by the path is
filled with the current filling color, which is either the last color
set using the general `color=` option or the optional color ⟨color⟩. For
self-intersection paths and for paths consisting of several closed
areas, the "enclosed area" is somewhat complicated to define and two
different definitions exist, namely the nonzero winding number rule and
the even odd rule, see the explanation of these options, below.

Just as for the `draw` option, setting ⟨color⟩ to `none` disables
filling locally.

    \begin{tikzpicture}
      \fill (0,0) -- (1,1) -- (2,1);
      \fill (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
      \fill[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
      \fill (8,0) -- (9,1) -- (10,0) circle (.5cm);
    \end{tikzpicture}

If the `fill` option is used together with the `draw` option (either
because both are given as options or because a `\filldraw` command is
used), the path is filled *first*, then the path is drawn *second*. This
is especially useful if different colors are selected for drawing and
for filling. Even if the same color is used, there is a difference
between this command and a plain `fill`: A "filldrawn" area will be
slightly larger than a filled area because of the thickness of the
"pen".

    \begin{tikzpicture}[fill=yellow!80!black,line width=5pt]
      \filldraw (0,0) -- (1,1) -- (2,1);
      \filldraw (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
      \filldraw[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
      \filldraw (8,0) -- (9,1) -- (10,0) circle (.5cm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/fill",
      meta = "⟨color⟩"
    },
    ["fill opacity"] = {
      details = [[
This option sets the opacity of fillings. In addition to filling
operations, this opacity also applies to text and images.

Note, again, that when you use PostScript as your output format, this
option works only with recent versions of Ghostscript.

    \begin{tikzpicture}[thick,fill opacity=0.5]
      \filldraw[fill=red]   (0:1cm)    circle (12mm);
      \filldraw[fill=green] (120:1cm)  circle (12mm);
      \filldraw[fill=blue]  (-120:1cm) circle (12mm);
    \end{tikzpicture}

    \begin{tikzpicture}
      \fill[red] (0,0) rectangle (3,2);

      \node                   at (0,0) {\huge A};
      \node[fill opacity=0.5] at (3,2) {\huge B};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/fill:opacity",
      meta = "⟨value⟩"
    },
    fit = {
      details = [[
This option must be given to a `node` path command. The ⟨coordinates or
nodes⟩ should be a sequence of TikZ coordinates or node names, one
directly after the other without commas (like with the
`plot coordinates` path operation). Examples are `(1,0) (2,2)` or
`(a) (1,0) (b)`, where `a` and `b` are nodes.

For this sequence of coordinates, a minimal bounding box is computed
that encompasses all the listed ⟨coordinates or nodes⟩. For coordinates
in the list, the bounding box is guaranteed to contain this coordinate,
for nodes it is guaranteed to contain the `east`, `west`, `north` and
`south` anchors of the node. In principle (the details will be explained
in a moment), things are now set up such that the text box of the node
will be exactly this bounding box.

Here is an example: We fit several points in a rectangular node. By
setting the `inner sep` to zero, we see exactly the text box of the
node. Then we fit these points again in a circular node. Note how the
circle encompasses exactly the same bounding box.

    \begin{tikzpicture}[inner sep=0pt,thick,
                        dot/.style={fill=blue,circle,minimum size=3pt}]
      \draw[help lines] (0,0) grid (3,2);
      \node[dot] (a) at (1,1) {};
      \node[dot] (b) at (2,2) {};
      \node[dot] (c) at (1,2) {};
      \node[dot] (d) at (1.25,0.25) {};
      \node[dot] (e) at (1.75,1.5) {};

      \node[draw=red,   fit=(a) (b) (c) (d) (e)] {box};
      \node[draw,circle,fit=(a) (b) (c) (d) (e)] {};
    \end{tikzpicture}

Every time the `fit` option is used, the following style is also applied
to the node:

The exact effects of the `fit` option are the following:

1.  A minimal bounding box containing all coordinates is computed. Note
    that if a coordinate like `(a)` is used that contains a node name,
    this has the same effect as explicitly providing the `(a.north)` and
    `(a.south)` and `(a.west)` and `(a.east)`. If you wish to refer only
    to the center of the `a` node, use `(a.center)` instead.

2.  The `text width` option is set to the width of this bounding box.

3.  The `align=center` option is set.

4.  The `anchor` is set to `center`.

5.  The `at` position of the node is set to the center of the computed
    bounding box.

6.  After the node has been typeset, its height and depth are adjusted
    such that they add up to the height of the computed bounding box and
    such that the text of the node is vertically centered inside the
    box.

The above means that, generally speaking, if the node contains text like
`box` in the above example, it will be centered inside the box. It will
be difficult to put the text elsewhere, in particular, changing the
`anchor` of the node will not have the desired effect. Instead, what you
should do is to create a node with the `fit` option that does not
contain any text, give it a name, and then use normal nodes to add text
at the desired positions. Alternatively, consider using the `label` or
`pin` options.

Suppose, for instance, that in the above example we want the word "box"
to appear inside the box, but at its top. This can be achieved as
follows:

    \begin{tikzpicture}[inner sep=0pt,thick,
                        dot/.style={fill=blue,circle,minimum size=3pt}]
      \draw[help lines] (0,0) grid (3,2);
      \node[dot] (a) at (1,1) {};
      \node[dot] (b) at (2,2) {};
      \node[dot] (c) at (1,2) {};
      \node[dot] (d) at (1.25,0.25) {};
      \node[dot] (e) at (1.75,1.5) {};

      \node[draw=red,fit=(a) (b) (c) (d) (e)] (fit) {};
      \node[below] at (fit.north) {box};
    \end{tikzpicture}

Here is a real-life example that uses fitting:

    \begin{tikzpicture}
      [vertex/.style={minimum size=2pt,fill,draw,circle},
       open/.style={fill=none},
       sibling distance=1.5cm,level distance=.75cm,
       every fit/.style={ellipse,draw,inner sep=-2pt},
       leaf/.style={label={[name=#1]below:$#1$}},auto]

      \node [vertex] (root) {}
      child { node [vertex,open] {}
        child { node [vertex,open] {}
          child { node [vertex] (b's parent) {}
            child { node [vertex] {}
              child { node [vertex,leaf=d] {} }
              child { node [vertex,leaf=e] {} } }
            child { node [vertex,leaf=b] {} } }
          child { node [vertex,leaf=a] {} } }
        child { node [coordinate] {}
          child[missing]
          child { node [vertex] (f's parent) {}
            child { node [vertex,leaf=c] {} }
            child { node [vertex,leaf=f] {} } } }
        edge from parent node {$\rho$} };

      \node [fit=(d) (e) (b) (b's parent),label=above left:$F^{(b,R)}$] {};
      \node [fit=(c) (f) (f's parent),label=above right:$F^{(c,R)}$]    {};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/fit",
      meta = "⟨coordinates or nodes⟩"
    },
    ["fit fading"] = {
      details = [[
When set to `true`, the fading is shifted and resized (in exactly the
same way as a shading) so that it covers the current path. When set to
`false`, the fading is only shifted so that it is centered on the path's
center, but it is not resized. This can be useful for special-purpose
fadings, for instance when you use a fading to "punch out" something.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/fit:fading",
      meta = "⟨boolean⟩"
    },
    ["folding line length"] = {
      details = [[
Sets the length of the base line for folding. For the dodecahedron this
is the length of all the sides of the pentagons.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/folding:line:length",
      meta = "⟨dimension⟩"
    },
    font = {
      details = [[
Sets the font used for the text inside nodes. However, this font will
*not* (yet) be installed when any of the dimensions of the node are
being computed, so dimensions like `1em` will be with respect to the
font used outside the node (usually the font that was in force when the
picture started).

    \begin{tikzpicture}
      \node [font=\itshape] {italic};
    \end{tikzpicture}

    \tikz \node [font=\tiny,  minimum height=3em, draw] {tiny};
    \tikz \node [font=\small, minimum height=3em, draw] {small};

A useful example of how the `font` option can be used is the following:

    \tikz [every text node part/.style={font=\itshape},
           every lower node part/.style={font=\footnotesize}]
      \node [circle split,draw] {state \nodepart{lower} output};

As can be seen, the font can be changed for each node part. This does
*not* work with the `node font` command since, as the name suggests,
this command can only be used to select the "overall" font for the node
and this is done very early.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/font",
      meta = "⟨font commands⟩"
    },
    framed = {
      details = [[
This is a shorthand for `show background rectangle`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/framed"
    },
    ["general shadow"] = {
      details = [[
This option should be given to a `\path` or a `node`. It has the
following effect: Before the path is used normally, it is used once with
the ⟨shadow options⟩ in force. Furthermore, when the path is "preused"
in this way, it is shifted and scaled a little bit.

In detail, the following happens: A `preaction` is used to paint the
path in a special manner before it is actually painted. This "special"
manner is as follows: The options in ⟨shadow options⟩ are used for
painting this path. Typically, the ⟨shadow options⟩ will contain options
like `fill=black` to create, say, a black shadow. Furthermore, after the
⟨shadow options⟩ have been set up, the following extra canvas
transformations are applied to the path: It is scaled by `shadow scale`
(with the origin of scaling at the path's center) and it is shifted by
`shadow xshift` and `shadow yshift`.

Note that since scaling and shifting is done using canvas
transformations, shadows are not taken into account when the picture's
bounding box is computed.

    \tikz [even odd rule]
      \draw [general shadow={fill=red}] (0,0) circle (.5) (0.5,0) circle (.5);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/general:shadow",
      meta = "⟨shadow options⟩"
    },
    ["graph/level"] = {
      details = [[
This key gets executed for each newly created node with ⟨level⟩ set to
the current level of the node. You can use this key to, say, reconfigure
the node distance or the node color.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graph/level",
      meta = "⟨level⟩"
    },
    ["graph/level ⟨level⟩"] = {
      details = [[
This key also gets executed for each newly created node with ⟨level⟩ set
to the current level of the node.

    \tikz \graph [
      branch down=5mm,
      level 1/.style={nodes=red},
      level 2/.style={nodes=green!50!black},
      level 3/.style={nodes=blue}]
    {
      a -> {
        b,
        c -> {
          d,
          e -> {f,g},
          h
        },
        j
      }
    };

    \tikz \graph [
      branch down=5mm,
      level 1/.style={grow right=2cm},
      level 2/.style={grow right=1cm},
      level 3/.style={grow right=5mm}]
    {
      a -> {
        b,
        c -> {
          d,
          e -> {f,g},
          h
        },
        j
      }
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graph/level:⟨level⟩"
    },
    ["graph/parse"] = {
      details = [[
This key can only be used inside the ⟨options⟩ of a ⟨group
specification⟩. Its effect is that the ⟨text⟩ is inserted at the
beginning of the current group as if you had entered it there.
Naturally, it makes little sense to just write down some static ⟨text⟩
since you could just as well directly place it at the beginning of the
group. The real power of this command stems from the fact that the keys
mechanism allows you to say, for instance, `parse/.expand once` to
insert the text stored in some macro into the group.

    \def\mychain{ a -> b -> c; }
    \tikz \graph { [parse/.expand once=\mychain] d -> e };

In the following, more fancy example we use a loop to create a chain of
dynamic length.

    \def\mychain#1{
      \def\mytext{1}
      \foreach \i in {2,...,#1} {
        \xdef\mytext{\mytext -> \i}
      }
    }
    \tikzgraphsset{my chain/.style={
        /utils/exec=\mychain{#1},
        parse/.expand once=\mytext}
    }
    \tikz \graph { [my chain=4] };

Multiple uses of this key accumulate, that is, all the texts given in
the different uses is inserted in the order it is given.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/graph/parse",
      meta = "⟨text⟩"
    },
    gridded = {
      details = [[
This is a shorthand for `show background grid`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/gridded"
    },
    grow = {
      details = [[
This key is used to define the ⟨direction⟩ in which the tree will grow.
The ⟨direction⟩ can either be an angle in degrees or one of the
following special text strings: `down`, `up`, `left`, `right`, `north`,
`south`, `east`, `west`, `north east`, `north west`, `south east`, and
`south west`. All of these have "their obvious meaning", so, say,
`south west` is the same as the angle $-135^\circ$.

As a side effect, this option installs the default growth function.

In addition to setting the direction, this option also has a seemingly
strange effect: It sets the sibling distance for the current level to
`0pt`, but leaves the sibling distance for later levels unchanged.

This somewhat strange behavior has a highly desirable effect: If you
give this option before the list of children of a node starts, the
"current level" is still the parent level. Each child will be on a later
level and, hence, the sibling distance will be as specified originally.
This will cause the children to be neatly aligned in a line orthogonal
to the given ⟨direction⟩. However, if you give this option locally to a
single child, then "current level" will be the same as the child's
level. The zero sibling distance will then cause the child to be placed
exactly at a point at distance `level distance` in the direction
⟨direction⟩. However, the children of the child will be placed
"normally" on a line orthogonal to the ⟨direction⟩.

These placement effects are best demonstrated by some examples:

    \tikz \node {root} [grow=right] child child;

    \tikz \node {root} [grow=south west] child child;

    \begin{tikzpicture}[level distance=10mm,sibling distance=5mm]
      \node {root}
        [grow=down]
        child
        child
        child[grow=right] {
          child child child
        };
    \end{tikzpicture}

    \begin{tikzpicture}[level distance=2em]
      \node {C}
        child[grow=up]    {node {H}}
        child[grow=left]  {node {H}}
        child[grow=down]  {node {H}}
        child[grow=right] {node {C}
            child[grow=up]    {node {H}}
            child[grow=right] {node {H}}
            child[grow=down]  {node {H}}
          edge from parent[double]
            coordinate (wrong)
        };
      \draw[<-,red] ([yshift=-2mm]wrong) -- +(0,-1)
        node[below]{This is wrong!};
    \end{tikzpicture}

    \begin{tikzpicture}
      \node[rectangle,draw] (a) at (0,0) {start node};
      \node[rectangle,draw] (b) at (2,1) {end};

      \draw (a) -- (b)
        node[coordinate,midway] {}
          child[grow=100,<-] {node[above] {the middle is here}};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/grow",
      meta = "⟨direction⟩"
    },
    ["grow cyclic"] = {
      details = [[
This style causes the children to be arranged "on a circle". For this,
the children are placed at distance `\tikzleveldistance` from the parent
node, but not on a straight line, but on points on a circle. Instead of
a sibling distance, there is a `sibling angle` that denotes the angle
between two given children.

Note that this function will rotate the coordinate system of the
children to ensure that the grandchildren will grow in the right
direction.

    \begin{tikzpicture}
      [grow cyclic,
       level 1/.style={level distance=8mm,sibling angle=60},
       level 2/.style={level distance=4mm,sibling angle=45},
       level 3/.style={level distance=2mm,sibling angle=30}]
      \coordinate [rotate=-90] % going down
        child foreach \x in {1,2,3}
          {child foreach \x in {1,2,3}
            {child foreach \x in {1,2,3}}};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/grow:cyclic"
    },
    ["grow via three points"] = {
      details = [[
This option installs a growth function that works as follows: If a
parent node has just one child, this child is placed at ⟨x⟩. If the
parent node has two children, these are placed at ⟨y⟩ and ⟨z⟩. If the
parent node has more than two children, the children are placed at
points that are linearly extrapolated from the three points ⟨x⟩, ⟨y⟩,
and ⟨z⟩. In detail, the position is $x + \frac{n-1}{2}(y-x) +
    (c-1)(z-y)$, where $n$ is the number of children and $c$ is the
number of the current child (starting with $1$).

The net effect of all this is that if you have a certain "linear
arrangement" in mind and use this option to specify the placement of a
single child and of two children, then any number of children will be
placed correctly.

Here are some arrangements based on this growth function. We start with
a simple "above" arrangement:

    \begin{tikzpicture}[grow via three points={%
        one child at (0,1) and two children at (-.5,1) and (.5,1)}]
      \node at (0,0) {one} child;
      \node at (0,-1.5) {two} child child;
      \node at (0,-3) {three} child child child;
      \node at (0,-4.5) {four} child child child child;
    \end{tikzpicture}

The next arrangement places children above, but "grows only to the
right".

    \begin{tikzpicture}[grow via three points={%
        one child at (0,1) and two children at (0,1) and (1,1)}]
      \node at (0,0) {one} child;
      \node at (0,-1.5) {two} child child;
      \node at (0,-3) {three} child child child;
      \node at (0,-4.5) {four} child child child child;
    \end{tikzpicture}

In the final arrangement, the children are placed along a line going
down and right.

    \begin{tikzpicture}[grow via three points={%
        one child at (-1,-.5) and two children at (-1,-.5) and (0,-.75)}]
      \node at (0,0) {one} child;
      \node at (0,-1.5) {two} child child;
      \node at (0,-3) {three} child child child;
      \node at (0,-4.5) {four} child child child child;
    \end{tikzpicture}

These examples should make it clear how you can create new styles to
arrange your children along a line.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/grow:via:three:points",
      meta = "one child at (⟨x⟩ ) and two children at (⟨y⟩) and (⟨z⟩)"
    },
    ["grow'"] = {
      details = [[
This key has the same effect as `grow`, only the children are arranged
in the opposite order.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/grow'",
      meta = "⟨direction⟩"
    },
    ["growth function"] = {
      details = [[
This rather low-level option allows you to set a new growth function.
The ⟨macro name⟩ must be the name of a macro without parameters. This
macro will be called for each child of a node. The initial function is
an internal function that corresponds to downward growth.

The effect of executing the macro should be the following: It should
transform the coordinate system in such a way that the origin becomes
the place where the current child should be anchored. When the macro is
called, the current coordinate system will be set up such that the
anchor of the parent node is in the origin. Thus, in each call, the
⟨macro name⟩ must essentially do a shift to the child's origin. When the
macro is called, the TeX counter `\tikznumberofchildren` will be set to
the total number of children of the parent node and the counter
`\tikznumberofcurrentchild` will be set to the number of the current
child.

The macro may, in addition to shifting the coordinate system, also
transform the coordinate system further. For example, it could be
rotated or scaled.

Additional growth functions are defined in the library, see Section ??.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/growth:function",
      meta = "⟨macro name⟩"
    },
    ["growth parent anchor"] = {
      details = [[
This key allows you to specify which anchor of the parent node is to be
used for computing the children's position. For example, when there is
only one child and the `level distance` is `2cm`, then the child node
will be placed two centimeters below the ⟨anchor⟩ of the parent node.
"Being placed" means that the child node's anchor (which is the anchor
specified using the `anchor=` option in the `node` command of the child)
is two centimeters below the parent node's ⟨anchor⟩.

In the following example, the two red lines both have length `1cm`.

    \begin{tikzpicture}[level distance=1cm]
      \node [rectangle,draw] (a) at (0,0) {root}
      [growth parent anchor=south] child;

      \node [rectangle,draw] (b) at (2,0) {root}
      [growth parent anchor=north east] child;

      \draw [red,thick,dashed] (a.south) -- (a-1);
      \draw [red,thick,dashed] (b.north east) -- (b-1);
    \end{tikzpicture}

In the next example, the top and bottom nodes are aligned at the top and
the bottom, respectively.

    \begin{tikzpicture}
      [level distance=2cm,growth parent anchor=north,
       every node/.style={anchor=north,rectangle,draw}
       every child node/.style={anchor=south}]

      \node at (0,0) {root} child {node {small}};

      \node at (2,0) {big root} child {node {\large big}};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/growth:parent:anchor",
      meta = "⟨anchor⟩"
    },
    ["handle active characters in code"] = {
      details = [[
When this key is set, at the beginning of every `\tikz` command and
every `{tikzpicture}`, the character codes of all symbols used by
TikZ are reset to their normal values. Furthermore, at the beginning of
each node, the catcodes are restored to the values they had prior to the
current picture.

The net effect of this is that, in most cases, symbols having a special
character code can be used nicely both in TikZ code and also in node
texts.

In the following, slightly silly, example we make the dot an active
character and define it in some strange way. Now, in the later
TikZ command, the dot in `3.0cm` may no longer be active and setting the
`handle...` option achieves exactly this. However, as can be seen, the
dot is once more active inside the node.

    \catcode`\.=\active
    \def.{\o}

    \tikz [handle active characters in code]
      \node [draw, minimum width=3.0cm] {hall. pe.ple};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/handle:active:characters:in:code",
      meta = "⟨true or false⟩"
    },
    ["handle active characters in nodes"] = {
      details = [[
This key is needed for a special situation: As explained for the
`handle ... code` key, that key switches off all special meaning of
symbols and switches them back on again at the beginning of nodes.
However, there is one situation when this is not possible: When some
text has already been read by TeX, the catcodes can no longer change.
Now, for normal nodes this is not a problem since their contents has not
been read at the moment the catcodes are restored. In contrast for label
nodes for edges, nodes produced by the `graph` and `quotes` libraries,
and some others nodes, their text *has* already been read when the
catcodes get adjusted.

The present key may help in such situations: It causes the text of all
such "indirectly created" nodes to be surrounded by a call to the
`\scantokens` command. This command attempts to reread an already read
text, but allows catcodes to change. As users of this command will know,
it is not a perfect substitute for directly reading the text by TeX, but
it normally has the desired effect.

    \catcode`\.=\active
    \def.{\o}

    \tikz [handle active characters in code,
           handle active characters in nodes]
      \node [draw, label=f..] {hall. pe.ple};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/handle:active:characters:in:nodes",
      meta = "⟨true or false⟩"
    },
    height = {
      details = [[
Inside a `spy scope`, this is a shortcut for `minimum height`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/height",
      meta = "⟨dimension⟩"
    },
    ["help lines"] = {
      details = [[
This style makes lines "subdued" by using thin gray lines for them.
However, this style is not installed automatically and you have to say
for example:

    \tikz \draw[help lines] (0,0) grid (3,3);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/help:lines"
    },
    ["huge circuit symbols"] = {
      details = [[
This style sets the default circuit symbol unit to `10pt`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/huge:circuit:symbols"
    },
    ["huge mindmap"] = {
      details = [[
This style causes concepts to be even bigger and it is best used with A2
paper and above.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/huge:mindmap"
    },
    id = {
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/id",
      meta = "⟨id⟩"
    },
    ["if"] = {
      details = [[
This option has the same effect as giving a corresponding if in the
⟨calendar specification⟩. The option is mostly useful for use in the
`every calendar` style, where you cannot provide if conditionals
otherwise.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/if",
      meta = "(⟨conditions⟩)⟨code or options⟩else⟨else code or options⟩"
    },
    ["in"] = {
      details = [[
The angle at which the curve reaches the target coordinate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/in",
      meta = "⟨angle⟩"
    },
    ["in control"] = {
      details = [[
This option causes the ⟨coordinate⟩ to be used as the target control
point. You can use a coordinate like `+(1,0)` to specify a point
relative to the *end* coordinate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/in:control",
      meta = "⟨coordinate⟩"
    },
    ["in distance"] = {
      details = [[
Sets the minimum and maximum in distance.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/in:distance",
      meta = "⟨distance⟩"
    },
    ["in front of path"] = {
      details = [[
This is the opposite of `behind path`: It causes nodes to be drawn on
top of the path. Since this is the default behavior, you usually do not
need this option; it is only needed when an enclosing scope has used
`behind path` and you now wish to "switch back" to the normal behavior.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/in:front:of:path"
    },
    ["in looseness"] = {
      details = [[
Specifies the looseness factor for the in distance only.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/in:looseness",
      meta = "⟨number⟩"
    },
    ["in max distance"] = {
      details = [[
The maximum distance set only for the target coordinate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/in:max:distance",
      meta = "⟨distance⟩"
    },
    ["in min distance"] = {
      details = [[
The minimum distance set only for the target coordinate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/in:min:distance",
      meta = "⟨distance⟩"
    },
    info = {
      details = [[
This key has nearly the same effect as the `label` key, only the
following style is used additionally automatically:

The ⟨options⟩ and ⟨angle⟩ are passed directly to the `label` command.

    \begin{tikzpicture}[circuit ee IEC,every info/.style=red]
      \node [resistor,info=$3\Omega$] {};
    \end{tikzpicture}

You will find a detailed discussion of the `label` option on page ??.

Hint: To place some text *on* the main node, use `center` as the
⟨angle⟩:

    \begin{tikzpicture}[circuit ee IEC,every info/.style=red]
      \node [resistor,info=center:$3\Omega$] {};
      \node [resistor,point up,info=center:$R_1$] at (2,0) {};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/info",
      meta = "[⟨options⟩]⟨angle⟩:⟨text⟩"
    },
    ["info sloped"] = {
      details = [[
This key works like `info`, only the `transform shape` option is set
when the label is drawn, causing it to follow the sloping of the main
node.

    \begin{tikzpicture}[circuit ee IEC,every info/.style=red]
      \draw (0,0) to[resistor={info sloped={$3\Omega$}}] (3,0)
                  to[resistor={info sloped={$4\Omega$}}] (3,2);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/info:sloped",
      meta = "[⟨options⟩]⟨angle⟩:⟨text⟩"
    },
    ["info'"] = {
      details = [[
This key works exactly like the `info` key, only in case the ⟨angle⟩ is
missing, it defaults to `below` instead of the current value of
`label position`, which is usually `above`. This means that when you use
`info`, you get a label above the node, while when you use the `info’`
key you get a label below the node. In case the node has been rotated,
the positions of the info nodes are rotated accordingly.

    \begin{tikzpicture}[circuit ee IEC,every info/.style=red]
      \draw (0,0) to[resistor={info={$3\Omega$},info'={$R_1$}}] (3,0)
                  to[resistor={info={$4\Omega$},info'={$R_2$}}] (3,2);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/info'",
      meta = "[⟨options⟩]⟨angle⟩:⟨text⟩"
    },
    ["info' sloped"] = {
      details = [[
This is a combination of `info’` and `info sloped`.

    \begin{tikzpicture}[circuit ee IEC,every info/.style=red]
      \draw (0,0) to[resistor={info' sloped={$3\Omega$}}] (3,0)
                  to[resistor={info' sloped={$4\Omega$}}] (3,2);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/info':sloped",
      meta = ""
    },
    initial = {
      details = [[
This style is used to draw initial states.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/initial"
    },
    ["initial above"] = {
      details = [[
This is a shorthand for `initial by arrow,initial where=above`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/initial:above"
    },
    ["initial below"] = {
      details = [[
Works similarly to the previous option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/initial:below"
    },
    ["initial by arrow"] = {
      details = [[
This style causes an arrow and, possibly, some text to be added to the
node. The arrow points from the text to the node. The node text and the
direction and the distance can be set using the following key:

    \begin{tikzpicture}[every initial by arrow/.style={text=red,->>}]
      \node[state,initial,initial distance=2cm] {$q_0$};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/initial:by:arrow"
    },
    ["initial by diamond"] = {
      details = [[
This style uses a diamond to indicate an initial node.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/initial:by:diamond"
    },
    ["initial distance"] = {
      details = [[
Sets the length of the arrow leading from the text to the state node.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/initial:distance",
      meta = "⟨distance⟩"
    },
    ["initial left"] = {
      details = [[
Works similarly to the previous option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/initial:left"
    },
    ["initial right"] = {
      details = [[
Works similarly to the previous option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/initial:right"
    },
    ["initial text"] = {
      details = [[
This key sets the text to be used. Use an empty text to suppress all
text.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/initial:text",
      meta = "⟨text⟩"
    },
    ["initial where"] = {
      details = [[
Set the place where the text should be shown. Allowed values are
`above`, `below`, `left`, and `right`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/initial:where",
      meta = "⟨direction⟩"
    },
    ["inner color"] = {
      details = [[
This option sets the color used at the center of a `radial` shading.
When this option is used, the `shade` and `shading=radial` options are
set.

    \tikz \draw[inner color=red] (0,0) rectangle (2,1);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/inner:color",
      meta = "⟨color⟩"
    },
    ["inner frame sep"] = {
      details = [[
Sets the horizontal and vertical separator distances simultaneously.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/inner:frame:sep",
      meta = "⟨dimension⟩"
    },
    ["inner frame xsep"] = {
      details = [[
Sets the additional horizontal separator distance for the background
rectangle.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/inner:frame:xsep",
      meta = "⟨dimension⟩"
    },
    ["inner frame ysep"] = {
      details = [[
Same for the vertical separator distance.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/inner:frame:ysep",
      meta = "⟨dimension⟩"
    },
    inputs = {
      details = [[
This key is defined only inside the scope of a `circuit logic`. There,
it has the same effect as `logic gate inputs`, described on page ??.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/inputs",
      meta = "⟨inputs⟩"
    },
    ["insert path"] = {
      details = [[
This key can be used inside an option to add something to the current
path. This is mostly useful for defining styles that create graphic
contents. This option should be used with care, for instance it should
not be used as an argument of, say, a `node`. In the following example,
we use a style to add little circles to a path.

    \tikz [c/.style={insert path={circle[radius=2pt]}}]
      \draw (0,0) -- (1,1) [c] -- (3,2) [c];

The effect is the same as of
`(0,0) – (1,1) circle[radius=2pt] – (3,2) circle[radius=2pt]`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/insert:path",
      meta = "⟨path⟩"
    },
    ["intersection/by"] = {
      details = [[
This key allows you to specify a list of names for the intersection
coordinates. The intersection coordinates will still be named
⟨prefix⟩`-`⟨number⟩, but additionally the first coordinate will also be
named by the first element of the ⟨comma-separated list⟩. What happens
is that the ⟨comma-separated list⟩ is passed to the `\foreach` statement
and for ⟨list member⟩ a coordinate is created at the already-named
intersection.

    \begin{tikzpicture}
      \clip (-2,-2) rectangle (2,2);
      \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
      \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

      \fill [name intersections={of=curve 1 and curve 2, by={a,b}}]
            (a) circle (2pt)
            (b) circle (2pt);
    \end{tikzpicture}

You can also use the `...` notation of the `\foreach` statement inside
the ⟨comma-separated list⟩.

In case an element of the ⟨comma-separated list⟩ starts with options in
square brackets, these options are used when the coordinate is created.
A coordinate name can still, but need not, follow the options. This
makes it easy to add labels to intersections:

    \begin{tikzpicture}
      \clip (-2,-2) rectangle (2,2);
      \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
      \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

      \fill [name intersections={
              of=curve 1 and curve 2,
              by={[label=center:a],[label=center:...],[label=center:i]}}];
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/intersection/by",
      meta = "⟨comma-separated list⟩"
    },
    ["intersection/name"] = {
      details = [[
This key specifies the prefix name for the coordinate nodes placed at
each intersection.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/intersection/name",
      meta = "⟨prefix⟩"
    },
    ["intersection/of"] = {
      details = [[
This key is used to specify the names of the paths to use for the
intersection.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/intersection/of",
      meta = "⟨name path 1⟩ and ⟨name path 2⟩"
    },
    ["intersection/sort by"] = {
      details = [[
By default, the intersections are simply returned in the order that the
intersection algorithm finds them. Unfortunately, this is not
necessarily a "helpful" ordering. This key can be used to sort the
intersections along the path specified by ⟨path name⟩, which should be
one of the paths mentioned in the `/tikz/intersection/of` key.

    \begin{tikzpicture}
    \clip (-0.5,-0.75) rectangle (3.25,2.25);
    \foreach \pathname/\shift in {line/0cm, curve/2cm}{
      \tikzset{xshift=\shift}
      \draw [->, name path=curve] (1,1.5) .. controls (-1,1) and (2,0.5) .. (0,0);
      \draw [->, name path=line]  (0,-.5) -- (1,2) ;
      \fill [name intersections={of=line and curve,sort by=\pathname, name=i}]
        [red, opacity=0.5, every node/.style={left=.25cm, black, opacity=1}]
        \foreach \s in {1,2,3}{(i-\s) circle (2pt) node {\footnotesize\s}};
    }
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/intersection/sort:by",
      meta = "⟨path name⟩"
    },
    ["intersection/total"] = {
      details = [[
This key means that the total number of intersections found will be
stored in ⟨macro⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/intersection/total",
      meta = "⟨macro⟩"
    },
    ["isometric view"] = {
      details = [[
A special kind of `3d view` is isometric, which can be set with the
`isometric view` style. It simply sets `3d view={-45}{35.26}`. The value
for ⟨elevation⟩ is determined with $\arctan(1/\sqrt{2})$. In isometric
projection the angle between any pair of axes is 120$^\circ$, as shown
below.

    \begin{tikzpicture}[isometric view]
      \draw[->] (-1,0,0) -- (1,0,0) node[pos=1.1]{x};
      \draw[->] (0,-1,0) -- (0,1,0) node[pos=1.1]{y};
      \draw[->] (0,0,-1) -- (0,0,1) node[pos=1.1]{z};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/isometric:view"
    },
    join = {
      details = [[
When this key is given to any node on a chain (except possibly for the
first node), an `edge` command is added after the node. The `with` part
specifies which node should be used for the start point of the edge; if
the `with` part is omitted, the `\tikzchainprevious` is used. This
`edge` command gets the ⟨options⟩ as parameter and the current node as
its target. If there is no previous node and no `with` is given, no
`edge` command gets executed.

Note that it makes sense to call this option several times for a node,
in order to connect it to several nodes. This is especially useful for
joining in branches, see the next section.

    \begin{tikzpicture}[start chain,node distance=5mm,
                        every join/.style={->,red}]
      \node [draw,on chain,join] {};
      \node [draw,on chain,join] {Hallo};
      \node [draw,on chain,join] {Welt};
      \node [draw,on chain=going below,
             join,join=with chain-1 by {blue,<-}] {foo};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/join",
      meta = "with ⟨with⟩ by ⟨options⟩"
    },
    ["jump mark left"] = {
      details = [[
This option causes the points on the path to be drawn using piecewise
constant, non-connected series of lines. If there are any marks, they
will be placed on left open ends:

    \tikz\draw plot[jump mark left, mark=*] file{plots/pgfmanual-sine.table};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/jump:mark:left"
    },
    ["jump mark mid"] = {
      details = [[
This option causes the points on the path to be drawn using piecewise
constant, non-connected series of lines. If there are any marks, they
will be placed in the middle of the horizontal line segments:

    \tikz\draw plot[jump mark mid, mark=*] file{plots/pgfmanual-sine.table};

In case of non-constant mesh widths, the same remarks as for
`const plot mark mid` apply.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/jump:mark:mid"
    },
    ["jump mark right"] = {
      details = [[
This option causes the points on the path to be drawn using piecewise
constant, non-connected series of lines. If there are any marks, they
will be placed on right open ends:

    \tikz\draw plot[jump mark right, mark=*] file{plots/pgfmanual-sine.table};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/jump:mark:right"
    },
    ["key attribute"] = {
      details = [[
This style is intended for key attributes. By default, the will cause
the attribute to be typeset in italics. Typically, underlining is used
instead, but that looks ugly and it is difficult to implement in TeX.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/key:attribute"
    },
    label = {
      details = [[
\[label-option\] When this option is given to a `node` operation, it
causes *another* node to be added to the path after the current node has
been finished. This extra node will have the text ⟨text⟩. It is placed,
in principle, in the direction ⟨angle⟩ relative to the main node, but
the exact rules are a bit complex. Suppose the `node` currently under
construction is called `main node` and let us call the label node
`label node`. Then the following happens:

1.  The ⟨angle⟩ is used to determine a position on the border of the
    `main node`. If the ⟨angle⟩ is missing, the value of the following
    key is used instead:

    The ⟨angle⟩ determines the position on the border of the shape in
    two different ways. Normally, the border position is given by
    `main node.`⟨angle⟩. This means that the ⟨angle⟩ can either be a
    number like `0` or `-340`, but it can also be an anchor like
    `north`. Additionally, the special angles `above`, `below`, `left`,
    `right`, `above left`, and so on are automatically replaced by the
    corresponding angles `90`, `270`, `180`, `0`, `135`, and so on.

    A special case arises when the following key is set:

2.  Then, an anchor point for the `label node` is computed. It is
    determined in such a way that the `label node` will "face away" from
    the border of the `main node`. The anchor that is chosen depends on
    the position of the border point that is chosen and its position
    relative to the center of the `main node` and on whether the
    `transform shape` option is set. In detail, when the computed border
    point is at $0^\circ$, the anchor `west` will be used. Similarly,
    when the border point is at $90^\circ$, the anchor `south` will be
    used, and so on for $180^\circ$ and $270^\circ$.

    For angles between these "major" angles, like $30^\circ$ or
    $110^\circ$, combined anchors, like `south west` for $30^\circ$ or
    `south east` for $110^\circ$, are used. However, for angles close to
    the major angles, (differing by up to $2^\circ$ from the major
    angle), the anchor for the major angle is used. Thus, a label at a
    border point for $2^\circ$ will have the anchor `west`, while a
    label for $3^\circ$ will have the anchor `south west`, resulting in
    a "jump" of the anchor. You can set the anchor "by hand" using the
    `anchor` key or indirect keys like `left`.

        \tikz
          \node [circle, draw,
                 label=default,
                 label=60:$60^\circ$,
                 label=below:$-90^\circ$,
                 label=3:$3^\circ$,
                 label=2:$2^\circ$,
                 label={[below]180:$180^\circ$},
                 label={[centered]135:$135^\circ$}] {my circle};

3.  One ⟨angle⟩ is special: If you set the ⟨angle⟩ to `center`, then the
    label will be placed on the center of the main node. This is mainly
    useful for adding a label text to an existing node, especially if it
    has been rotated.

        \tikz \node [transform shape,rotate=90,
                     rectangle,draw,label={[red]center:R}] {main node};

You can pass ⟨options⟩ to the node `label node`. For this, you provide
the options in square brackets before the ⟨angle⟩. If you do so, you
need to add braces around the whole argument of the `label` option and
this is also the case if you have brackets or commas or semicolons or
anything special in the ⟨text⟩.

    \tikz \node [circle,draw,label={[red]above:X}] {my circle};

    \begin{tikzpicture}
      \node [circle,draw,label={[name=label node]above left:$a,b$}] {};
      \draw (label node) -- +(1,1);
    \end{tikzpicture}

If you provide multiple `label` options, then multiple extra label nodes
are added in the order they are given.

The following styles influence how labels are drawn:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/label",
      meta = "[⟨options⟩]⟨angle⟩:⟨text⟩"
    },
    ["label distance"] = {
      details = [[
The ⟨distance⟩ is additionally inserted between the main node and the
label node.

    \tikz[label distance=5mm]
      \node [circle,draw,label=right:X,
                         label=above right:Y,
                         label=above:Z]       {my circle};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/label:distance",
      meta = "⟨distance⟩"
    },
    ["label position"] = {
      details = [[
Sets the default position for labels.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/label:position",
      meta = "⟨angle⟩"
    },
    ["large circuit symbols"] = {
      details = [[
This style sets the default circuit symbol unit to `8pt`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/large:circuit:symbols"
    },
    ["large mindmap"] = {
      details = [[
This style includes the `mindmap` style, but additionally changes the
default size of concepts, fonts and distances so that a medium-sized
mindmap will fit on an A3 page (A3 pages are twice as large as A4
pages).
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/large:mindmap"
    },
    ["late options"] = {
      details = [[
This option can be given on a path (but not as an argument to a `node`
path command) and has the same effect as the `node also` path command.
Inside the ⟨options⟩, you should use the `name` option to specify the
node for which you wish to add late options:

    \begin{tikzpicture}
      \node      [draw,circle]       (a) {Hello};
      \path [late options={name=a, label=above:world}];
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/late:options",
      meta = "⟨options⟩"
    },
    left = {
      details = [[
Similar to `above`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/left",
      meta = "⟨offset⟩"
    },
    ["left color"] = {
      details = [[
This option does exactly the same as `top color`, except that the
shading angle is set to $90^\circ$.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/left:color",
      meta = "⟨color⟩"
    },
    ["left delimiter"] = {
      details = [[
This option can be given to a any node that has the standard anchors
`north`, `south` and so on. The ⟨delimiter⟩ can be any delimiter that is
acceptable to TeX's `\left` command.

    \begin{tikzpicture}
      \matrix [matrix of math nodes,left delimiter=(,right delimiter=\}]
      {
        a_8 & a_1 & a_6 \\
        a_3 & a_5 & a_7 \\
        a_4 & a_9 & a_2 \\
      };
    \end{tikzpicture}

    \begin{tikzpicture}
      \node [fill=red!20,left delimiter=(,right delimiter=\}]
        {$\displaystyle\int_0^1 x\,dx$};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/left:delimiter",
      meta = "⟨delimiter⟩"
    },
    ["left of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/left:of",
      meta = "⟨node⟩"
    },
    lens = {
      details = [[
The ⟨options⟩ should contain transformation commands like `scale` or
`rotate`. These transformations are applied to the picture when it is
shown inside the spy-on node.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/lens",
      meta = "⟨options⟩"
    },
    level = {
      details = [[
This style is executed at the beginning of each set of children, where
⟨number⟩ is the current level in the current tree. For example, when you
say `\node {x} child child;`, then `level=1` is used before the first
`child`. The style or code of this key will be passed ⟨number⟩ as its
first parameter. If this first `child` has children itself, then
`level=2` would be used for them.

    \begin{tikzpicture}[level/.style={sibling distance=20mm/#1}]
      \node {root}
        child { child child }
        child { child child child };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/level",
      meta = "⟨number⟩"
    },
    ["level 1 concept"] = {
      details = [[
The `mindmap` style adds this style to the `level 1` style. This means
that the first level children of a mindmap tree will use this style.

    \tikz
      [root concept/.append style={concept color=blue!80},
       level 1 concept/.append style={concept color=red!50},
       mindmap]
      \node [concept] {Root concept}
        child[grow=30] {node[concept] {child}}
        child[grow=0 ] {node[concept] {child}};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/level:1:concept"
    },
    ["level 2 concept"] = {
      details = [[
Works like `level 1 concept`, only for second level children.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/level:2:concept"
    },
    ["level 3 concept"] = {
      details = [[
Works like `level 1 concept`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/level:3:concept"
    },
    ["level 4 concept"] = {
      details = [[
Works like `level 1 concept`. Note that there are no fifth and higher
level styles, you need to modify `level 5` directly in such cases.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/level:4:concept"
    },
    ["level distance"] = {
      details = [[
This key determines the distance between different levels of the tree,
more precisely, between the parent and the line on which its children
are arranged. When given to a single child, this will set the distance
for this child only.

    \begin{tikzpicture}
      \node {root}
        [level distance=20mm]
        child
        child {
          [level distance=5mm]
          child
          child
          child
        }
        child[level distance=10mm];
    \end{tikzpicture}

    \begin{tikzpicture}
      [level 1/.style={level distance=10mm},
       level 2/.style={level distance=5mm}]
      \node {root}
        child
        child {
          child
          child[level distance=10mm]
          child
        }
        child;
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/level:distance",
      meta = "⟨distance⟩"
    },
    ["level ⟨number⟩"] = {
      details = [[
This style is used in addition to the `level` style. So, when you say
`\node {x} child child;`, then the following key list is executed:
`level=1,level 1`.

    \begin{tikzpicture}
      [level 1/.style={sibling distance=20mm},
       level 2/.style={sibling distance=5mm}]
      \node {root}
        child { child child }
        child { child child child };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/level:⟨number⟩"
    },
    ["light emitting"] = {
      details = [[
Like a unit, an annotation should be given as an additional option to a
node. It causes some drawings (in this case, two parallel lines) to be
placed next to the node.

    \tikz [circuit ee IEC] \draw (0,0) to [diode=light emitting] (2,0);

The ⟨options⟩ can be used for three different things:

1.  You can use keys like `red` to change the appearance of this
    annotation, locally.

2.  You can use keys like `<-` or `-latex` to change the direction and
    kinds of arrows used in the annotation.

3.  You can use info labels like `ohm=5` or `info=foo` inside the
    ⟨options⟩. These info labels will be added to the main node (not to
    the annotation itself), but the label distance will have been
    changed to accommodate for the space taken up by the annotation.

        \tikz [circuit ee IEC]
        {
          \draw (0,2) to [diode={light emitting,info=not good}] (2,2);
          \draw (0,0) to [diode={light emitting={info=better},
                                 info'=also good}]  (2,0);
        }

In addition to `light emitting` there is also a key called
`light emitting’`, which simply places the annotation on the other side
of the node.

You can configure the appearance of annotations in three ways:

-   You can set the `every circuit annotation` style.

-   You can set the `every light emitting` style.

-   You can set the following key:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/light:emitting",
      meta = "⟨options⟩"
    },
    ["line cap"] = {
      details = [[
Specifies how lines "end". Permissible ⟨type⟩ are `round`, `rect`, and
`butt`. They have the following effects:

    \begin{tikzpicture}
      \begin{scope}[line width=10pt]
        \draw[line cap=round] (0,1 ) -- +(1,0);
        \draw[line cap=butt]  (0,.5) -- +(1,0);
        \draw[line cap=rect]  (0,0 ) -- +(1,0);
      \end{scope}
      \draw[white,line width=1pt]
        (0,0 ) -- +(1,0) (0,.5) -- +(1,0) (0,1 ) -- +(1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/line:cap",
      meta = "⟨type⟩"
    },
    ["line join"] = {
      details = [[
Specifies how lines "join". Permissible ⟨type⟩ are `round`, `bevel`, and
`miter`. They have the following effects:

    \begin{tikzpicture}[line width=10pt]
      \draw[line join=round] (0,0) -- ++(.5,1) -- ++(.5,-1);
      \draw[line join=bevel] (1.25,0) -- ++(.5,1) -- ++(.5,-1);
      \draw[line join=miter] (2.5,0) -- ++(.5,1) -- ++(.5,-1);
      \useasboundingbox (0,1.5); % enlarge bounding box
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/line:join",
      meta = "⟨type⟩"
    },
    ["line to"] = {
      details = [[
Causes a straight line to be added to the path upon a `to` or an `edge`
operation.

    \tikz {\draw (0,0) to[line to] (1,0);}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/line:to"
    },
    ["line width"] = {
      details = [[
Specifies the line width. Note the space.

      \tikz \draw[line width=5pt] (0,0) -- (1cm,1.5ex);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/line:width",
      meta = "⟨dimension⟩"
    },
    loop = {
      details = [[
This key is similar to the `curve to` key, but differs in the following
ways: First, the actual target coordinate is ignored and the start
coordinate is used as the target coordinate. Thus, it is allowed not to
provide any target coordinate, which can be useful with unnamed nodes.
Second, the `looseness` is set to `8` and the `min distance` to `5mm`.
These settings result in rather nice loops when the opening angle
(difference between `in` and `out`) is 30$^\circ$.

    \begin{tikzpicture}
      \node [circle,draw] {a} edge [in=30,out=60,loop] ();
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/loop"
    },
    ["loop above"] = {
      details = [[
Sets the `loop` style and sets in and out angles such that loop is above
the node. Furthermore, the `above` option is set, which causes a node
label to be placed at the correct position.

    \begin{tikzpicture}
      \node [circle,draw] {a} edge [loop above] node {x} ();
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/loop:above"
    },
    ["loop below"] = {
      details = [[
Works like the previous option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/loop:below"
    },
    ["loop left"] = {
      details = [[
Works like the previous option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/loop:left"
    },
    ["loop right"] = {
      details = [[
Works like the previous option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/loop:right"
    },
    ["loose background"] = {
      details = [[
Sets the inner frame separator to 2ex.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/loose:background"
    },
    ["loosely dash dot"] = {
      details = [[
Shorthand for setting a loosely dashed and dotted dash pattern.

    \tikz \draw[loosely dash dot] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/loosely:dash:dot"
    },
    ["loosely dash dot dot"] = {
      details = [[
Shorthand for setting a loosely dashed and dotted dash pattern with more
dots.

    \tikz \draw[loosely dash dot dot] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/loosely:dash:dot:dot"
    },
    ["loosely dashed"] = {
      details = [[
Shorthand for setting a loosely dashed dash pattern.

    \tikz \draw[loosely dashed] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/loosely:dashed"
    },
    ["loosely dotted"] = {
      details = [[
Shorthand for setting a loosely dotted dash pattern.

    \tikz \draw[loosely dotted] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/loosely:dotted"
    },
    looseness = {
      details = [[
This number specifies how "loose" the curve will be. In detail, the
following happens: TikZ computes the distance between the start and the
target coordinate (if the start and/or target coordinate are nodes, the
distance is computed between the points on their border). This distance
is then multiplied by a fixed factor and also by the factor ⟨number⟩.
The resulting distance, let us call it $d$, is then used as the distance
of the control points from the start and target coordinates.

The fixed factor has been chosen in such a way that if ⟨number⟩ is `1`,
if the `in` and `out` angles differ by 90$\circ$, then a quarter circle
results:

    \tikz \draw (0,0) to [out=0,in=-90]               (1,1);
    \tikz \draw (0,0) to [out=0,in=-90,looseness=0.5] (1,1);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/looseness",
      meta = "⟨number⟩"
    },
    ["lower left"] = {
      details = [[
Sets the color to be used in a `bilinear interpolation` shading for the
lower left corner. Also, this options selects this shading and sets the
`shade` option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/lower:left",
      meta = "⟨color⟩"
    },
    ["lower right"] = {
      details = [[
Works like `lower left`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/lower:right",
      meta = "⟨color⟩"
    },
    magnification = {
      details = [[
This has the same effect as saying `lens={scale=`⟨number⟩`}`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/magnification",
      meta = "⟨number⟩"
    },
    ["make snapshot after"] = {
      details = [[
Works exactly like `make snapshot of`, only the ⟨time⟩ is interpreted as
$⟨time⟩ + \epsilon$. This only makes a difference at the end of a
timeline and when there are two or more values specified for the same
time: When there are several values specified for time $t$, a normal
snapshot for time $t$ uses the first value given for the attribute. In
contrast, this command would use the last one given. Similarly, when an
animation timeline ends at time $t$, a normal snapshot of time $t$ would
use the last value of the timeline, while this key would not apply the
animation at all (it has already ended at time $t + \epsilon$).

    \tikz [make snapshot of = 2s]
      \fill :fill = { 0s = "green", 2s = "red" } (0,0) rectangle ++(1,1);
    \tikz [make snapshot after = 2s]
      \fill :fill = { 0s = "green", 2s = "red" } (0,0) rectangle ++(1,1);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/make:snapshot:after",
      meta = "⟨time⟩"
    },
    ["make snapshot if necessary"] = {
      details = [[
This key makes a snapshot of ⟨time⟩ only when the output format does not
provide support for animations; if the output format supports animations
(like SVG), then the command has no effect and animations are created
normally.

This manual is typeset with the following being set once are for all in
preamble:

    \tikzset{make snapshot if necessary}

Because of this setting, in the PDF version of this document, all
animations are shown at the value they would have at moment $0s$. In
contrast, in the SVG version, the animations are created normally.

In both versions, the smaller pictures showing how the animation
proceeds over time are created using `make snapshot of` for the
indicated times.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/make:snapshot:if:necessary",
      meta = "⟨time⟩"
    },
    ["make snapshot of"] = {
      details = [[
When this key is used in a TeX scope, animation commands given in the
scope do not add animation code to the output. Instead, TikZ computes
the values the attributes of the animation would have at the specified
⟨time⟩ and inserts the necessary system layer command to set the
attribute to the computed values (some care has been taken to make this
computation match the computations done by viewer applications as best
as possible).

    \tikz [make snapshot of = 1s] {
      \fill :fill = { 0s = "black", 2s = "white" } (0,0) rectangle ++(1,1);
      \fill :fill = { 1s = "black", 3s = "white" } (2,0) rectangle ++(1,1);
    }

The moment ⟨time⟩ is best thought of as ⟨time⟩ seconds after the "moment
zero" where all timelines start by default. Now, "real" animation may
start at different time through user interaction, which clearly makes no
sense for snapshots. Nevertheless, you will sometimes wish to have more
control over when a timeline starts for the purposes of taking
snapshots. You can use the following key for this:

The computations of the values the animation "would have" are done
entirely by TikZ, which has the big advantage is that no support from
the viewer application or the output format is needed -- snapshots work
with all output formats, not just with SVG. However, computations done
by TikZ are not always very precise and can be slow because of TeX's
limitations. In addition, there are some further limitations when it
comes to TikZ's computation of snapshot values:

-   As mentioned above, except for `begin snapshot`, other commands for
    specifying the beginning or end of a timeline based on user
    interaction make no sense for timelines: The keys `begin`,
    `begin on`, `end`, and `end on` are silently ignored.

-   The value `current value` for a value is forbidden since this value
    is almost impossible to compute by TikZ.

-   Accumulating repeats of a motion are (currently) not supported, but
    should not rely on this.

When ⟨time⟩ is empty, "snapshot taking" is switched off and animation
commands are inserted once more.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/make:snapshot:of",
      meta = "⟨time⟩"
    },
    mark = {
      details = [[
Sets the mark to a mnemonic that has previously been defined using the
`\pgfdeclareplotmark`. By default, `*`, `+`, and `x` are available,
which draw a filled circle, a plus, and a cross as marks. Many more
marks become available when the library `plotmarks` is loaded.
Section ?? lists the available plot marks.

One plot mark is special: the `ball` plot mark is available only in
TikZ. The `ball color` option determines the balls's color. Do not use
this option with a large number of marks since it will take very long to
render in PostScript.

  Option                 Effect
  --------------------- --------
  height14pt width0pt   
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/mark",
      meta = "⟨mark mnemonic⟩"
    },
    ["mark indices"] = {
      details = [[
This option allows you to specify explicitly the indices at which a mark
should be placed. Counting starts with 1. You can use the `\foreach`
syntax, that is, `...` can be used.

    \tikz \draw plot[mark=x,mark indices={1,4,...,10,11,12,...,16,20},smooth]
      file {plots/pgfmanual-sine.table};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/mark:indices",
      meta = "⟨list⟩"
    },
    ["mark options"] = {
      details = [[
Redefines `every mark` such that it sets `{options}`.

    \tikz \fill[fill=blue!20]
      plot[mark=triangle*,mark options={color=blue,rotate=180}]
        file{plots/pgfmanual-sine.table} |- (0,0);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/mark:options",
      meta = "⟨options⟩"
    },
    ["mark phase"] = {
      details = [[
This option tells TikZ that the first mark to be draw should be the
$p$th, followed by the $(p+r)$th, then the $(p+2r)$th, and so on.

    \tikz \draw plot[mark=x,mark repeat=3,mark phase=6,smooth] file {plots/pgfmanual-sine.table};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/mark:phase",
      meta = "⟨p⟩"
    },
    ["mark repeat"] = {
      details = [[
This option tells TikZ that only every $r$th mark should be drawn.

    \tikz \draw plot[mark=x,mark repeat=3,smooth] file {plots/pgfmanual-sine.table};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/mark:repeat",
      meta = "⟨r⟩"
    },
    ["mark size"] = {
      details = [[
Sets the size of the plot marks. For circular plot marks, ⟨dimension⟩ is
the radius, for other plot marks ⟨dimension⟩ should be about half the
width and height.

This option is not really necessary, since you achieve the same effect
by specifying `scale=`⟨factor⟩ as a local option, where ⟨factor⟩ is the
quotient of the desired size and the default size. However, using
`mark size` is a bit faster and more natural.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/mark:size",
      meta = "⟨dimension⟩"
    },
    matrix = {
      details = [[
This option can be passed to a `node` path command. It signals that the
node will contain a matrix.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (4,2);
      \node [matrix,fill=red!20,draw=blue,very thick] (my matrix) at (2,1)
      {
        \draw (0,0)   circle (4mm); & \node[rotate=10] {Hello};        \\
        \draw (0.2,0) circle (2mm); & \fill[red]   (0,0) circle (3mm); \\
      };

      \draw [very thick,->] (0,0) |- (my matrix.west);
    \end{tikzpicture}

The exact syntax of the matrix is explained in the course of this
section.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix",
      meta = "⟨true or false⟩"
    },
    ["matrix anchor"] = {
      details = [[
This option has the same effect as `anchor`, but the option applies only
to the matrix itself, not to the cells inside. If you just say
`anchor=north` as an option to the matrix node, all nodes inside matrix
will also have this anchor, unless it is explicitly set differently for
each node. By comparison, `matrix anchor` sets the anchor for the
matrix, but for the nodes inside the value of `anchor` remain unchanged.

    \begin{tikzpicture}
      \matrix [matrix anchor=west] at (0,0)
      {
        \node {123}; \\ % still center anchor
        \node {12}; \\
        \node {1}; \\
      };
      \matrix [anchor=west] at (0,-2)
      {
        \node {123}; \\ % inherited west anchor
        \node {12}; \\
        \node {1}; \\
      };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix:anchor",
      meta = "⟨anchor⟩"
    },
    ["matrix of math nodes"] = {
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix:of:math:nodes"
    },
    ["matrix of nodes"] = {
      details = [[
Conceptually, this key adds `\node{` at the beginning and `};` at the
end of each cell and sets the `anchor` of the node to `base`.
Furthermore, it adds the option `name` option to each node, where the
name is set to ⟨matrix name⟩`-`⟨row number⟩`-`⟨column number⟩. For
example, if the matrix has the name `my matrix`, then the node in the
upper left cell will get the name `my matrix-1-1`.

    \begin{tikzpicture}
      \matrix (magic) [matrix of nodes]
      {
        8 & 1 & 6 \\
        3 & 5 & 7 \\
        4 & 9 & 2 \\
      };

      \draw[thick,red,->] (magic-1-1) |- (magic-2-3);
    \end{tikzpicture}

You may wish to add options to certain nodes in the matrix. This can be
achieved in three ways.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix:of:nodes"
    },
    ["matrix/inner style order"] = {
      details = [[
The order in which these styles are applied to the matrix cells is
specified by this key. By default it is

    \tikzset{
      matrix/inner style order={
        every cell,
        column,
        even odd column,
        row,
        even odd row,
        cell,
      },
    }

You can use this to install your own styles here, but only *names* of
styles are permitted here. The style specification has to be placed
outside of `matrix/inner style order` and unless it is installed inside
`/tikz/matrix/inner style/`, it has to be fully qualified.

    \tikzset{
      my style/.code={%
        \ifnum\pgfmatrixcurrentcolumn=2
            \tikzset{font=\itshape}%
        \fi
      },
      matrix/inner style order={
          every cell,
          even odd column,
          even odd row,
          column,
          row,
          cell,
          /tikz/my style,
      },
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style:order"
    },
    ["matrix/inner style/cell"] = {
      details = [[
Wraps `/tikz/row `⟨number⟩` column `⟨number⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/cell"
    },
    ["matrix/inner style/column"] = {
      details = [[
Wraps `/tikz/column `⟨number⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/column"
    },
    ["matrix/inner style/even odd column"] = {
      details = [[
Wraps `/tikz/every even column` and `/tikz/every odd column`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/even:odd:column"
    },
    ["matrix/inner style/even odd row"] = {
      details = [[
Wraps `/tikz/every even row` and `/tikz/every odd row`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/even:odd:row"
    },
    ["matrix/inner style/every cell"] = {
      details = [[
Wraps `/tikz/every cell`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/every:cell"
    },
    ["matrix/inner style/row"] = {
      details = [[
Wraps `/tikz/row `⟨number⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/row"
    },
    ["max distance"] = {
      details = [[
If the computed distance for the start and target coordinates are above
⟨distance⟩, then ⟨distance⟩ is used instead.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/max:distance",
      meta = "⟨distance⟩"
    },
    ["medium circuit symbols"] = {
      details = [[
This style sets the default circuit symbol unit to `7pt`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/medium:circuit:symbols"
    },
    meet = {
      details = [[
Use this key with a scope to establish a view for the scope. In the
argument to the `meet` key, both `rectangle` texts are optional. Also,
everything following `at` is optional; when it is missing, the ⟨window
corner⟩s are assumed to be the same as the ⟨to-be-viewed corner⟩s. The
latter are two corners of a rectangle that should be transformed in such
a way that it fits inside the rectangle described by the two window
corners.

More precisely, at the beginning of the scope a canvas transformation is
installed that scales and translates the canvas is such a way that

1.  the center of the to-be-viewed rectangle lies at the center of the
    window rectangle and

2.  the to-be-viewed rectangle has maximum size that it still fits
    inside the window rectangle.

&nbsp;

    \tikz {
      \draw [red, very thick] (0,0) rectangle (20mm,20mm);
      \begin{scope}[meet = {(0.5,0.5) (2.5,1.5) at (0,0) (2,2)}]
        \draw [blue, very thick] (5mm,5mm) rectangle (25mm,15mm);
        \draw [thick] (1,1) circle [x radius=5mm, y radius=10mm] node {Hi};
      \end{scope} }

    \tikz {
      \draw [red, very thick] (0,0) rectangle (20mm,20mm);
      \begin{scope}[slice = {(0.5,0.5) (2.5,1.5) at (0,0) (2,2)}]
        \draw [blue, very thick] (5mm,5mm) rectangle (25mm,15mm);
        \draw [thick] (1,1) circle [x radius=5mm, y radius=10mm] node {Hi};
      \end{scope} }

As mentioned earlier, the main use of views is in conjunction with
animations. In order to animate a view, you specify the scope containing
the `meet` command as the target object and then animate its `:view`
attribute:

    \tikz [animate = {
      my scope:view = {
        begin on = { click, of next = here },
        0s = "{(0.5,0.5) (2.5,1.5)}",
        2s = "{(0.5,0) (1.5,2)}", forever
      }}] {
      \draw [red, fill=red!20, very thick, name=here]
        (0,0) rectangle (20mm,20mm);
      \begin{scope}[name = my scope,
                    meet = {(0.5,0.5) (2.5,1.5) at (0,0) (2,2)}]
        \draw [blue, very thick] (5mm,5mm) rectangle (25mm,15mm);
        \draw [thick] (1,1) circle [x radius=5mm, y radius=10mm] node {Hi};
      \end{scope} }

You can, of course, also specify the animation using the
`animate myself:` key when you specify the animation inside the scope:

    \tikz [animate = {
      my scope:view = {
      }}] {
      \draw [red, fill=red!20, very thick, name=here]
        (0,0) rectangle (20mm,20mm);
      \begin{scope}[animate = { myself: = { :view = {
                      begin on = { click, of = here },
                      0s = "{(0.5,0.5) (2.5,1.5)}",
                      2s = "{(0.5,0) (1.5,2)}", forever }}},
                    slice = {(0.5,0.5) (2.5,1.5) at (0,0) (2,2)}]
        \draw [blue, very thick] (5mm,5mm) rectangle (25mm,15mm);
        \draw [thick] (1,1) circle [x radius=5mm, y radius=10mm] node {Hi};
      \end{scope} }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/meet",
      meta = "⟨to-be-viewed corner⟩ rectangle ⟨to-be-viewed corner⟩ at ⟨window corner⟩ rectangle ⟨window corner⟩"
    },
    ["mid left"] = {
      details = [[
Works like `base left`, but with `mid east` and `mid west` anchors
instead of `base east` and `base west`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/mid:left",
      meta = "⟨specification⟩"
    },
    ["mid right"] = {
      details = [[
Works like `mid left`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/mid:right",
      meta = "⟨specification⟩"
    },
    ["middle color"] = {
      details = [[
This option specifies the color for the middle of an axis shading. It
also sets the `shade` and `shading=axis` options, but it does not change
the rotation angle.

*Note:* Since both `top color` and `bottom color` change the middle
color, this option should be given *last* if all of these options need
to be given:

    \tikz \draw[top color=white,bottom color=black,middle color=red]
      (0,0) rectangle (2,1);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/middle:color",
      meta = "⟨color⟩"
    },
    midway = {
      details = [[
This has the same effect as `pos=0.5`.

    \tikz \draw (0,0) .. controls +(up:2cm) and +(left:3cm) .. (1,5)
           node[at end]          {\texttt{at end}}
           node[very near end]   {\texttt{very near end}}
           node[near end]        {\texttt{near end}}
           node[midway]          {\texttt{midway}}
           node[near start]      {\texttt{near start}}
           node[very near start] {\texttt{very near start}}
           node[at start]        {\texttt{at start}};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/midway"
    },
    ["min distance"] = {
      details = [[
If the computed distance for the start and target coordinates are below
⟨distance⟩, then ⟨distance⟩ is used instead.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/min:distance",
      meta = "⟨distance⟩"
    },
    mindmap = {
      details = [[
Use this style with all pictures or at least scopes that contain a
mindmap. It installs a whole bunch of settings that are useful for
drawing mindmaps.

    \tikz[mindmap,concept color=red!50]
      \node [concept] {Root concept}
        child[grow=right] {node[concept] {Child concept}};

The sizes of concepts are predefined in such a way that a medium-size
mindmap will fit on an A4 page (more or less).

#### Remark:

Note that `mindmap` redefines `font` sizes and `sibling angle` depending
on the current concept level (i.e. inside of `level 1 concept`,
`level 2 concept` etc.). Thus, if you need to redefine these variables,
use

`level 1 concept/.append style={font=\small}`

or

`level 2 concept/.append style={sibling distance=90}`

*after* the `mindmap` style.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/mindmap"
    },
    missing = {
      details = [[
If this option is given to a child, the current child counter is
increased, but the child is otherwise ignored. In particular, the normal
contents of the child is completely ignored.

    \begin{tikzpicture}[level distance=10mm,sibling distance=5mm]
      \node {root} [grow=down]
        child          { node {1} }
        child          { node {2} }
        child          { node {3} }
        child[missing] { node {4} }
        child          { node {5} }
        child          { node {6} };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/missing",
      meta = "⟨true or false⟩"
    },
    ["miter limit"] = {
      details = [[
When you use the miter join and there is a very sharp corner (a small
angle), the miter join may protrude very far over the actual joining
point. In this case, if it were to protrude by more than ⟨factor⟩ times
the line width, the miter join is replaced by a bevel join.

    \begin{tikzpicture}[line width=5pt]
      \draw                 (0,0) -- ++(5,.5) -- ++(-5,.5);
      \draw[miter limit=25] (6,0) -- ++(5,.5) -- ++(-5,.5);
      \useasboundingbox (14,0); % make bounding box bigger
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/miter:limit",
      meta = "⟨factor⟩"
    },
    ["month code"] = {
      details = [[
This option allows you to specify what the macro `\tikzmonthcode` should
expand to.

By default, the `\tikzmonthcode` it is set to

    \node[every month]{\tikzmonthtext};

Note that this node is not named by default.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:code",
      meta = "⟨code⟩"
    },
    ["month label above centered"] = {
      details = [[
Works as above, only the label is centered above the row containing the
first day.

    \tikz
      \calendar [dates=2000-02-01 to 2000-02-last,
                 day list right,month label above centered];

    \tikz
      \calendar [dates=2000-01-20 to 2000-02-10,
                 week list,month label above centered];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:above:centered"
    },
    ["month label above left"] = {
      details = [[
This style places the month label above of the row of the first day,
flushed left to the leftmost column. The amount by which the label is
raised is fixed to `1.25em`; use the `yshift` option with the month node
to modify this.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list right,month xshift=1em,
                 month label above left];

    \tikz
      \calendar [dates=2000-01-20 to 2000-02-10,
                 week list,month label above left];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:above:left"
    },
    ["month label above right"] = {
      details = [[
Works as above, but flushed right

    \tikz
      \calendar [dates=2000-01-20 to 2000-02-10,
                 week list,month label above right];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:above:right"
    },
    ["month label below centered"] = {
      details = [[
Works like `month label above centered`, only below.

    \tikz
      \calendar [dates=2000-02-01 to 2000-02-last,
                 day list right,month label below centered];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:below:centered"
    },
    ["month label below left"] = {
      details = [[
Works like `month label above left`, only the label is placed below the
row. This placement is not really useful with the `week list`
arrangement, but rather with the `day list right` or `month list`
arrangement.

    \tikz
      \calendar [dates=2000-02-01 to 2000-02-last,
                 day list right,month label below left];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:below:left"
    },
    ["month label left"] = {
      details = [[
Places the month label to the left of the first day of the month. (For
`week list` and `month list` where a month does not start on a Monday,
the position is chosen "as if" the month had started on a Monday --
which is usually exactly what you want.)

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list downward,month yshift=1em,
                 month label left];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:left"
    },
    ["month label left vertical"] = {
      details = [[
This style works like the above style, only the label is rotated
counterclockwise by 90 degrees.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list downward,month yshift=1em,
                 month label left vertical];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:left:vertical"
    },
    ["month label right"] = {
      details = [[
This style places the month label to the right of the row in which the
first day of the month lies. This means that for a day list the label is
to the right of the first day, for a week list it is to the right of the
first week, and for a month list it is to the right of the whole month.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list downward,month yshift=1em,
                 month label right];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:right"
    },
    ["month label right vertical"] = {
      details = [[
Works as above, only the label is rotated clockwise by 90 degrees.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list downward,month yshift=1em,
                 month label right vertical];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:right:vertical"
    },
    ["month list"] = {
      details = [[
In this arrangement there is a row for each month. As for the
`week list`, the `day xshift` is used for the horizontal distance. For
the vertical shift, `month yshift` is used.

In each row, all days of the month are listed alongside each other.
However, it is once more ensured that days in each column lie on the
same day of week. Thus, the very first column contains only Mondays. If
a month does not start with a Monday, its days are shifted to the right
such that the days lie on the correct columns.

    \sffamily\scriptsize
    \tikz
      \calendar [dates=2000-01-01 to 2000-12-31,
                 month list,month label left,month yshift=1.25em]
                if (Sunday) [black!50];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:list"
    },
    ["month text"] = {
      details = [[
This option allows you to change the macro `\tikzmonthtext`. By default,
the month text is a long textual presentation of the current month being
typeset.

    \tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,
                    month label above centered,
                    month text=\textcolor{red}{\%mt} \%y-];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:text",
      meta = "⟨text⟩"
    },
    ["month xshift"] = {
      details = [[
Specifies an additional horizontal shift between different months.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:xshift",
      meta = "⟨dimension⟩"
    },
    ["month yshift"] = {
      details = [[
Specifies an additional vertical shift between different months.

    \tikz \calendar[dates=2000-01-01 to 2000-02-last,week list,
                    month yshift=0pt];

    \tikz \calendar[dates=2000-01-01 to 2000-02-last,week list,
                    month yshift=1cm];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/month:yshift",
      meta = "⟨dimension⟩"
    },
    ["move to"] = {
      details = [[
Causes a move to be added to the path upon a `to` or an `edge`
operation.

    \tikz \draw (0,0) to[line to] (1,0)
                      to[move to] (2,0) to[line to] (3,0);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/move:to"
    },
    name = {
      details = [[
Assigns a name to the node for later reference. Since this is a
"high-level" name (drivers never know of it), you can use spaces,
number, letters, or whatever you like when naming a node. Thus, you can
name a node just `1` or perhaps `start of chart` or even `y_ 1`. Your
node name should *not* contain any punctuation like a dot, a comma, or a
colon since these are used to detect what kind of coordinate you mean
when you reference a node.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/name",
      meta = "⟨node name⟩"
    },
    ["name intersections"] = {
      details = [[
This key changes the key path to `/tikz/intersection` and processes
⟨options⟩. These options determine, among other things, which paths to
use for the intersection. Having processed the options, any
intersections are then found. A coordinate is created at each
intersection, which by default, will be named `intersection-1`,
`intersection-2`, and so on. Optionally, the prefix `intersection` can
be changed, and the total number of intersections stored in a TeX-macro.

    \begin{tikzpicture}[every node/.style={opacity=1, black, above left}]
      \draw [help lines] grid (3,2);
      \draw [name path=ellipse] (2,0.5) ellipse (0.75cm and 1cm);
      \draw [name path=rectangle, rotate=10] (0.5,0.5) rectangle +(2,1);
      \fill [red, opacity=0.5, name intersections={of=ellipse and rectangle}]
        (intersection-1) circle (2pt) node {1}
        (intersection-2) circle (2pt) node {2};
    \end{tikzpicture}

The following keys can be used in ⟨options⟩:

    \begin{tikzpicture}
      \clip (-2,-2) rectangle (2,2);
      \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
      \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

      \fill [name intersections={of=curve 1 and curve 2, name=i, total=\t}]
            [red, opacity=0.5, every node/.style={above left, black, opacity=1}]
            \foreach \s in {1,...,\t}{(i-\s) circle (2pt) node {\footnotesize\s}};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/name:intersections",
      meta = "{options}"
    },
    ["name prefix"] = {
      details = [[
The value of this key is prefixed to every node inside the current
scope. This includes both the naming of the node (via the `name` key or
via the implicit `(`⟨name⟩`)` syntax) as well as any referencing of the
node. Outside the scope, the nodes can (and need to) be referenced using
"full name" consisting of the prefix and the node name.

The net effect of this is that you can set the name prefix at the
beginning of a scope to some value and then use short and simple names
for the nodes inside the scope. Later, outside the scope, you can
reference the nodes via their full name:

    \tikz {
      \begin{scope}[name prefix = top-]
        \node (A) at (0,1) {A};
        \node (B) at (1,1) {B};
        \draw (A) -- (B);
      \end{scope}
      \begin{scope}[name prefix = bottom-]
        \node (A) at (0,0) {A};
        \node (B) at (1,0) {B};
        \draw (A) -- (B);
      \end{scope}

      \draw [red] (top-A) -- (bottom-B);
    }

As can be seen, name prefixing makes it easy to write reusable code.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/name:prefix",
      meta = "⟨text⟩"
    },
    ["name prefix .."] = {
      details = [[
This key is available only inside the code of a pic. There, it (locally)
changes the name prefix to the value it had outside the pic. This allows
you to access nodes outside the current pic.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/name:prefix:.."
    },
    ["name suffix"] = {
      details = [[
Works as `name prefix`, only the ⟨text⟩ is appended to every node name
in the current scope.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/name:suffix",
      meta = "⟨text⟩"
    },
    ["near end"] = {
      details = [[
Set to `pos=0.75`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/near:end"
    },
    ["near start"] = {
      details = [[
Set to `pos=0.25`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/near:start"
    },
    ["nearly opaque"] = {
      details = [[
    \tikz{\fill[red]           (0,0)   rectangle (1,0.5);
          \fill[nearly opaque] (0.5,0) rectangle (1.5,0.25); }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/nearly:opaque"
    },
    ["nearly transparent"] = {
      details = [[
    \tikz{\fill[red]                (0,0)   rectangle (1,0.5);
          \fill[nearly transparent] (0.5,0) rectangle (1.5,0.25); }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/nearly:transparent"
    },
    ["new set"] = {
      details = [[
This will setup a node set named ⟨set name⟩ within the current scope.
Inside the scope, you can add nodes to the node set using the `set` key.
If a node set of the same name already exists in the current scope, it
will be reset and made empty for the current scope.

Note that this command has the path `/tikz` and is normally used
*outside* the `graph` command.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/new:set",
      meta = "⟨set name⟩"
    },
    ["no markers"] = {
      details = [[
Disables markers (the same as `mark=none`).
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/no:markers"
    },
    ["no marks"] = {
      details = [[
Disables markers (the same as `mark=none`).
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/no:marks"
    },
    ["node contents"] = {
      details = [[
\[option-node-contents\] This key sets the contents of the node to the
given text as if you had given it at the end in curly braces. When the
option is used inside the options of a node, the parsing of the node
stops immediately after the end of the option block. In particular, the
option block cannot be followed by further option blocks or curly braces
(or, rather, these do not count as part of the node specification.) Also
note that the ⟨node contents⟩ may not contain fragile stuff since the
catcodes get fixed upon reading the options. Here is an example:

    \tikz {
      \path (0,0) node [red]                    {A}
            (1,0) node [blue]                   {B}
            (2,0) node [green, node contents=C]
            (3,0) node [node contents=D]           ;
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/node:contents",
      meta = "⟨node contents⟩"
    },
    ["node distance"] = {
      details = [[
The value of this key is used as ⟨shifting part⟩ is used if and only if
a ⟨of-part⟩ is present, but no ⟨shifting part⟩.

    \begin{tikzpicture}[every node/.style=draw,node distance=5mm]
      \draw[help lines] (0,0) grid (2,3);

      % Not gridded
      \node (a1) at (0,0) {not gridded};
      \node (b1) [above=of a1] {fooy};
      \node (c1) [above=of b1] {a};

      % gridded
      \begin{scope}[on grid]
        \node (a2) at (2,0) {gridded};
        \node (b2) [above=of a2] {fooy};
        \node (c2) [above=of b2] {a};
      \end{scope}
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/node:distance",
      meta = "⟨shifting part⟩"
    },
    ["node font"] = {
      details = [[
This option sets the font used for all text used in a node.

    \begin{tikzpicture}
      \draw[node font=\itshape] (1,0) -- +(1,1) node[above] {italic};
    \end{tikzpicture}

Since the ⟨font commands⟩ are executed at a very early stage in the
construction of the node, the font selected using this command will also
dictate the values of dimensions defined in terms of `em` or `ex`. For
instance, when the `minimum height` of a node is `3em`, the actual
height will be (at least) three times the line distance selected by the
⟨font commands⟩:

    \tikz \node [node font=\tiny,  minimum height=3em, draw] {tiny};
    \tikz \node [node font=\small, minimum height=3em, draw] {small};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/node:font",
      meta = "⟨font commands⟩"
    },
    ["node halign header"] = {
      details = [[
This is the key that is used by `align` internally for alignment without
line breaking. Read the following only if you are familiar with the
`\halign` command.

This key only has an effect if `text width` is empty, otherwise it is
ignored. Furthermore, if ⟨macro storing a header⟩ is empty, then this
key also has no effect. So, suppose `text width` is empty, but ⟨header⟩
is not. In this case the following happens:

When the node text is parsed, the command `\\` is redefined internally.
This redefinition is done in such a way that the text from the start of
the node to the first occurrence of `\\` is put in an `\hbox`. Then the
text following `\\` up to the next `\\` is put in another `\hbox`. This
goes on until the text between the last `\\` and the closing `}` is also
put in an `\hbox`.

The ⟨macro storing a header⟩ should be a macro that contains some text
suitable for use as a header for the `\halign` command. For instance,
you might define

    \def\myheader{\hfil\hfil##\hfil\cr}
    \tikz [node halign header=\myheader] ...

You cannot just say `node halign header=\hfil\hfil# \hfil\cr` because
this confuses TeX inside matrices, so this detour via a macro is needed.

Next, conceptually, all these boxes are recursively put inside an
`\halign` command. Assuming that ⟨first⟩ is the first of the above
boxes, the command `\halign{`⟨header⟩ `\box`⟨first⟩ `\cr}` is used to
create a new box, which we will call the ⟨previous box⟩. Then, the
following box is created, where ⟨second⟩ is the second input box:
`\halign{`⟨header⟩ `\box`⟨previous box⟩ `\cr` `\box`⟨second⟩`\cr}`. Let
us call the resulting box the ⟨previous box⟩ once more. Then the next
box that is created is `\halign{`⟨header⟩ `\box`⟨previous box⟩ `\cr`
`\box`⟨third⟩`\cr}`.

All of this means that if ⟨header⟩ is an `\halign` header like
`\hfil# \hfil\cr`, then all boxes will be centered relative to one
another. Similarly, a ⟨header⟩ of `\hfil# \cr` causes the text to be
flushed right.

Note that this mechanism is not flexible enough to all multiple columns
inside ⟨header⟩. You will have to use a `tabular` or a `matrix` in such
cases.

One further note: Since the text of each line is placed in a box,
settings will be local to each "line". This is very similar to the way a
cell in a `tabular` or a `matrix` behaves.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/node:halign:header",
      meta = "⟨macro storing a header⟩"
    },
    ["node quotes mean"] = {
      details = [[
This key allows you to define your own handler for quotes options.
Inside the options of a `node`, whenever a key--value pair with the
syntax

> `"`⟨text⟩`"``’`⟨options⟩

is encountered, the following happens: The above string gets replaced by
⟨replacement⟩ where inside the ⟨replacement⟩ the parameter `# 1` is
⟨text⟩ and `# 2` is ⟨options⟩. If the apostrophe is present (see also
the discussion of `quotes mean label`), the ⟨options⟩ start with `’,`.

The ⟨replacement⟩ is then parsed normally as options (using `\pgfkeys`).

Here is an example, where the quotes are used to define labels that are
automatically named according to the `text`:

    \tikzset{node quotes mean={label={[#2,name={#1}]#1}}}

    \tikz {
      \node ["1", "2" label position=left, circle, draw] {circle};
      \draw (1) -- (2);
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/node:quotes:mean",
      meta = "⟨replacement⟩"
    },
    nodes = {
      details = [[
This key adds the ⟨options⟩ to the style `every node`. It is mainly just
a shorthand for the code `every node/.append style=`⟨options⟩.

The main use of this option is the install some options for the nodes
*inside* the matrix that should not apply to the matrix *itself*.

    \begin{tikzpicture}
      \matrix [nodes={fill=blue!20,minimum size=5mm}]
      {
        \node {8}; & \node{1}; & \node {6}; \\
        \node {3}; & \node{5}; & \node {7}; \\
        \node {4}; & \node{9}; & \node {2}; \\
      };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/nodes",
      meta = "⟨options⟩"
    },
    ["nodes in empty cells"] = {
      details = [[
When set to `true`, a node (with empty contents) is put in empty cells.
Normally, empty cells are just, well, empty. The style can be used
together with both a `matrix of nodes` and a `matrix of math nodes`.

    \begin{tikzpicture}
      \matrix [matrix of math nodes,nodes={circle,draw}]
      {
        a_8 &     & a_6 \\
        a_3 &     & a_7 \\
        a_4 & a_9 &     \\
      };
    \end{tikzpicture}

    \begin{tikzpicture}
      \matrix [matrix of math nodes,nodes={circle,draw},nodes in empty cells]
      {
        a_8 &     & a_6 \\
        a_3 &     & a_7 \\
        a_4 & a_9 &     \\
      };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/nodes:in:empty:cells",
      meta = "⟨true or false⟩"
    },
    ["nonzero rule"] = {
      details = [[
If this rule is used (which is the default), the following method is
used to determine whether a given point is "inside" the path: From the
point, shoot a ray in some direction towards infinity (the direction is
chosen such that no strange borderline cases occur). Then the ray may
hit the path. Whenever it hits the path, we increase or decrease a
counter, which is initially zero. If the ray hits the path as the path
goes "from left to right" (relative to the ray), the counter is
increased, otherwise it is decreased. Then, at the end, we check whether
the counter is nonzero (hence the name). If so, the point is deemed to
lie "inside", otherwise it is "outside". Sounds complicated? It is.

    \begin{tikzpicture}
      \filldraw[fill=yellow!80!black]
      % Clockwise rectangle
      (0,0) -- (0,1) -- (1,1) -- (1,0) -- cycle
      % Counter-clockwise rectangle
      (0.25,0.25) -- (0.75,0.25) -- (0.75,0.75) -- (0.25,0.75) -- cycle;

      \draw[->] (0,1) -- (.4,1);
      \draw[->] (0.75,0.75) -- (0.3,.75);

      \draw[->] (0.5,0.5) -- +(0,1) node[above] {crossings: $-1+1 = 0$};

      \begin{scope}[yshift=-3cm]
        \filldraw[fill=yellow!80!black]
        % Clockwise rectangle
        (0,0) -- (0,1) -- (1,1) -- (1,0) -- cycle
        % Clockwise rectangle
        (0.25,0.25) -- (0.25,0.75) -- (0.75,0.75) -- (0.75,0.25) -- cycle;

        \draw[->] (0,1) -- (.4,1);
        \draw[->] (0.25,0.75) -- (0.4,.75);

        \draw[->] (0.5,0.5) -- +(0,1) node[above] {crossings: $1+1 = 2$};
      \end{scope}
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/nonzero:rule"
    },
    ["numbered faces"] = {
      details = [[
Sets `face `⟨i⟩ to `\node {`⟨i⟩`};` for all $i$.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/numbered:faces"
    },
    ohm = {
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ohm",
      meta = "⟨value⟩"
    },
    ["on background layer"] = {
      details = [[
This key can (only) be used with a `{scope}` or `\scoped`. It will cause
everything inside the scope to be typeset on a background layer.

The ⟨options⟩ will be executed *inside* background scope. This is useful
since *other* options passed to the `{scope}` environment will be
executed *before* the actual background material starts and, thus, will
have no effect on it.

    \begin{tikzpicture}
      % On main layer:
      \fill[blue] (0,0) circle (1cm);

      \begin{scope}[on background layer={color=yellow}]
        \fill (-1,-1) rectangle (1,1);
      \end{scope}

      \begin{scope}[on background layer]
        \fill[black] (-.8,-.8) rectangle (.8,.8);
      \end{scope}

      % On main layer again:
      \fill[blue!50] (-.5,-1) rectangle (.5,1);
    \end{tikzpicture}

A scope with this option set should not be "deeply nested" inside the
picture since changes to the graphic state (like the color or the
transformation matrix) "do not survive a layer switch", see also
Section ?? for details. In particular, setting, say, the line width at
the beginning of a picture will not have an effect on the background
picture.

For this reason, it may be useful to setup the following style:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/on:background:layer",
      meta = "⟨options⟩"
    },
    ["on chain"] = {
      details = [[
This key should be given as an option to a node. When the option is
used, the ⟨chain name⟩ must be the name of a chain that has been started
using the `start chain` option. If ⟨chain name⟩ is the empty string, the
current value of the innermost activated chain is used. If this option
is used several times for a node, only the last invocation "wins". (To
place a node on several chains, use the `\chainin` command repeatedly.)

The ⟨direction⟩ part is optional. If present, it sets the direction used
for this node, otherwise the ⟨direction⟩ that was given to the original
`start chain` option is used (or of the last `continue chain` option,
which allows you to change this default).

The effects of this option are the following:

1.  An internal counter (there is one local counter for each chain) is
    increased. This counter reflects the current number of the node in
    the chain, where the first node is node 1, the second is node 2, and
    so on.

    The value of this internal counter is globally stored in the macro
    `\tikzchaincount`.

2.  If the node does not yet have a name, (having been given using the
    `name` option or the name-syntax), the name of the node is set to
    ⟨chain name⟩`-`⟨value of the internal chain counter⟩. For instance,
    if the chain is called `nums`, the first node would be named
    `nums-1`, the second `nums-2`, and so on. For the default chain name
    `chain`, the first node is named `chain-1`, the second `chain-2`,
    and so on.

3.  Independently of whether the name has been provided automatically or
    via the `name` option, the name of the node is globally stored in
    the macro `\tikzchaincurrent`.

4.  Except for the first node, the macro `\tikzchainprevious` is now
    globally set to the name of the node of the previous node on the
    chain. For the first node of the chain, this macro is globally set
    to the empty string.

5.  Except possibly for the first node of the chain, the placement rule
    is now executed. The placement rule is just a TikZ option that is
    applied automatically to each node on the chain. Depending on the
    form of the ⟨direction⟩ parameter (either the locally given one or
    the one given to the `start chain` option), different things happen.

    First, it makes a difference whether the ⟨direction⟩ starts with
    `going` or with `placed`. The difference is that in the first case,
    the placement rule is not applied to the first node of the chain,
    while in the second case the placement rule is applied also to this
    first node. The idea is that a `going`-direction indicates that we
    are "going somewhere relative to the previous node" whereas a
    `placed` indicates that we are "placing nodes according to their
    number".

    Independently of which form is used, the ⟨text⟩ inside ⟨direction⟩
    that follows `going` or `placed` (separated by a compulsory space)
    can have two different effects:

    1.  If it contains an equal sign, then this ⟨text⟩ is used as the
        placement rule, that is, it is simply executed.

    2.  If it does not contain an equal sign, then
        ⟨text⟩`=of \tikzchainprevious` is used as the placement rule.

    Note that in the first case, inside the ⟨text⟩ you have access to
    `\tikzchainprevious` and `\tikzchaincount` for doing your
    positioning calculations.

        \begin{tikzpicture}[start chain=circle placed {at=(\tikzchaincount*30:1.5)}]
          \foreach \i in {1,...,10}
            \node [on chain] {\i};

          \draw (circle-1) -- (circle-10);
        \end{tikzpicture}

6.  The following style is executed:

Recall that the standard placement rule has a form like
`right=of (\tikzchainprevious)`. This means that each new node is placed
to the right of the previous one, spaced by the current value of
`node distance`.

    \begin{tikzpicture}[start chain,node distance=5mm]
      \node [draw,on chain] {};
      \node [draw,on chain] {Hallo};
      \node [draw,on chain] {Welt};
    \end{tikzpicture}

The optional ⟨direction⟩ allows us to temporarily change the direction
in the middle of a chain:

    \begin{tikzpicture}[start chain,node distance=5mm]
      \node [draw,on chain] {Hello};
      \node [draw,on chain] {World};
      \node [draw,on chain=going below] {,};
      \node [draw,on chain] {this};
      \node [draw,on chain] {is};
    \end{tikzpicture}

You can also use more complicated computations in the ⟨direction⟩:

    \begin{tikzpicture}[start chain=going {at=(\tikzchainprevious),shift=(30:1)}]
      \draw [help lines] (0,0) grid (3,2);
      \node [draw,on chain] {1};
      \node [draw,on chain] {Hello};
      \node [draw,on chain] {World};
      \node [draw,on chain] {.};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/on:chain",
      meta = "⟨chain name⟩⟨direction⟩"
    },
    ["on grid"] = {
      details = [[
When this key is set to `true`, an ⟨of-part⟩ of the current form behaves
differently: The anchors set for the current node as well as the anchor
used for the other ⟨node name⟩ are set to `center`.

This has the following effect: When you say `above=1cm of somenode` with
`on grid` set to true, the new node will be placed in such a way that
its center is 1cm above the center of `somenode`. Repeatedly placing
nodes in this way will result in nodes that are centered on "grid
coordinate", hence the name of the option.

    \begin{tikzpicture}[every node/.style=draw]
      \draw[help lines] (0,0) grid (2,3);

      % Not gridded
      \node (a1) at (0,0) {not gridded};
      \node (b1) [above=1cm of a1] {fooy};
      \node (c1) [above=1cm of b1] {a};

      % gridded
      \node (a2) at (2,0) {gridded};
      \node (b2) [on grid,above=1cm of a2] {fooy};
      \node (c2) [on grid,above=1cm of b2] {a};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/on:grid",
      meta = "⟨boolean⟩"
    },
    ["only marks"] = {
      details = [[
This option causes only marks to be shown; no path segments are added to
the actual path. This can be useful for quickly adding some marks to a
path.

    \tikz \draw (0,0) sin (1,1) cos (2,0)
      plot[only marks,mark=x] coordinates{(0,0) (1,1) (2,0) (3,-1)};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/only:marks"
    },
    opacity = {
      details = [[
Sets both the drawing and filling opacity to ⟨value⟩.

The following predefined styles make it easier to use this option:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/opacity",
      meta = "⟨value⟩"
    },
    opaque = {
      details = [[
This yields completely opaque drawings, which is the default.

    \tikz{\fill[red]    (0,0)   rectangle (1,0.5);
          \fill[opaque] (0.5,0) rectangle (1.5,0.25); }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/opaque"
    },
    out = {
      details = [[
The angle at which the curve leaves the start coordinate. If the start
coordinate is a node, the start coordinate is the point on the border of
the node at the given ⟨angle⟩. The control point will, thus, lie at a
certain distance in the direction ⟨angle⟩ from the start coordinate.

    \begin{tikzpicture}[out=45,in=135]
      \draw (0,0) to (1,0)
            (0,0) to (2,0)
            (0,0) to (3,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/out",
      meta = "⟨angle⟩"
    },
    ["out control"] = {
      details = [[
This option causes the ⟨coordinate⟩ to be used as the start control
point. All computations of $d$ are ignored. You can use a coordinate
like `+(1,0)` to specify a point relative to the start coordinate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/out:control",
      meta = "⟨coordinate⟩"
    },
    ["out distance"] = {
      details = [[
Sets the minimum and maximum out distance.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/out:distance",
      meta = "⟨distance⟩"
    },
    ["out looseness"] = {
      details = [[
Specifies the looseness factor for the out distance only.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/out:looseness",
      meta = "⟨number⟩"
    },
    ["out max distance"] = {
      details = [[
The maximum distance set only for the start coordinate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/out:max:distance",
      meta = "⟨distance⟩"
    },
    ["out min distance"] = {
      details = [[
The minimum distance set only for the start coordinate.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/out:min:distance",
      meta = "⟨distance⟩"
    },
    ["outer color"] = {
      details = [[
This option sets the color used at the border and outside of a `radial`
shading.

    \tikz \draw[outer color=red,inner color=white]
      (0,0) rectangle (2,1);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/outer:color",
      meta = "⟨color⟩"
    },
    ["outer frame sep"] = {
      details = [[
Sets both the $x$- and $y$-separation.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/outer:frame:sep",
      meta = "⟨dimension⟩"
    },
    ["outer frame xsep"] = {
      details = [[
The ⟨dimension⟩ is added at the left and right side of the line.

    \begin{tikzpicture}
      [background rectangle/.style={fill=yellow},
       framed,
       show background top,
       outer frame xsep=1ex]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/outer:frame:xsep",
      meta = "⟨dimension⟩"
    },
    ["outer frame ysep"] = {
      details = [[
This option does not apply to the top line, but to the left and right
lines, see below.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/outer:frame:ysep",
      meta = "⟨dimension⟩"
    },
    overlay = {
      details = [[
This option is mainly intended for use when nodes in other pictures are
referenced, but you can also use it in other situations. The effect of
this option is that everything within the current scope is not taken
into consideration when the bounding box of the current picture is
computed.

You need to specify this option on all paths (or at least on all parts
of paths) that contain a reference to a node in another picture. The
reason is that, otherwise, TikZ will attempt to make the current picture
large enough to encompass *the node in the other picture*. However, on a
second run of TeX this will create an even bigger picture, leading to
larger and larger pictures. Unless you know what you are doing, I
suggest specifying the `overlay` option with all pictures that contain
references to other pictures.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/overlay",
      meta = "⟨boolean⟩"
    },
    ["parabola height"] = {
      details = [[
This option has the same effect as
`[bend pos=0.5,bend={+(0pt,`⟨dimension⟩`)}]`.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw (-1,0) parabola[parabola height=2cm] +(3,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/parabola:height",
      meta = "⟨dimension⟩"
    },
    parametric = {
      details = [[
Sets whether the plot is a parametric plot. If true, then `t` must be
used instead of `x` as the parameter and two comma-separated functions
must be given in the ⟨gnuplot formula⟩. An example is the following:

    \tikz \draw[scale=0.5,domain=-3.141:3.141,smooth]
      plot[parametric,id=parametric-example] function{t*sin(t),t*cos(t)};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/parametric",
      meta = "⟨boolean⟩"
    },
    ["parent anchor"] = {
      details = [[
This option works the same way as the `child anchor`, only for the
parent.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/parent:anchor",
      meta = "⟨anchor⟩"
    },
    ["path fading"] = {
      details = [[
This option tells TikZ that the current path should be faded with the
fading ⟨name⟩. If no ⟨name⟩ is given, the ⟨name⟩ set for the whole scope
is used. Similarly to options like `draw` or `fill`, this option is
reset for each path, so you have to add it to each path that should be
faded. You can also specify `none` as ⟨name⟩, in which case fading for
the path will be switched off in case it has been switched on by
previous options or styles.

    \begin{tikzpicture}[path fading=south]
      % Checker board
      \fill [black!20] (0,0) rectangle (4,3);
      \pattern [pattern=checkerboard,pattern color=black!30]
                       (0,0) rectangle (4,3);

      \fill [color=blue]                   (0.5,1.5) rectangle +(1,1);
      \fill [color=blue,path fading=north] (2.5,1.5) rectangle +(1,1);

      \fill [color=red,path fading]        (1,0.75) ellipse (.75 and .5);
      \fill [color=red]                    (3,0.75) ellipse (.75 and .5);
    \end{tikzpicture}

Note that you can "fade just about anything". In particular, you can
fade a shading.

    \begin{tikzpicture}
      % Checker board
      \fill [black!20] (0,0) rectangle (4,4);
      \path [pattern=checkerboard,pattern color=black!30] (0,0) rectangle (4,4);

      \shade [ball color=blue,path fading=south] (2,2) circle (1.8);
    \end{tikzpicture}

The `fade inside` of the following example is more transparent in the
middle than on the outside.

    \tikzfading[name=fade inside,
                inner color=transparent!80,
                outer color=transparent!30]
    \begin{tikzpicture}
      % Checker board
      \fill [black!20] (0,0) rectangle (4,4);
      \path [pattern=checkerboard,pattern color=black!30] (0,0) rectangle (4,4);

      \shade [ball color=red] (3,3) circle (0.8);
      \shade [ball color=white,path fading=fade inside] (2,2) circle (1.8);
    \end{tikzpicture}

Note that adding the `path fading` option to a node fades the
(background) path, not the text itself. To fade the text, you need to
use a scope fading (see below).
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/path:fading",
      meta = "⟨name⟩"
    },
    ["path picture"] = {
      details = [[
When this option is given on a path and when the ⟨code⟩ is not empty,
the following happens: After all other "filling" operations are done
with the path, which are caused by the options `fill`, `pattern` and
`shade`, a local scope is opened and the path is temporarily installed
as a clipping path. Then, the ⟨code⟩ is executed, which can now draw
something. Then, the local scope ends and, possibly, the path is
stroked, provided the `draw` option has been given.

As with other keys like `fill` or `draw` this option needs to be given
on a path, setting the `path picture` outside a path has no effect (the
path picture is cleared at the beginning of each path).

The ⟨code⟩ can be any normal TikZ code like `\draw ...` or `\node ...`.
As always, when you include an external graphic, you need to put it
inside a `\node`.

Note that no special actions are taken to transform the origin in any
way. This means that the coordinate `(0,0)` is still where is was when
the path was being constructed and not -- as one might expect -- at the
lower left corner of the path. However, you can use the following
special node to access the size of the path:

path picture bounding box This node is of shape `rectangle`. Its size
and position are those of `current path bounding box` just before the
⟨code⟩ of the path picture started to be executed. The ⟨code⟩ can
construct its own paths, so accessing the `current path bounding box`
inside the ⟨code⟩ yields the bounding box of any path that is currently
being constructed inside the ⟨code⟩.

    \begin{tikzpicture}
      \draw [help lines] (0,0) grid (3,2);
      \filldraw [fill=blue!10,draw=blue,thick] (1.5,1) circle (1)
        [path picture={
          \node at (path picture bounding box.center) {
            This is a long text.
          };}
        ];
    \end{tikzpicture}

    \begin{tikzpicture}[cross/.style={path picture={
          \draw[black]
                (path picture bounding box.south east) --
                (path picture bounding box.north west)
                (path picture bounding box.south west) --
                (path picture bounding box.north east);
        }}]
      \draw [help lines] (0,0) grid (3,2);
      \filldraw [cross,fill=blue!10,draw=blue,thick] (1,1) circle (1);
      \path     [cross,top color=red,draw=red,thick] (2,0) -- (3,2) -- (3,0);
    \end{tikzpicture}

      \begin{tikzpicture}[path image/.style={
          path picture={
            \node at (path picture bounding box.center) {
              \includegraphics[height=3cm]{#1}
            };}}]
      \draw     [help lines] (0,0) grid (3,2);

      \draw [path image=brave-gnu-world-logo,draw=blue,thick]
              (0,1) circle (1);
      \draw [path image=brave-gnu-world-logo,draw=red,very thick,->]
              (1,0) parabola[parabola height=2cm] (3,0);

    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/path:picture",
      meta = "⟨code⟩"
    },
    pattern = {
      details = [[
This option causes the path to be filled with a pattern. If the ⟨name⟩
is given, this pattern is used, otherwise the pattern set in the
enclosing scope is used. As for the `draw` and `fill` options, setting
⟨name⟩ to `none` disables filling locally.

The pattern works like a fill color. In particular, setting a new fill
color will fill the path with a solid color once more.

Strangely, no ⟨name⟩s are permissible by default. You need to load for
instance the `patterns` library, see Section ??, to install predefined
patterns.

    \begin{tikzpicture}
      \draw[pattern=dots] (0,0) circle (1cm);
      \draw[pattern=fivepointed stars] (0,0) rectangle (3,1);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pattern",
      meta = "⟨name⟩"
    },
    ["pattern color"] = {
      details = [[
This option is used to set the color to be used for form-only patterns.
This option has no effect on inherently colored patterns.

    \begin{tikzpicture}
      \draw[pattern color=red,pattern=fivepointed stars]  (0,0) circle (1cm);
      \draw[pattern color=blue,pattern=fivepointed stars] (0,0) rectangle (3,1);
    \end{tikzpicture}

    \begin{tikzpicture}
      \def\mypath{(0,0) -- +(0,1) arc (180:0:1.5cm) -- +(0,-1)}
      \fill   [red]                                \mypath;
      \pattern[pattern color=white,pattern=bricks] \mypath;
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pattern:color",
      meta = "⟨color⟩"
    },
    ["patterns/bottom left"] = {
      details = [[
Instead of a PGF name point, this key takes a TikZ point,
e.g. `(-.1,-.1)`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/bottom:left",
      meta = "⟨point⟩"
    },
    ["patterns/bounding box"] = {
      details = [[
This is a shorthand to set the bounding box. It will assign the first
point to `bottom left` and the second point to `top right`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/bounding:box",
      meta = "⟨point⟩ and ⟨point⟩"
    },
    ["patterns/infer tile bounding box"] = {
      details = [[
Instead of specifying the bounding box by hand, you can ask TikZ to
infer the size of the bounding box for you. The ⟨dimension⟩ parameter is
padding that is added around the bounding box.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/infer:tile:bounding:box",
      meta = "⟨dimension⟩"
    },
    ["patterns/tile size"] = {
      details = [[
Instead of a PGF name point, this key takes a TikZ point, e.g. `(3,3)`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/tile:size",
      meta = "⟨point⟩"
    },
    ["patterns/tile transformation"] = {
      details = [[
Instead of a PGF transformation, this key takes a list of keys and value
and extracts the resulting transformation from them, e.g. `rotate=30`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/tile:transformation",
      meta = "⟨transformation⟩"
    },
    ["patterns/top right"] = {
      details = [[
Instead of a PGF name point, this key takes a TikZ point,
e.g. `(3.1,3.1)`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/top:right",
      meta = "⟨point⟩"
    },
    perspective = {
      details = [[
The 'strength' of the perspective can be determined by setting the
location of the vanishing points. The default values have a stronger
perspective towards $x$ and $y$ than towards $z$, as shown below.

    \begin{tikzpicture}[3d view,perspective]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}

From this example it also shows that the maximum dimensions of the
cuboid are no longer 2 by 2 by 2. This is inherent to the perspective
projection.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/perspective",
      meta = "⟨vanishing points⟩"
    },
    ["perspective/p"] = {
      details = [[
The location of the vanishing point that determines the 'strength' of
the perspective in $x$-direction can be set with the `p` key.

    \begin{tikzpicture}[
      3d view,
      perspective={
        p = {(5,0,0)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}

Note also that when only `p` is provided, the perspective in $y$ and $z$
direction is turned off.

To turn off the perspective in $x$-direction, one must set the $x$
component of `p` to `0` (e.g. `p={(0,a,b)}`, where `a` and `b` can be
any number and will be ignored). Or one can provide `q` and `r` and omit
`p`.

By changing the $y$ and $z$ components of `p`, one can achieve various
effects.

    \begin{tikzpicture}[
      3d view,
      perspective={
        p = {(5,0,1)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}

    \begin{tikzpicture}[
      3d view,
      perspective={
        p = {(5,1,0)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}

    \begin{tikzpicture}[
      3d view,
      perspective={
        p = {(5,1,1)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/perspective/p",
      meta = "{x,y,z}"
    },
    ["perspective/q"] = {
      details = [[
Similar to `p`, but can be turned off by setting its $y$ component to
`0`.

    \begin{tikzpicture}[
      3d view,
      perspective={
        q = {(0,5,0)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/perspective/q",
      meta = "{x,y,z}"
    },
    ["perspective/r"] = {
      details = [[
Similar to `p`, but can be turned off by setting its $z$ component to
`0`.

    \begin{tikzpicture}[
      3d view,
      perspective={
        r = {(0,0,5)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/perspective/r",
      meta = "{x,y,z}"
    },
    ["pic actions"] = {
      details = [[
This key is a style that can be used (only) inside the code of a pic.
There, it will set the "action" keys set inside the ⟨options⟩ of the pic
("actions" are drawing, filling, shading, and clipping or any
combination thereof).

To see how this key works, let us define the following pic:

    \tikzset{
      my pic/.pic = {
        \path [pic actions] (0,0) circle[radius=3mm];
        \draw (-3mm,-3mm) rectangle (3mm,3mm);
      }
    }

In the code, whether or not the circle gets drawn/filled/shaded depends
on which options where given to the `pic` command when it is used. In
contrast, the rectangle will always (just) be drawn.

     (0,0) circle[radius=3mm];
        \draw (-3mm,-3mm) rectangle (3mm,3mm);
      }
    }}]
    \tikz \pic                      {my pic}; \space
    \tikz \pic [red]                {my pic}; \space
    \tikz \pic [draw]               {my pic}; \space
    \tikz \pic [draw=red]           {my pic}; \space
    \tikz \pic [draw, shading=ball] {my pic}; \space
    \tikz \pic [fill=red!50]        {my pic};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pic:actions"
    },
    ["pic text"] = {
      details = [[
This macro stores the ⟨text⟩ in the macro `\tikzpictext`, which is
`\let` to `\relax` by default. Setting the `pic text` to some value is
the "preferred" way of communicating a (single) piece of text that
should become part of a pic (typically of a node). In particular, the
`quotes` library maps quoted parameters to this key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pic:text",
      meta = "⟨text⟩"
    },
    ["pic text options"] = {
      details = [[
This macro stores the ⟨options⟩ in the macro `\tikzpictextoptions`,
which is `\let` to the empty string by default. The `quotes` library
maps options for quoted parameters to this key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pic:text:options",
      meta = "⟨options⟩"
    },
    ["pic type"] = {
      details = [[
This key sets the pic type of the current `pic`. When this option is
used inside an option block of a `pic`, the parsing of the `pic` ends
immediately and no pic type in braces is expected. (In other words, this
option behaves exactly like the `node contents` option and, indeed, the
two are interchangeable.)

     (0,0) to [bend left] (3mm,0);
      },
    }}]
    \tikz {
      \path (0,0) pic [pic type = seagull]
            (1,0) pic                      {seagull};
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pic:type",
      meta = "⟨pic type⟩"
    },
    ["pics/background code"] = {
      details = [[
Like `foreground code`, only that the ⟨code⟩ is always put behind the
path, except when the `behind path` option is applied to the pic, then
the background code is drawn in front of the "behind path" code.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pics/background:code",
      meta = "⟨code⟩"
    },
    ["pics/code"] = {
      details = [[
This key stores the ⟨code⟩ that should be drawn in the current pic.
Normally, setting this key is done by the ⟨pic type⟩, but you can also
set it in the ⟨options⟩ and leave the ⟨pic type⟩ empty:

    \tikz \pic [pics/code={\draw (-3mm,0) to[bend left] (0,0)
                                          to[bend left] (3mm,0);}]
          {}; % no pic type specified
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pics/code",
      meta = "⟨code⟩"
    },
    ["pics/foreground code"] = {
      details = [[
This key stores ⟨code⟩ that will always be drawn in front of the current
path, even when `behind path` is used. If `behind path` is not used and
`code` is (also) set, the code of `code` is drawn first, following by
the foreground ⟨code⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pics/foreground:code",
      meta = "⟨code⟩"
    },
    pin = {
      details = [[
This option is quite similar to the `label` option, but there is one
difference: In addition to adding an extra node to the picture, it also
adds an edge from this node to the main node. This causes the node to
look like a pin that has been added to the main node:

    \tikz \node [circle,fill=blue!50,minimum size=1cm,pin=60:$q_0$] {};

The meaning of the ⟨options⟩ and the ⟨angle⟩ and the ⟨text⟩ is exactly
the same as for the `node` option. Only, the options and styles the
influence the way pins look are different:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pin",
      meta = "[⟨options⟩]⟨angle⟩:⟨text⟩"
    },
    ["pin distance"] = {
      details = [[
This ⟨distance⟩ is used instead of the `label distance` for the distance
between the main node and the label node.

    \tikz[pin distance=1cm]
      \node [circle,draw,pin=right:X,
                         pin=above right:Y,
                         pin=above:Z]       {my circle};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pin:distance",
      meta = "⟨distance⟩"
    },
    ["pin edge"] = {
      details = [[
This option can be used to set the options that are to be used in the
edge created by the `pin` option.

    \tikz[pin distance=10mm]
      \node [circle,draw,pin={[pin edge={blue,thick}]right:X},
                         pin=above:Z]       {my circle};

    \tikz [every pin edge/.style={},
           initial/.style={pin={[pin distance=5mm,
                                 pin edge={<-,shorten <=1pt}]left:start}}]
      \node [circle,draw,initial] {my circle};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pin:edge",
      meta = "⟨options⟩"
    },
    ["pin position"] = {
      details = [[
The default pin position. Works like `label position`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pin:position",
      meta = "⟨angle⟩"
    },
    place = {
      details = [[
This style indicates that a node is a place of a Petri net. Usually, the
text of the node should be empty since places do not contain any text.
You should use the `label` option to add text outside the node like its
name or its capacity. You should use the `tokens` options, explained in
Section ??, to add tokens inside the place.

    \begin{tikzpicture}
      \node[place,label=above:$p_1$,tokens=2]        (p1) {};
      \node[place,label=below:$p_2\ge1$,right=of p1] (p2) {};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/place"
    },
    ["plane origin"] = {
      details = [[
Origin of the plane.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/plane:origin",
      meta = "⟨point⟩"
    },
    ["plane x"] = {
      details = [[
Unit vector of the $x$-direction in the new plane.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/plane:x",
      meta = "⟨point⟩"
    },
    ["plane y"] = {
      details = [[
Unit vector of the $y$-direction in the new plane.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/plane:y",
      meta = "⟨point⟩"
    },
    ["point down"] = {
      details = [[
This is the same as `rotate=-90`.

    \tikz [circuit ee IEC] \node [diode,point down] {};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/point:down"
    },
    ["point left"] = {
      details = [[
This is the same as `rotate=-180`.

    \tikz [circuit ee IEC] \node [diode,point left] {};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/point:left"
    },
    ["point right"] = {
      details = [[
This key has no effect.

    \tikz [circuit ee IEC] \node [diode,point right] {};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/point:right"
    },
    ["point up"] = {
      details = [[
This is the same as `rotate=90`.

    \tikz [circuit ee IEC] \node [diode,point up] {};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/point:up"
    },
    ["polar comb"] = {
      details = [[
This option causes a line from the origin to the point to be added to
the path for each plot point.

    \tikz \draw plot[polar comb,
         mark=pentagon*,mark options={fill=white,draw=red},mark size=4pt]
       coordinates {(0:1cm) (30:1.5cm) (160:.5cm) (250:2cm) (-60:.8cm)};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/polar:comb"
    },
    pos = {
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pos",
      meta = "⟨fraction⟩"
    },
    post = {
      details = [[
This style is also used with paths leading *from* a transition *to* a
place, but this time the place is in the post-set of the transition.
Again, feel free to redefine it.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/post"
    },
    postaction = {
      details = [[
The postactions work in the same way as the preactions, only they are
applied *after* the main action has been taken. Like preactions,
multiple `postaction` options may be given to a `\path` command, in
which case the path is reused several times, each time with a different
set of options in force.

If both pre- and postactions are specified, then the preactions are
taken first, then the main action, and then the post actions.

In the first example, we use a postaction to draw the path, after it has
already been drawn:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);

      \draw
        [postaction={draw,line width=2mm,blue}]
        [line width=4mm,red,fill=white] (0,0) rectangle (2,2);
    \end{tikzpicture}

In another example, we use a postaction to "colorize" a path:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw
        [postaction={path fading=south,fill=white}]
        [postaction={path fading=south,fading angle=45,fill=blue,opacity=.5}]
        [left color=black,right color=red,draw=white,line width=2mm]
                   (0,0) rectangle (1,2)
                   (1,2) circle (5mm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/postaction",
      meta = "⟨options⟩"
    },
    pre = {
      details = [[
This style can be used with paths leading *from* a transition *to* a
place to indicate that the place is in the pre-set of the transition. By
default, this style is `<-,shorten <=1pt`, but feel free to redefine it.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pre"
    },
    ["pre and post"] = {
      details = [[
This style is to be used to indicate that a place is both in the pre-
and post-set of a transition.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/pre:and:post"
    },
    preaction = {
      details = [[
This option can be given to a `\path` command (or to derived commands
like `\draw` which internally call `\path`). Similarly to options like
`draw`, this option only has an effect when given to a `\path` or as
part of the options of a `node`; as an option to a `{scope}` it has no
effect.

When this option is used on a `\path`, the effect is the following: When
the path has been completely constructed and is about to be used, a
scope is created. Inside this scope, the path is used but not with the
original path options, but with ⟨options⟩ instead. Then, the path is
used in the usual manner. In other words, the path is used twice: Once
with ⟨options⟩ in force and then again with the normal path options in
force.

Here is an example in which the path consists of a rectangle. The main
action is to draw this path in red (which is why we see a red
rectangle). However, the preaction is to draw the path in blue, which is
why we see a blue rectangle behind the red rectangle.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);

      \draw
        [preaction={draw,line width=4mm,blue}]
        [line width=2mm,red] (0,0) rectangle (2,2);
    \end{tikzpicture}

Note that when the preactions are preformed, then the path is already
"finished". In particular, applying a coordinate transformation to the
path has no effect. By comparison, applying a canvas transformation does
have an effect. Let us use this to add a "shadow" to a path. For this,
we use the preaction to fill the path in gray, shifted a bit to the
right and down:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw
        [preaction={fill=black,opacity=.5,
                    transform canvas={xshift=1mm,yshift=-1mm}}]
        [fill=red] (0,0) rectangle (1,2)
                   (1,2) circle (5mm);
    \end{tikzpicture}

Naturally, you would normally create a style `shadow` that contains the
above code. The `shadows` library, see Section ??, contains predefined
shadows of this kind.

It is possible to use the `preaction` option multiple times. In this
case, for each use of the `preaction` option, the path is used again
(thus, the ⟨options⟩ do not accumulate in a single usage of the path).
The path is used in the order of `preaction` options given.

In the following example, we use one `preaction` to add a shadow and
another to provide a shading, while the main action is to use a pattern.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw [pattern=fivepointed stars]
        [preaction={fill=black,opacity=.5,
                    transform canvas={xshift=1mm,yshift=-1mm}}]
        [preaction={top color=blue,bottom color=white}]
                   (0,0) rectangle (1,2)
                   (1,2) circle (5mm);
    \end{tikzpicture}

A complicated application is shown in the following example, where the
path is used several times with different fadings and shadings to create
a special visual effect:

    \begin{tikzpicture}
      [
        % Define an interesting style
        button/.style={
          % First preaction: Fuzzy shadow
          preaction={fill=black,path fading=circle with fuzzy edge 20 percent,
                     opacity=.5,transform canvas={xshift=1mm,yshift=-1mm}},
          % Second preaction: Background pattern
          preaction={pattern=#1,
                     path fading=circle with fuzzy edge 15 percent},
          % Third preaction: Make background shiny
          preaction={top color=white,
                     bottom color=black!50,
                     shading angle=45,
                     path fading=circle with fuzzy edge 15 percent,
                     opacity=0.2},
          % Fourth preaction: Make edge especially shiny
          preaction={path fading=fuzzy ring 15 percent,
                     top color=black!5,
                     bottom color=black!80,
                     shading angle=45},
          inner sep=2ex
        },
        button/.default=horizontal lines light blue,
        circle
      ]

      \draw [help lines] (0,0) grid (4,3);

      \node [button] at (2.2,1) {\Huge Big};
      \node [button=crosshatch dots light steel blue,
             text=white] at (1,1.5) {Small};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/preaction",
      meta = "⟨options⟩"
    },
    prefix = {
      details = [[
The ⟨prefix⟩ is put before each plot file name. The default is
`\jobname.`, but if you have many plots, it might be better to use, say
`plots/` and have all plots placed in a directory. You have to create
the directory yourself.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/prefix",
      meta = "⟨prefix⟩"
    },
    ["prefix after command"] = {
      details = [[
Works like `append after command`, only the accumulation order is
inverse: The ⟨path⟩ is added before any earlier paths added using either
`append after command` or `prefix after command`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/prefix:after:command",
      meta = "⟨path⟩"
    },
    ["quotes mean label"] = {
      details = [[
When this option is used (which is the default when this library is
loaded), then, as described above, inside the options of a node a
special syntax check is done.

**The syntax.** For each string in the list of options it is tested
whether it starts with a quotation mark (note that this will never
happen for normal keys since the normal keys of TikZ do not start with
quotation marks). When this happens, the ⟨string⟩ should not be a
key--value pair, but, rather, must have the form:

> `"`⟨text⟩`"``’`⟨options⟩

(We will discuss the optional apostrophe in a moment. It is not really
important for the current option, but only for edge labels, which are
discussed later).

**Transformation to a label option.** When a ⟨string⟩ has the above
form, it is treated (almost) as if you had written

> `label={[`⟨options⟩`]`⟨text⟩`}`

instead. The "almost" refers to the following additional feature: In
reality, before the ⟨options⟩ are executed inside the `label` command,
the direction keys `above`, `left`, `below right` and so on are
redefined so that `above` is a shorthand for `label position=90` and
similarly for the other keys. The net effect is that in order to specify
the position of the ⟨text⟩ relative to the main node you can just put
something like `left` or `above right` inside the ⟨options⟩:

    \tikz
      \node ["$90^\circ$" above, "$180^\circ$" left, circle, draw] {circle};

Alternatively, you can also use ⟨direction⟩`:`⟨actual text⟩ as your
⟨text⟩. This works since the `label` command allows you to specify a
direction at the beginning when it is separated by a colon:

    \tikz
      \node ["90:$90^\circ$", "left:$180^\circ$", circle, draw] {circle};

Arguably, placing `above` or `left` behind the ⟨text⟩ seems more natural
than having it inside the ⟨text⟩.

In addition to the above, before the ⟨options⟩ are executed, the
following style is also executed:

**Handling commas and colons inside the text.** The ⟨text⟩ may not
contain a comma, unless it is inside curly braces. The reason is that
the key handler separates the total options of a `node` along the commas
it finds. So, in order to have text containing a comma, just add curly
braces around either the comma or just around the whole ⟨text⟩:

    \tikz \node ["{yes, we can}", draw] {foo};

The same is true for a colon, only in this case you may need to surround
specifically the colon by curly braces to stop the `label` option from
interpreting everything before the colon as a direction:

    \tikz \node ["yes{:} we can", draw] {foo};

**The optional apostrophe.** Following the closing quotation marks in a
⟨string⟩ there may (but need not) be a single quotation mark (an
apostrophe), possibly surrounded by whitespaces. If it is present, it is
simply added to the ⟨options⟩ as another option (and, indeed, a single
apostrophe is a legal option in TikZ, it is a shorthand for `swap`):

  String           has the same effect as
  ---------------- --------------------------------------------------
  `"foo"’`         `"foo" {’}`
  `"foo"’ red`     `"foo" {’,red}`
  `"foo"’{red}`    `"foo" {’,red}`
  `"foo"{’,red}`   `"foo" {’,red}`
  `"foo"{red,’}`   `"foo" {red,’}`
  `"foo"{’red}`    `"foo" {’red}` (illegal; there is no key `’red`)
  `"foo" red’`     `"foo" {red’}` (illegal; there is no key `red’`)
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/quotes:mean:label"
    },
    ["quotes mean pin"] = {
      details = [[
This option has exactly the same effect as `quotes mean label`, only
instead of transforming quoted text to the `label` option, they get
transformed to the `pin` option:

    \tikz [quotes mean pin]
      \node ["$90^\circ$" above, "$180^\circ$" left, circle, draw] {circle};

Instead of `every label quotes`, the following style is executed with
each such pin:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/quotes:mean:pin"
    },
    radius = {
      details = [[
Sets the `x radius` and `y radius` simultaneously.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/radius",
      meta = "⟨value⟩"
    },
    range = {
      details = [[
This key sets the range of the plot. If set, all points whose
$y$-coordinates lie outside this range will be considered to be outliers
and will cause jumps in the plot, by default:

    \tikz \draw[scale=0.5,domain=-3.141:3.141, samples=100, smooth, range=-3:3]
      plot[id=tan-example] function{tan(x)};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/range",
      meta = "⟨start⟩:⟨end⟩"
    },
    ["raw gnuplot"] = {
      details = [[
This key causes the ⟨gnuplot formula⟩ to be passed on to GNUPLOT without
setting up the samples or the `plot` operation. Thus, you could write

    plot[raw gnuplot,id=raw-example] function{set samples 25; plot sin(x)}

This can be useful for complicated things that need to be passed to
GNUPLOT. However, for really complicated situations you should create a
special external generating GNUPLOT file and use the `file`-syntax to
include the table "by hand".
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/raw:gnuplot"
    },
    ["rdf engine"] = {
      details = [[
This key only has an effect when `rdf engine on` is called, otherwise
the argument is silently ignored. The ⟨rdf keys⟩ get executed with the
path prefix `/tikz/rdf engine` at the beginning of the current scope
(for a node, at the beginning of the node's scope). Depending on which
keys are used, semantic information gets to be added to the output.

Note that you cannot simply the keys with path prefix `/tikz/rdf engine`
directly since they need to be executed at very specific times during
TikZ's processing of scopes. Always call those keys via this key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine",
      meta = "⟨rdf keys⟩"
    },
    ["rdf engine on"] = {
      details = [[
Switches "on" the generation of RDF information for the current
TeX scope. The idea is that libraries can internally use the
`rdf engine` key (explained below) a lot in order to provide good
semantic information in the output when desired, but need not worry that
this will bloat output files since users have to use this key explicitly
to include semantic information in the output.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine:on"
    },
    ["rdf engine/get new resource curie"] = {
      details = [[
The ⟨macro⟩ will be set to a new unique curie that can be used anywhere
where a curie is allowed. Here is an example how we can add a state and
a transition container to an automaton, both of which have no
corresponding scope in TikZ.

    \tikz [ name = my automaton,
            rdf engine = {
              get new resource curie = \statecurie,
              get new resource curie = \transitiocurie,
              statement = {
                subject   = (my automaton),
                predicate = automata:hasStateSet,
                object    = \statecurie },
              statement = {
                subject   = \statecurie,
                hat type  = automata:stateSet },
              statement = {
                subject   = (my automaton),
                predicate = automata:hasTransitionSet,
                object    = \transitiocurie },
              statement = {
                subject   = \transitiocurie,
                hat type  = automata:transitionSet } } ] { ... }

The ⟨macro⟩ will be valid for the whole scope.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/get:new:resource:curie",
      meta = "⟨macro⟩"
    },
    ["rdf engine/get scope curie"] = {
      details = [[
The ⟨macro⟩ will be set to a unique curie that represents the scope or
node. If the scope is named (using the `name` key or the special
parenthesis syntax for nodes) and this name is later referenced in
another statement, the same curie will be generated. Note how in the
following code no name is given for the automaton, which means that the
whole RDF code could be moved inside a style like `finite automaton` or
something similar.

    \tikz [ rdf engine = {
              get new resource curie = \statecurie,
              get new resource curie = \transitiocurie,
              get scope curie = \automatoncurie,
              statement = {
                subject   = \automatoncurie,
                predicate = automata:hasStateSet,
                object    = \statecurie },
              statement = {
                subject   = \statecurie,
                hat type  = automata:stateSet },
              statement = {
                subject   = \automatoncurie,
                predicate = automata:hasTransitionSet,
                object    = \transitiocurie },
              statement = {
                subject   = \transitiocurie,
                hat type  = automata:transitionSet } } ] { ... }

The ⟨macro⟩ will be valid for the whole scope.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/get:scope:curie",
      meta = "⟨macro⟩"
    },
    ["rdf engine/prefix"] = {
      details = [[
Inside the current scope, you can use ⟨prefix⟩`:` inside curies (compact
universal resource identifier expressions, see the RDFA specification)
as an abbreviation for the ⟨iri⟩. (It has the same effect as the
`prefix` attribute in RDFa.) You can use this key several times for a
given scope.

    \scoped [rdf engine = {
      prefix = {rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns\tikzrdfhashmark},
      prefix = {automata: http://www.tcs.uni-luebeck.de/ontologies/2016/04/28/automata/},
      statement = { ..., predicate = rdf:type, object = automata:state },
      statement = { ..., predicate = rdf:type, object = automata:final },
      }] ...

The above could also be written more verbosely as

    \scoped [rdf engine = {
      statement = { ...,
        predicate = http://www.w3.org/1999/02/22-rdf-syntax-ns\tikzrdfhashmark type,
        object = http://www.tcs.uni-luebeck.de/ontologies/2016/04/28/automata/state }
      },
      statement = { ...,
        predicate = http://www.w3.org/1999/02/22-rdf-syntax-ns\tikzrdfhashmark type,
        object = http://www.tcs.uni-luebeck.de/ontologies/2016/04/28/automata/final }
      }] ...

The use of the command `\tikzrdfhashmark` is necessary since TeX assigns
a special meaning to hash marks. The command simple expands to a
"normal" hash mark for use in texts.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/prefix",
      meta = "⟨prefix: iri⟩"
    },
    ["rdf engine/scope is new context"] = {
      details = [[
This key executes `get scope curie=\tikzrdfcontext`, thereby setting the
macro `\tikzrdfcontext` to the current scope. The idea is the key is
used with "major resources" and that keys can use this macro as the
`subject` of statements if no subject is given explicitly. For instance,
a `title` key might be defined as follows:

    title/.style = {
      rdf engine = { statement = {
          subject   = \tikzrdfcontext,
          predicate = dc:Title,
          object    = "#1"
    } } }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/scope:is:new:context"
    },
    ["rdf engine/statement"] = {
      details = [[
Each use of this key will add one RDF statement to the output file. The
⟨options⟩ will be executed with the path prefix
`/tikz/rdf engine/statements` and must use the three keys `subject`,
`predicate`, and `object` to specify the three components of the
statement (these keys can, however, be called by styles internally, so
not all statements will explicitly set these three keys). Note that *all
three must always be set*, it is *not* possible to setup, say, just a
subject for a scope and then omit the subject for statements inside the
scope. (However, using styles you can setup things in such a way that a
certain subject is used for several statements.)

    \tikz [rdf engine = {
      statement = {
        subject   = http://www.example.org/persons/Einstein,
        predicate = http://www.example.org/predicates/isA,
        object    = http://www.example.org/professions/physicist
      },
      statement = {
        subject   = http://www.example.org/persons/Curie,
        predicate = http://www.example.org/predicates/isA,
        object    = http://www.example.org/professions/physicist
      }}] { ... }

The statements are normally added at the beginning of the scope where
the `rdf enging` command is used (except when the `object` is
`scope content`, which is explained later). This means that when you use
`prefix` inside an `rdf engine` command, it will apply to all
statements, regardless of the order.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statement",
      meta = "{options}"
    },
    ["rdf engine/statements/has as member"] = {
      details = [[
This key may only be added to statements whose subject was previously
used as a subject in a statement containing the `is a container` key. In
this case, the internal counter will be increased and the predicate will
be set to `rdf:_ `⟨count⟩. This means that we can write the above code
as:

    \tikz { ...

      \scoped [rdf engine = {
        statement = {
          subject   = (safe),
          has type  = rdf:Seq,
          is a container,
        },
        statement = {
          subject   = (safe),
          has as member,
          object    = (coins)
        },
        statement = {
          subject   = (safe),
          has as member,
          object    = (gold)
        } }];
    }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/has:as:member"
    },
    ["rdf engine/statements/has type"] = {
      details = [[
This style is a shorthand for `predicate=rdf:type` and `object=`⟨type⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/has:type",
      meta = "⟨type⟩"
    },
    ["rdf engine/statements/is a bag"] = {
      details = [[
This is a shorthand for `predicate = rdf:Bag, is a container`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/is:a:bag"
    },
    ["rdf engine/statements/is a container"] = {
      details = [[
Add this key to a statement in order to tell TikZ that it should setup a
special counter for the subject of the statement that keeps track of the
container's children.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/is:a:container"
    },
    ["rdf engine/statements/is a sequence"] = {
      details = [[
This is a shorthand for `predicate = rdf:Seq, is a container`. In the
above example we could say:

    \tikz { ...

      \scoped [rdf engine = {
        statement = {
          subject   = (safe),
          is a sequence
        },
        ... } ]; }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/is:a:sequence"
    },
    ["rdf engine/statements/is an alternative"] = {
      details = [[
This is a shorthand for `predicate = rdf:Alt, is a container`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/is:an:alternative"
    },
    ["rdf engine/statements/object"] = {
      details = [[
Sets the object for the statement. The syntax allowed for the ⟨object⟩
is as follows:

1.  As for `subject` and `predicate` you can use a curie here. This is
    the default unless one of the following special cases is used:

2.  As for `subject` and `predicate`, you can use the syntax `(`⟨name of
    node or scope⟩`)` to create and use a curie for the node or scope.

3.  If the ⟨object⟩ starts with `"`, it must have the syntax
    `"`⟨literals⟩`"`. In this case, the object of the statement is not a
    curie (not a normal "resource") but the string of ⟨literals⟩ given.

4.  If the ⟨object⟩ is the text "`scope content`", the object of the
    statement is actually the whole contents of the scope to which this
    statement is attached.

5.  The two previous cases can be combined in the form of an object of
    the form `"`⟨literals⟩`" and scope content`. In this case, the
    contents of the scope is "normally" the object, but this gets
    "overruled" by the ⟨literals⟩. Formally, this means that the object
    is the ⟨literals⟩, but the intended semantics is that the object is
    the scope content, only for further processing it should be
    considered to be ⟨literals⟩. A typical example is the case where the
    scope content is, say, the text "January 1st, 2000" but the
    ⟨literals⟩ are set to `2000-01-01`, which is easier for software to
    process:

        \node [rdf engine = {
          statement = {
            subject = ...,
            predicate = dc:Date,
            object = "2000-01-01" and scope content
          } } ] { January 1st, 2000 };

For the last two cases, only one statement may be given per scope that
has the `scope content` as its object; if more than one is given, the
last one wins. This is the reason why several uses of `predicate` are
allowed in a `statement`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/object",
      meta = "⟨object⟩"
    },
    ["rdf engine/statements/predicate"] = {
      details = [[
Sets the predicate for the statement. The syntax is exactly the same as
for the subject. Unlike for subjects, you can use the predicate key
several times inside a single statement and the uses will "accumulate"
and several statements are created, namely one statement for each use of
`predicate` for the subject and object specified inside the use of
`statement`. This behavior is not very systematic (it violates the rule
"one statement per `statement`") and you should normally use the
`statement` once for each use of the `predicate` key. However, in
conjunction with the object `scope content` it is necessary to allow
this behavior.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/predicate",
      meta = "⟨predicate⟩"
    },
    ["rdf engine/statements/subject"] = {
      details = [[
Sets the subject of the to-be-created statement. The ⟨subject⟩ can be in
one of two possible formats:

1.  A curie (a *compact universal resource identifier expression,* see
    the RDFA specification for details). Examples are standard URLs like
    `http://www.example.org`, but also text like `# my_ automaton`. Note
    that in order to include a hashmark in a curie you should use the
    command `\tikzrdfhashmark`, which expands to a hash mark (TeX treats
    hash marks in a special way, which is why this command is used
    here).

2.  When the ⟨subject⟩ starts with an opening parenthesis, that is, with
    "`(`", the ⟨subject⟩ must have the form `(`⟨node or scope name⟩`)`.
    In this case, the ⟨node or scope name⟩ must be the name of an
    already existing node (the current node or scope is considered as
    "existing" here). Then, the curie `# `⟨id⟩ is used as subject, where
    the ⟨id⟩ is a unique internal identifier for the node.

    As an example, suppose you wish to specify that a node has some
    other node as child, you could write the following:

        \tikz [ rdf engine = { prefix = { rels: http://www.example.org/relations/} } ] {
          \node (fritz)          { Fritz };
          \node (heinz) at (2,0) { Heinz };
          \draw [->] (fritz) -- (heinz)
                [rdf engine = {
                  statement = {
                    subject = (fritz),
                    predicate = rels:isSonOf,
                    object  = (heinz)
                  } } ];
        }

You can use a macro as ⟨subject⟩, it will be expanded before the above
syntax check is done.

If you use the `subject` key several times inside a single `statement`
command, (only) the last subject is used.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/subject",
      meta = "⟨subject⟩"
    },
    relationship = {
      details = [[
This style works like `entity`, only it is to be used for relationships.
Again, `relationship`s are actually relationship types.

    \begin{tikzpicture}
      \node[entity] (sheep)  at (0,0)   {Sheep};
      \node[entity] (genome) at (2,0)   {Genome};
      \node[relationship]    at (1,1.5) {has}
        edge (sheep)
        edge (genome);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/relationship"
    },
    relative = {
      details = [[
This option tells TikZ whether the `in` and `out` angles should be
considered absolute or relative. Absolute means that an `out` angle of
30$^\circ$ means that the curve leaves the start coordinate at an angle
of 30$^\circ$ relative to the paper (unless, of course, further
transformations have been installed). A *relative* angle is, by
comparison, measured relative to a straight line from the start
coordinate to the target coordinate. Thus, a relative angle of
30$^\circ$ means that the curve will bend to the left from the line
going straight from the start to the target. For the target, the
relative coordinate is measured in the same manner, namely relative to
the line going from the start to the target. Thus, an angle of
150$^\circ$ means that the curve will reach target coming slightly from
the left.

    \begin{tikzpicture}[out=45,in=135,relative]
      \draw (0,0) to (1,0)
                  to (2,1)
                  to (2,2);
    \end{tikzpicture}

    \begin{tikzpicture}[out=90,in=90,relative]
      \node [circle,draw] (a) at (0,0) {a};
      \node [circle,draw] (b) at (1,1) {b};
      \node [circle,draw] (c) at (2,2) {c};

      \path (a) edge (b)
                edge (c);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/relative",
      meta = "⟨true or false⟩"
    },
    ["remember picture"] = {
      details = [[
This option tells TikZ that it should attempt to remember the position
of the current picture on the page. This attempt may fail depending on
which backend driver is used. Also, even if remembering works, the
position may only be available on a second run of TeX.

Provided that remembering works, you may consider saying

    \tikzset{every picture/.append style={remember picture}}

to make TikZ remember all pictures. This will add one line in the `.aux`
file for each picture in your document -- which typically is not very
much. Then, you do not have to worry about remembered pictures at all.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/remember:picture",
      meta = "⟨boolean⟩"
    },
    ["reset cm"] = {
      details = [[
Completely resets the coordinate transformation matrix to the identity
matrix. This will destroy not only the transformations applied in the
current scope, but also all transformations inherited from surrounding
scopes. Do not use this option, unless you really, really know what you
are doing.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/reset:cm"
    },
    resistor = {
      details = [[
This key should be used with a `node` path command or with the `to` path
command.

**Using the Key with Normal Nodes.** When used with a node, it will
cause this node to "look like" a resistor (by default, in the IEC
library, this is just a simple rectangle).

    \tikz [circuit ee IEC]
      \node [resistor] {};

Unlike normal nodes, a resistor node generally should not take any text
(as in `node [resistor] {foo}`). Instead, the labeling of resistors
should be done using the `label`, `info` and `ohm` options.

    \tikz [circuit ee IEC]
      \node [resistor,ohm=5] {};

The ⟨options⟩ make no real sense when the `resistor` option is used with
a normal node, you can just as well given them to the `node` itself.
Thus, the following has the same effect as the above example:

    \tikz [circuit ee IEC]
      \node [resistor={ohm=5}] {};

In a circuit, you will often wish to rotate elements. For this, the
options `point up`, `point down`, `point left` or `point right` may be
especially useful. They are just shorthands for appropriate rotations
like `rotate=90`.

    \tikz [circuit ee IEC] {
      \node (R1) [resistor,point up,ohm=5] at (3,1) {};
      \node (R2) [resistor,ohm=10k]        at (0,0) {};
      \draw (R2) -| (R1);
    }

**Using the Key on a To Path.** When the `resistor` key is used on a
`to` path inside a `circuit ee IEC`, the `circuit handle symbol` key is
called internally. This has a whole bunch of effects:

1.  The path currently being constructed is cut up to make place for a
    node.

2.  This node will be a `resistor node` that is rotated so that it
    points "along" the path (unless an option like `shift only` or an
    extra rotation is used to change this).

3.  The ⟨options⟩ passed to the `resistor` key are passed on to the
    node.

4.  The ⟨options⟩ are pre-parsed to identify a `pos` key or a key like
    `at start` or `midway`. These keys are used to determine where on
    the `to` path the node will lie.

Since the ⟨options⟩ of the `resistor` key are passed on to the resistor
node on the path, you can use it to add labels to the node. Here is a
simple example:

    \tikz [circuit ee IEC]
      \draw (0,0) to [resistor=red]        (3,0)
                  to [resistor={ohm=2\mu}] (3,2);

You can add multiple labels to a resistor and you can have multiple
resistors (or other elements) on a single path.

**Inputs, Outputs, and Anchors.** Like the logical gates, all ee-symbols
have an `input` and an `output` anchor. Special-purpose-nodes may have
even more anchors of this type. Furthermore, the ee-symbols-nodes also
have four standard compass direction anchors.

**Changing the Appearance.** To configure the appearance of all
`resistor`s, see Section ??. You can use the ⟨options⟩ to locally change
the appearance of a single resistor.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/resistor",
      meta = "⟨options⟩"
    },
    right = {
      details = [[
Similar to `above`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/right",
      meta = "⟨offset⟩"
    },
    ["right color"] = {
      details = [[
Works like `left color`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/right:color",
      meta = "⟨color⟩"
    },
    ["right delimiter"] = {
      details = [[
Works as above.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/right:delimiter",
      meta = "⟨delimiter⟩"
    },
    ["right of"] = {
      details = [[

]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/right:of",
      meta = "⟨node⟩"
    },
    ["root concept"] = {
      details = [[
This style is used for the roots of mindmap trees. By adding something
to this, you can change how the root of a mindmap will be rendered.

    \tikz
      [root concept/.append style={concept color=blue!80,minimum size=3.5cm},
       mindmap]
      \node [concept] {Root concept};

Note that styles like `large mindmap` redefine these styles, so you
should add something to this style only inside the picture.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/root:concept"
    },
    rotate = {
      details = [[
Rotates the coordinate system by ⟨degree⟩:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                 (0,0) -- (1,1) -- (1,0);
      \draw[rotate=40,blue] (0,0) -- (1,1) -- (1,0);
      \draw[rotate=-20,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rotate",
      meta = "⟨degree⟩"
    },
    ["rotate around"] = {
      details = [[
Rotates the coordinate system by ⟨degree⟩ around the point ⟨coordinate⟩.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                                (0,0) -- (1,1) -- (1,0);
      \draw[rotate around={40:(1,1)},blue] (0,0) -- (1,1) -- (1,0);
      \draw[rotate around={-20:(1,1)},red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rotate:around",
      meta = "{⟨degree⟩:⟨coordinate⟩}"
    },
    ["rotate around x"] = {
      details = [[
This key sets the $x$, $y$ and $z$ vectors of the PGF $xyz$-coordinate
system so that they are rotated by ⟨angle⟩ around the axis corresponding
to the $x$-vector. The rotation is applied so that when looking towards
the origin along this axis, positive angles result in an anticlockwise
rotation.

    \begin{tikzpicture}[>=stealth]
      \draw [->] (0,0,0) -- (2,0,0) node [at end, right] {$x$};
      \draw [->] (0,0,0) -- (0,2,0) node [at end, left]  {$y$};
      \draw [->] (0,0,0) -- (0,0,2) node [at end, left]  {$z$};

      \draw [red,   rotate around x=0]  (0,0,0) -- (1,1,0) -- (1,0,0);
      \draw [green, rotate around x=45] (0,0,0) -- (1,1,0) -- (1,0,0);
      \draw [blue,  rotate around x=90] (0,0,0) -- (1,1,0) -- (1,0,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rotate:around:x",
      meta = "⟨angle⟩"
    },
    ["rotate around y"] = {
      details = [[
This key sets the $x$, $y$ and $z$ vectors of the PGF $xyz$-coordinate
system so that they are rotated by ⟨angle⟩ around the axis corresponding
to the $y$-vector. The rotation is applied so that when looking towards
the origin along this axis, positive angles result in an anticlockwise
rotation.

    \begin{tikzpicture}[>=stealth]
      \draw [->] (0,0,0) -- (2,0,0) node [at end, right] {$x$};
      \draw [->] (0,0,0) -- (0,2,0) node [at end, left]  {$y$};
      \draw [->] (0,0,0) -- (0,0,2) node [at end, left]  {$z$};

      \draw [red,   rotate around y=0]   (0,0,0) -- (1,1,0) -- (1,0,0);
      \draw [green, rotate around y=-45] (0,0,0) -- (1,1,0) -- (1,0,0);
      \draw [blue,  rotate around y=-90] (0,0,0) -- (1,1,0) -- (1,0,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rotate:around:y",
      meta = "⟨angle⟩"
    },
    ["rotate around z"] = {
      details = [[
This key sets the $x$, $y$ and $z$ vectors of the PGF $xyz$-coordinate
system so that they are rotated by ⟨angle⟩ around the axis corresponding
to the $z$-vector. The rotation is applied so that when looking towards
the origin along this axis, positive angles result in an anticlockwise
rotation.

    \begin{tikzpicture}[>=stealth]
      \draw [->] (0,0,0) -- (2,0,0) node [at end, right] {$x$};
      \draw [->] (0,0,0) -- (0,2,0) node [at end, left]  {$y$};
      \draw [->] (0,0,0) -- (0,0,2) node [at end, left]  {$z$};

      \draw [red,   rotate around z=0]  (0,0) -- (1,1) -- (1,0);
      \draw [green, rotate around z=45] (0,0) -- (1,1) -- (1,0);
      \draw [blue,  rotate around z=90] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rotate:around:z",
      meta = "⟨angle⟩"
    },
    ["rotate fit"] = {
      details = [[
This key fits ⟨coordinates or nodes⟩ inside a node that is rotated by
⟨angle⟩. As a side effect, it also sets the `/tikz/rotate` key.

    \begin{tikzpicture}[inner sep=0pt,thick,
      dot/.style={fill=blue,circle,minimum size=3pt}]
      \draw[help lines] (0,0) grid (3,2);
      \node[dot] (a) at (1,1) {};
      \node[dot] (b) at (2,2) {};
      \node[dot] (c) at (1,2) {};
      \node[dot] (d) at (1.25,0.25) {};
      \node[dot] (e) at (1.75,1.5) {};
      \node[draw, fit=(a) (b) (c) (d) (e)] {};
      \node[draw=red, rotate fit=30, fit=(a) (b) (c) (d) (e)] {};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rotate:fit",
      meta = "⟨angle⟩"
    },
    ["rounded corners"] = {
      details = [[
When this option is in force, all corners (places where a line is
continued either via line-to or a curve-to operation) are replaced by
little arcs so that the corner becomes smooth.

    \tikz \draw [rounded corners] (0,0) -- (1,1)
               -- (2,0) .. controls (3,1) .. (4,0);

The ⟨inset⟩ describes how big the corner is. Note that the ⟨inset⟩ is
*not* scaled along if you use a scaling option like `scale=2`.

    \begin{tikzpicture}
      \draw[color=gray,very thin] (10pt,15pt) circle[radius=10pt];
      \draw[rounded corners=10pt] (0,0) -- (0pt,25pt) -- (40pt,25pt);
    \end{tikzpicture}

You can switch the rounded corners on and off "in the middle of path"
and different corners in the same path can have different corner radii:

    \begin{tikzpicture}
      \draw (0,0) [rounded corners=10pt] -- (1,1) -- (2,1)
                         [sharp corners] -- (2,0)
                   [rounded corners=5pt] -- cycle;
    \end{tikzpicture}

Here is a rectangle with rounded corners:

    \tikz \draw[rounded corners=1ex] (0,0) rectangle (20pt,2ex);

You should be aware, that there are several pitfalls when using this
option. First, the rounded corner will only be an arc (part of a circle)
if the angle is $90^\circ$. In other cases, the rounded corner will
still be round, but "not as nice".

Second, if there are very short line segments in a path, the "rounding"
may cause inadvertent effects. In such case it may be necessary to
temporarily switch off the rounding using `sharp corners`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/rounded:corners",
      meta = "⟨inset⟩"
    },
    ["row sep"] = {
      details = [[
This option works like `column sep`, only for rows. Here, too, you can
specify whether the space is added between the lower end of the first
row and the upper end of the second row, or whether the space is
computed between the origins of the two rows.

    \begin{tikzpicture}
      \matrix [draw,row sep=1cm,nodes=draw]
      {
        \node (a) {123}; & \node {1};   & \node {1}; \\
        \node (b) {12};  & \node {12};  & \node {1}; \\
        \node     {1};   & \node {123}; & \node {1}; \\
      };
      \draw [<->,red,thick] (a.south) -- (b.north) node [right,midway] {1cm};
    \end{tikzpicture}

    \begin{tikzpicture}
      \matrix [draw,row sep={1cm,between origins},nodes=draw]
      {
        \node (a) {123}; & \node {1};   & \node {1}; \\
        \node (b) {12};  & \node {12};  & \node {1}; \\
        \node     {1};   & \node {123}; & \node {1}; \\
      };
      \draw [<->,red,thick] (a.center) -- (b.center) node [right,midway] {1cm};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/row:sep",
      meta = "⟨spacing list⟩"
    },
    ["row ⟨number⟩"] = {
      details = [[
This style is used for every cell in row ⟨number⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/row:⟨number⟩"
    },
    ["row ⟨row number⟩ column ⟨column number⟩"] = {
      details = [[
This style is used for the cell in row ⟨row number⟩ and column ⟨column
number⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/row:⟨row:number⟩:column:⟨column:number⟩"
    },
    samples = {
      details = [[
Sets the number of samples used in the plot.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/samples",
      meta = "⟨number⟩"
    },
    ["samples at"] = {
      details = [[
This option specifies a list of positions for which the variable should
be evaluated. For instance, you can say `samples at={1,2,8,9,10}` to
have the variable evaluated exactly for values $1$, $2$, $8$, $9$, and
$10$. You can use the `\foreach` syntax, so you can use `...` inside the
⟨sample list⟩.

When this option is used, the `samples` and `domain` option are
overruled. The other way round, setting either `samples` or `domain`
will overrule this option.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/samples:at",
      meta = "⟨sample list⟩"
    },
    ["save path"] = {
      details = [[
Save the current soft path into ⟨macro⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/save:path",
      meta = "⟨macro⟩"
    },
    scale = {
      details = [[
Multiplies all coordinates by the given ⟨factor⟩. The ⟨factor⟩ should
not be excessively large in absolute terms or very close to zero.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw               (0,0) -- (1,1) -- (1,0);
      \draw[scale=2,blue] (0,0) -- (1,1) -- (1,0);
      \draw[scale=-1,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/scale",
      meta = "⟨factor⟩"
    },
    ["scale around"] = {
      details = [[
Scales the coordinate system by ⟨factor⟩, with the "origin of scaling"
centered on ⟨coordinate⟩ rather than the origin.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                             (0,0) -- (1,1) -- (1,0);
      \draw[scale=2,blue]               (0,0) -- (1,1) -- (1,0);
      \draw[scale around={2:(1,1)},red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/scale:around",
      meta = "{⟨factor⟩:⟨coordinate⟩}"
    },
    ["scope fading"] = {
      details = [[
In principle, this key works in exactly the same way as the
`path fading` key. The only difference is, that the effect of the fading
will persist after the current path till the end of the scope. Thus, the
⟨fading⟩ is applied to all subsequent drawings in the current scope, not
just to the current path. In this regard, the option works very much
like the `clip` option. (Note, however, that, unlike the `clip` option,
fadings to not accumulate unless a transparency group is used.)

The keys `fit fading` and `fading transform` have the same effect as for
`path fading`. Also that, just as for `path fading`, providing the
`scope fading` option with a `{scope}` only sets the name of the fading
to be used. You have to explicitly provide the `scope fading` with a
path to actually install a fading.

    \begin{tikzpicture}
      \fill [black!20] (-2,-2) rectangle (2,2);
      \pattern [pattern=checkerboard,pattern color=black!30]
                       (-2,-2) rectangle (2,2);

      % The bounding box of the shading:
      \draw [red] (-50bp,-50bp) rectangle (50bp,50bp);

      \path [scope fading=south,fit fading=false] (0,0);
      % fading is centered at its natural size

      \fill[red]   ( 90:1) circle (1);
      \fill[green] (210:1) circle (1);
      \fill[blue]  (330:1) circle (1);
    \end{tikzpicture}

In the following example we resize the fading to the size of the whole
picture:

    \begin{tikzpicture}
      \fill [black!20] (-2,-2) rectangle (2,2);
      \pattern [pattern=checkerboard,pattern color=black!30]
                       (-2,-2) rectangle (2,2);

      \path [scope fading=south] (-2,-2) rectangle (2,2);

      \fill[red]   ( 90:1) circle (1);
      \fill[green] (210:1) circle (1);
      \fill[blue]  (330:1) circle (1);
    \end{tikzpicture}

Scope fadings are also needed if you wish to fade a node.

    \tikz \node [scope fading=south,fading angle=45,text width=3.5cm]
    {
      This is some text that will fade out as we go right
      and down. It is pretty hard to achieve this effect in
      other ways.
    };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/scope:fading",
      meta = "⟨fading⟩"
    },
    semithick = {
      details = [[
Sets the line width to 0.6pt.

      \tikz \draw[semithick] (0,0) -- (1cm,1.5ex);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/semithick"
    },
    semitransparent = {
      details = [[
    \tikz{\fill[red]             (0,0)   rectangle (1,0.5);
          \fill[semitransparent] (0.5,0) rectangle (1.5,0.25); }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/semitransparent"
    },
    set = {
      details = [[
This key can be used as an option with a `node` command. The ⟨set name⟩
must be the name of a node set that has previously been created inside
some enclosing scope via the `new set` key. The effect is that the
current node is added to the node set.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/set",
      meta = "⟨set name⟩"
    },
    shade = {
      details = [[
Causes the path to be shaded using the currently selected shading (more
on this later). If this option is used together with the `draw` option,
then the path is first shaded, then drawn.

It is not an error to use this option together with the `fill` option,
but it makes no sense.

    \tikz \shade (0,0) circle (1ex);

    \tikz \shadedraw (0,0) circle (1ex);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shade"
    },
    shading = {
      details = [[
This selects a shading named ⟨name⟩. The following shadings are
predefined: `axis`, `radial`, and `ball`.

    \tikz \shadedraw [shading=axis] (0,0) rectangle (1,1);
    \tikz \shadedraw [shading=radial] (0,0) rectangle (1,1);
    \tikz \shadedraw [shading=ball] (0,0) circle (.5cm);

The shadings as well as additional shadings are described in more detail
in Section ??.

To change the color of a shading, special options are needed like
`left color`, which sets the color of an axis shading from left to
right. These options implicitly also select the correct shading type,
see the following example

    \tikz \shadedraw [left color=red,right color=blue]
        (0,0) rectangle (1,1);

For a complete list of the possible options see Section ?? once more.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shading",
      meta = "⟨name⟩"
    },
    ["shading angle"] = {
      details = [[
This option rotates the shading (not the path!) by the given angle. For
example, we can turn a top-to-bottom axis shading into a left-to-right
shading by rotating it by $90^\circ$.

    \tikz \shadedraw [shading=axis,shading angle=90] (0,0) rectangle (1,1);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shading:angle",
      meta = "⟨degrees⟩"
    },
    ["shadow scale"] = {
      details = [[
Shadows are scaled by ⟨factor⟩.

    \tikz [even odd rule]
      \draw [general shadow={fill=red,shadow scale=1.25}]
        (0,0) circle (.5) (0.5,0) circle (.5);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shadow:scale",
      meta = "⟨factor⟩"
    },
    ["shadow xshift"] = {
      details = [[
Shadows are shifted horizontally by ⟨dimension⟩.

    \tikz [even odd rule]
      \draw [general shadow={fill=red,shadow xshift=-5pt}]
        (0,0) circle (.5) (0.5,0) circle (.5);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shadow:xshift",
      meta = "⟨dimension⟩"
    },
    ["shadow yshift"] = {
      details = [[
Shadows are shifted vertically by ⟨dimension⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shadow:yshift",
      meta = "⟨dimension⟩"
    },
    shape = {
      details = [[
Select the shape either of the current node or, when this option is not
given inside a node but somewhere outside, the shape of all nodes in the
current scope.

Since this option is used often, you can leave out the `shape=`. When
TikZ encounters an option like `circle` that it does not know, it will,
after everything else has failed, check whether this option is the name
of some shape. If so, that shape is selected as if you had said
`shape=`⟨shape name⟩.

By default, the following shapes are available: `rectangle`, `circle`,
`coordinate`. Details of these shapes, like their anchors and size
options, are discussed in Section ??.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shape",
      meta = "⟨shape name⟩"
    },
    ["sharp corners"] = {
      details = [[
This options switches off any rounding on subsequent corners of the
path.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/sharp:corners"
    },
    ["sharp plot"] = {
      details = [[
This is the default and causes the points to be connected by straight
lines. This option is included only so that you can "switch back" if you
"globally" install, say, `smooth`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/sharp:plot"
    },
    shift = {
      details = [[
Adds the ⟨coordinate⟩ to all coordinates.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                       (0,0) -- (1,1) -- (1,0);
      \draw[shift={(1,1)},blue]   (0,0) -- (1,1) -- (1,0);
      \draw[shift={(30:1cm)},red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shift",
      meta = "{⟨coordinate⟩}"
    },
    ["shift only"] = {
      details = [[
This option does not take any parameter. Its effect is to cancel all
current transformations except for the shifting. This means that the
origin will remain where it is, but any rotation around the origin or
scaling relative to the origin or skewing will no longer have an effect.

This option is useful in situations where a complicated transformation
is used to "get to a position", but you then wish to draw something
"normal" at this position.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                                      (0,0) -- (1,1) -- (1,0);
      \draw[rotate=30,xshift=2cm,blue]           (0,0) -- (1,1) -- (1,0);
      \draw[rotate=30,xshift=2cm,shift only,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shift:only"
    },
    ["shorten <"] = {
      details = [[
Shorten the path by ⟨length⟩ in the direction of the starting point.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shorten:<",
      meta = "⟨length⟩"
    },
    ["shorten >"] = {
      details = [[
Shorten the path by ⟨length⟩ in the direction of the end point.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/shorten:>",
      meta = "⟨length⟩"
    },
    ["show background bottom"] = {
      details = [[
Works like the style for the top line.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:bottom"
    },
    ["show background grid"] = {
      details = [[
This style behaves similarly to the `show background rectangle` style,
but it will not use a rectangle path, but a grid. The lower left and
upper right corner of the grid is computed in the same way as for the
background rectangle:

    \begin{tikzpicture}[show background grid]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}

You can influence the background grid by setting the following style:

This option can be combined with the `framed` option (use the `framed`
option first):

    \tikzset{background grid/.style={thick,draw=red,step=.5cm},
             background rectangle/.style={rounded corners,fill=yellow}}
    \begin{tikzpicture}[framed,gridded]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:grid"
    },
    ["show background left"] = {
      details = [[
Works similarly.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:left"
    },
    ["show background rectangle"] = {
      details = [[
This style causes a rectangle to be drawn behind your graphic. This
style option must be given to the `{tikzpicture}` environment or to the
`\tikz` command.

    \begin{tikzpicture}[show background rectangle]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}

The size of the background rectangle is determined as follows: We start
with the bounding box of the picture. Then, a certain separator distance
is added on the sides. This distance can be different for the $x$- and
$y$-directions and can be set using the following options:

The following two styles make setting the inner separator a bit easier
to remember:

You can influence how the background rectangle is rendered by setting
the following style:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:rectangle"
    },
    ["show background right"] = {
      details = [[
Works similarly.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:right"
    },
    ["show background top"] = {
      details = [[
This style causes a single line to be drawn at the top of the background
rectangle. Normally, the line coincides exactly with the top line of the
background rectangle:

    \begin{tikzpicture}[
        background rectangle/.style={fill=yellow},
        framed,show background top]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}

The following option allows you to lengthen (or shorten) the line:

    \begin{tikzpicture}
      [background rectangle={fill=blue!20},
       outer frame sep=1ex,%
       show background top,%
       show background bottom,%
       show background left,%
       show background right]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}

You can influence how the line is drawn grid by setting the following
style:
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:top"
    },
    ["sibling angle"] = {
      details = [[
Sets the angle between siblings in the `grow cyclic` style.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/sibling:angle",
      meta = "⟨angle⟩"
    },
    ["sibling distance"] = {
      details = [[
This key specifies the distance between the anchors of the children of a
parent node.

    \begin{tikzpicture}
      [level distance=4mm,
       level 1/.style={sibling distance=8mm},
       level 2/.style={sibling distance=4mm},
       level 3/.style={sibling distance=2mm}]
      \coordinate
         child {
           child {child child}
           child {child child}
         }
         child {
           child {child child}
           child {child child}
         };
    \end{tikzpicture}

    \begin{tikzpicture}
      [level distance=10mm,
       every node/.style={fill=red!60,circle,inner sep=1pt},
       level 1/.style={sibling distance=20mm,nodes={fill=red!45}},
       level 2/.style={sibling distance=10mm,nodes={fill=red!30}},
       level 3/.style={sibling distance=5mm,nodes={fill=red!25}}]
      \node {31}
         child {node {30}
           child {node {20}
             child {node {5}}
             child {node {4}}
           }
           child {node {10}
             child {node {9}}
             child {node {1}}
           }
         }
         child {node {20}
           child {node {19}
             child {node {1}}
             child[missing]
           }
           child {node {18}}
         };
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/sibling:distance",
      meta = "⟨distance⟩"
    },
    size = {
      details = [[
Inside a `spy scope`, this is a shortcut for `minimum size`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/size",
      meta = "⟨dimension⟩"
    },
    slice = {
      details = [[
This key works exactly like `meet`, only the second rule is changed:

1.  the to-be-viewed rectangle has minimal size that it encompasses all
    of the window rectangle.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/slice",
      meta = "⟨to-be-viewed corner⟩ rectangle ⟨to-be-viewed corner⟩ at ⟨window corner⟩ rectangle ⟨window corner⟩"
    },
    sloped = {
      details = [[
This option causes the node to be rotated such that a horizontal line
becomes a tangent to the curve. The rotation is normally done in such a
way that text is never "upside down". To get upside-down text, use can
use `[rotate=180]` or `[allow upside down]`, see below.

    \tikz \draw (0,0) .. controls +(up:2cm) and +(left:2cm) .. (1,3)
        node foreach \p in {0,0.25,...,1} [sloped,above,pos=\p]{\p};

    \begin{tikzpicture}[->]
      \draw (0,0)   -- (2,0.5) node[midway,sloped,above] {$x$};
      \draw (2,-.5) -- (0,0)   node[midway,sloped,below] {$y$};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/sloped"
    },
    ["small circuit symbols"] = {
      details = [[
This style sets the default circuit symbol unit to `6pt`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/small:circuit:symbols"
    },
    ["small mindmap"] = {
      details = [[
This style includes the `mindmap` style, but additionally changes the
default size of concepts, fonts and distances so that a medium-sized
mindmap will fit on an A5 page (A5 pages are half as large as A4 pages).
Mindmaps with `small mindmap` will also fit onto a standard frame of the
`beamer` package.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/small:mindmap"
    },
    smooth = {
      details = [[
This option causes the points on the path to be connected using a smooth
curve:

    \tikz\draw plot[smooth] file{plots/pgfmanual-sine.table};

Note that the smoothing algorithm is not very intelligent. You will get
the best results if the bending angles are small, that is, less than
about $30^\circ$ and, even more importantly, if the distances between
points are about the same all over the plotting path.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/smooth"
    },
    ["smooth cycle"] = {
      details = [[
This option causes the points on the path to be connected using a closed
smooth curve.

    \tikz[scale=0.5]
      \draw plot[smooth cycle] coordinates{(0,0) (1,0) (2,1) (1,2)}
            plot               coordinates{(0,0) (1,0) (2,1) (1,2)} -- cycle;
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/smooth:cycle"
    },
    solid = {
      details = [[
Shorthand for setting a solid line as "dash pattern". This is the
default.

    \tikz \draw[solid] (0pt,0pt) -- (50pt,0pt);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/solid"
    },
    ["spy connection path"] = {
      details = [[
The ⟨code⟩ is executed after the spy-on and spy-in nodes have just been
created. Inside this ⟨code⟩, the two nodes can be accessed as
`tikzspyinnode` and `tikzspyonnode`. For example, the key
`connect spies` sets this command to

    \draw[thin] (tikzspyonnode) -- (tikzspyinnode);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/spy:connection:path",
      meta = "⟨code⟩"
    },
    ["spy scope"] = {
      details = [[
This option may be used with a `{scope}` or any environment that creates
such a scope internally (like `{tikzpicture}`). It has the following
effects:

-   It resets a number of graphic state parameters, including the color,
    line style, and others. This is necessary for technical reasons.

-   It tells TikZ that the content of the scope should be saved
    internally in a special box.

-   It defines the command `\spy` so that it can be used inside the
    scope.

-   At the end of the scope, the nodes belonging to the `\spy` commands
    used inside the scope are created.

-   The ⟨options⟩ are saved in an internal style. Each time `\spy` is
    used, these ⟨options⟩ will be used.

-   Three keys are defined that provide useful shortcuts:

It is permissible to nest `spy scopes`. In this case, all `\spy`
commands inside the inner `spy scope` only have an effect on material
inside the scope, whereas `\spy` commands outside the inner `spy scope`
but inside the outer `spy scope` allow you to "spy on the spy".

    \begin{tikzpicture}
      [spy using outlines={rectangle, red, magnification=5,
                           size=1.5cm, connect spies}]

      \begin{scope}
        [spy using outlines={circle, blue,
                             magnification=3, size=1.5cm, connect spies}]
        \draw [help lines] (0,0) grid (3,2);

        \draw [decoration=Koch curve type 1]
          decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

        \spy on (1.6,0.3) in node (zoom) [left] at (3.5,-1.25);
      \end{scope}

      \spy on (zoom.north west) in node [right] at (0,-1.25);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/spy:scope",
      meta = "⟨options⟩"
    },
    ["spy using outlines"] = {
      details = [[
This key creates a `spy scope` in which the spy-in node is drawn, but
not filled, using a thick line; and the spy-on node is drawn, but not
filled, using a very thin line.

    \begin{tikzpicture}
      [spy using outlines={circle, magnification=3, size=1cm, connect spies}]

      \draw [decoration=Koch curve type 1]
        decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

      \spy [red] on (1.6,0.3) in node at (3,1);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/spy:using:outlines",
      meta = "⟨options⟩"
    },
    ["spy using overlays"] = {
      details = [[
This key creates a `spy scope` in which both the spy-in and spy-on nodes
are filled, but with the fill opacity set to 20%.

    \begin{tikzpicture}
      [spy using overlays={circle, magnification=3, size=1cm, connect spies}]

      \draw [decoration=Koch curve type 1]
        decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

      \spy [green] on (1.6,0.3) in node at (3,1);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/spy:using:overlays",
      meta = "⟨options⟩"
    },
    ["start angle"] = {
      details = [[
Sets the start angle.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/start:angle",
      meta = "⟨degrees⟩"
    },
    ["start branch"] = {
      details = [[
This key is used in the same manner as the `start chain` command,
however, the effect is slightly different:

-   This option may only be used if some chain is already active and
    there is a (last) node on this chain. Let us call this node the
    ⟨fork node⟩.

-   The chain is not just called ⟨branch name⟩, but ⟨current
    chain⟩`/`⟨branch name⟩. For instance, if the ⟨fork node⟩ is part of
    the chain called `trunk` and the ⟨branch name⟩ is set to `left`, the
    complete chain name of the branch is `trunk/left`. The ⟨branch name⟩
    must be given, there is no default value.

-   The ⟨fork node⟩ is automatically "chained into" the branch chain as
    its first node. Thus, for the first node on the branch that you
    provide, the `join` option will cause it to be connected to the fork
    node.

&nbsp;

    \begin{tikzpicture}[every on chain/.style=join,every join/.style=->,
                        node distance=2mm and 1cm]
      { [start chain=trunk]
        \node [on chain] {A};
        \node [on chain] {B};

        { [start branch=numbers going below]
          \node [on chain] {1};
          \node [on chain] {2};
          \node [on chain] {3};
        }
        { [start branch=greek going above]
          \node [on chain] {$\alpha$};
          \node [on chain] {$\beta$};
          \node [on chain] {$\gamma$};
        }

        \node [on chain,join=with trunk/numbers-end,join=with trunk/greek-end] {C};
        { [start branch=symbols going below]
          \node [on chain] {$\star$};
          \node [on chain] {$\circ$};
          \node [on chain] {$\int$};
        }
      }
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/start:branch",
      meta = "⟨branch name⟩⟨direction⟩"
    },
    ["start chain"] = {
      details = [[
This key should, but need not, be given as an option to a scope
enclosing all nodes of the chain. Typically, this will be a `scope` or
the whole `tikzpicture`, but it might just be a path on which all nodes
of the chain are found. If no ⟨chain name⟩ is given, the default value
`chain` will be used instead.

The key starts a chain named ⟨chain name⟩ and makes it *active*, which
means that it is currently being constructed. The `start chain` can be
issued only once to activate a chain, inside a scope in which a chain is
active you cannot use this option once more (for the same chain name).
The chain stops being active at the end of the scope in which the
`start chain` command was given.

Although chains are only locally active (that is, active inside the
scope the `start chain` command was issued), the information concerning
the chains is stored globally and it is possible to *continue* a chain
after a scope has ended. For this, the `continue chain` option can be
used, which allows you to reactivate an existing chain in another scope.

The ⟨direction⟩ is used to determine the placement rule for nodes on the
chain. If it is omitted, the current value of the following key is used:

The ⟨direction⟩ can have two different forms: `going `⟨options⟩ or
`placed `⟨options⟩. The effect of these rules will be explained in the
description of the `on chain` option. Right now, just remember that the
⟨direction⟩ you provide with the `chain` option applies to the whole
chain.

Other than this, this key has no further effect. In particular, to place
nodes on the chain, you must use the `on chain` option, described next.

    \begin{tikzpicture}[start chain]
      % The chain is called just "chain"
      \node [on chain] {A};
      \node [on chain] {B};
      \node [on chain] {C};
    \end{tikzpicture}

    \begin{tikzpicture}
      % Same as above, using the scope shorthand
      { [start chain]
        \node [on chain] {A};
        \node [on chain] {B};
        \node [on chain] {C};
      }
    \end{tikzpicture}

    \begin{tikzpicture}[start chain=1 going right,
                        start chain=2 going below,
                        node distance=5mm,
                        every node/.style=draw]
      \node [on chain=1] {A};
      \node [on chain=1] {B};
      \node [on chain=1] {C};

      \node [on chain=2] at (0.5,-.5) {0};
      \node [on chain=2] {1};
      \node [on chain=2] {2};

      \node [on chain=1] {D};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/start:chain",
      meta = "⟨chain name⟩⟨direction⟩"
    },
    state = {
      details = [[
You should redefine it to something else, if you wish to use states of a
different nature.

    \begin{tikzpicture}[state/.style=state with output]
      \node[state]          {$q_0$ \nodepart{lower} $11$};
      \node[state] at (2,0) {$q_1$ \nodepart{lower} $00$};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/state"
    },
    ["state with output"] = {
      details = [[
This node style causes nodes to be drawn as split circles, that is,
using the `circle split` shape. In the upper part of the shape you have
the name of the style, in the lower part the output is placed. To
specify the output, use the command `\nodepart{lower}` inside the node.
This style also calls `every state`.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);

      \node[state without output] {$q_0$};

      \node[state with output] at (2,0) {$q_1$ \nodepart{lower} $00$};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/state:with:output"
    },
    ["state without output"] = {
      details = [[
This node style causes nodes to be drawn as circles. Also, this style
calls `every state`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/state:without:output"
    },
    step = {
      details = [[
Sets the stepping in both the $x$ and $y$-direction. If a dimension is
provided, this is used directly. If a number is provided, this number is
interpreted in the $xy$-coordinate system. For example, if you provide
the number `2`, then the $x$-step is twice the $x$-vector and the
$y$-step is twice the $y$-vector set by the `x=` and `y=` options.
Finally, if you provide a coordinate, then the $x$-part of this
coordinate will be used as the $x$-step and the $y$-part will be used as
the $y$-coordinate.

    \begin{tikzpicture}[x=.5cm]
      \draw[thick] (0,0) grid [step=1]     (3,2);
      \draw[red]   (0,0) grid [step=.75cm] (3,2);
    \end{tikzpicture}
    \begin{tikzpicture}
      \draw        (0,0) circle [radius=1];
      \draw[blue]  (0,0) grid [step=(45:1)] (3,2);
    \end{tikzpicture}

A complication arises when the $x$- and/or $y$-vector do not point along
the axes. Because of this, the actual rule for computing the $x$-step
and the $y$-step is the following: As the $x$- and $y$-steps we use the
$x$- and $y$-components or the following two vectors: The first vector
is either $(⟨x-grid-step-number⟩,0)$ or
$(⟨x-grid-step-dimension⟩,0\mathrm{pt})$, the second vector is
$(0,⟨y-grid-step-number⟩)$ or $(0\mathrm{pt},⟨y-grid-step-dimension⟩)$.

If the $x$-step or $y$-step is $0$ or negative the corresponding lines
are not drawn.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/step",
      meta = "⟨number or dimension or coordinate⟩"
    },
    ["structured tokens"] = {
      details = [[
This option, which must again be passed to a place, gets a list of texts
for tokens. For each text, a new token will be added to the place.

    \tikz  \node[place,structured tokens={$x$,$y$,$z$}] {};

    \begin{tikzpicture}[every place/.style={minimum size=9mm}]

      \foreach \x/\y/\tokennumber in {0/2/1,1/2/2,2/2/3,
                                      0/1/4,1/1/5,2/1/6,
                                      0/0/7,1/0/8,2/0/9}
        \node [place,structured tokens={1,...,\tokennumber}] at (\x,\y) {};
    \end{tikzpicture}

If you use lots of structured tokens, consider redefining the
`every token` style so that the tokens are larger.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/structured:tokens",
      meta = "⟨token texts⟩"
    },
    ["subgraph nodes"] = {
      details = [[
Sets the `every subgraph node` style to ⟨style⟩.

    \tikz [subgraph text bottom=text centered,
           subgraph nodes=red]
      \graph [tree layout] {
        a -> { b -> {c, d}, e -> {f, g -> h} };

        left [draw]  // { b, c, d };
        right [draw] // { e, f, g, h};

        left <-> right;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/subgraph:nodes",
      meta = "⟨style⟩"
    },
    ["subgraph text bottom"] = {
      details = [[
Works like `subgraph text top`, only the text placed at the bottom.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/subgraph:text:bottom",
      meta = "⟨text alignment options⟩"
    },
    ["subgraph text none"] = {
      details = [[
When this option is used, the text of a subgraph node is not shown.
Adding a slash after the node name achieves roughly the same effect, but
this option is useful in situations when subgraph nodes generally should
not have any text inside them.

    \tikz [subgraph text none]
      \graph [tree layout] {
        a -> { b -> {c, d}, e -> {f, g -> h} };

        left [draw]  // { b, c, d };
        right [draw] // { e, f, g, h};

        left <-> right;
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/subgraph:text:none"
    },
    ["subgraph text sep"] = {
      details = [[
Some space added between the inner nodes of a subgraph node and the text
labels.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/subgraph:text:sep",
      meta = "⟨dimension⟩"
    },
    ["subgraph text top"] = {
      details = [[
Specifies that the text of a subgraph node should be placed at the top
of the subgraph node: Still inside the node, but above all nodes inside
the subgraph node.

    \tikz [subgraph text top=text ragged left]
      \graph [tree layout] {
        a -> { b -> {c, d}, e -> {f, g -> h} };

        left [draw]  // { b, c, d };
        right [draw] // { e, f, g, h};

        left <-> right;
      };

You can pass any of the ⟨text alignment options⟩ understood by TikZ,
such as `text centered`:

    \tikz [subgraph text top=text centered]
      \graph [tree layout] {
        a -> { b -> {c, d}, e -> {f, g -> h} };

        left [draw, circle] // { b, c, d };
      };

To place a label *outside* the subgraph node, use a label, typically
defined using the `quotes` library:

    \tikz \graph [tree layout] {
        a -> { b -> {c, d}, e -> {f, g -> h} };

        / ["left", draw]  // { b, c, d } <->
        / ["right", draw] // { e, f, g, h};
      };
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/subgraph:text:top",
      meta = "⟨text alignment options⟩"
    },
    swap = {
      details = [[
This option exchanges the roles of `left` and `right` in automatic
placement. That is, if `left` is the current `auto` placement, `right`
is set instead and the other way round.

    \begin{tikzpicture}[auto]
      \draw[help lines,use as bounding box] (0,-.5) grid (4,5);

      \draw (0.5,0) .. controls (9,6) and (-5,6) .. (3.5,0)
        node foreach \pos in {0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1}
             [pos=\pos,swap,fill=red!20] {\pos}
        node foreach \pos in {0.025,0.2,0.4,0.6,0.8,0.975}
             [pos=\pos,fill=blue!20] {\pos};
    \end{tikzpicture}

    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto]
      \draw[help lines] (0,0) grid (3,2);

      \node[state] (q_0)                      {$q_0$};
      \node[state] (q_1) [above right of=q_0] {$q_1$};
      \node[state] (q_2) [below right of=q_0] {$q_2$};
      \node[state] (q_3) [below right of=q_1] {$q_3$};

      \path[->] (q_0) edge              node        {0} (q_1)
                      edge              node [swap] {1} (q_2)
                (q_1) edge              node        {1} (q_3)
                      edge [loop above] node        {0} ()
                (q_2) edge              node [swap] {0} (q_3)
                      edge [loop below] node        {1} ();
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/swap"
    },
    tension = {
      details = [[
This option influences how "tight" the smoothing is. A lower value will
result in sharper corners, a higher value in more "round" curves. A
value of $1$ results in a circle if four points at quarter-positions on
a circle are given. The default is $0.55$. The "correct" value depends
on the details of plot.

    \begin{tikzpicture}[smooth cycle]
      \draw                 plot[tension=0.2]
        coordinates{(0,0) (1,1) (2,0) (1,-1)};
      \draw[yshift=-2.25cm] plot[tension=0.5]
        coordinates{(0,0) (1,1) (2,0) (1,-1)};
      \draw[yshift=-4.5cm]  plot[tension=1]
        coordinates{(0,0) (1,1) (2,0) (1,-1)};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/tension",
      meta = "⟨value⟩"
    },
    text = {
      details = [[
Sets the color to be used for text labels. A `color=` option will
immediately override this option.

    \begin{tikzpicture}
      \draw[red]       (0,0) -- +(1,1) node[above]     {red};
      \draw[text=red]  (1,0) -- +(1,1) node[above]     {red};
      \draw            (2,0) -- +(1,1) node[above,red] {red};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/text",
      meta = "⟨color⟩"
    },
    ["text depth"] = {
      details = [[
This option works like `text height`, only for the depth of the text
box. This option is mostly useful when you need to ensure a uniform
depth of text boxes that need to be aligned.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/text:depth",
      meta = "⟨dimension⟩"
    },
    ["text effects"] = {
      details = [[
Execute every option in `{options}` with the key path for each option
temporarily set to `/pgf/decoration/text effects/`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/text:effects",
      meta = "{options}"
    },
    ["text height"] = {
      details = [[
Sets the height of the text boxes in shapes. Thus, when you write
something like `node {text}`, the `text` is first typeset, resulting in
some box of a certain height. This height is then replaced by the height
`text height`. The resulting box is then used to determine the size of
the shape, which will typically be larger. When you write `text height=`
without specifying anything, the "natural" size of the text box remains
unchanged.

    \tikz \node[draw]                  {y};
    \tikz \node[draw,text height=10pt] {y};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/text:height",
      meta = "⟨dimension⟩"
    },
    ["text opacity"] = {
      details = [[
Sets the opacity of text labels, overriding the `fill opacity` setting.

    \begin{tikzpicture}[every node/.style={fill,draw}]
      \draw[line width=2mm,blue!50,line cap=round] (0,0) grid (3,2);

      \node[opacity=0.5] at (1.5,2) {Upper node};
      \node[draw opacity=0.8,fill opacity=0.2,text opacity=1]
        at (1.5,0) {Lower node};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/text:opacity",
      meta = "⟨value⟩"
    },
    ["text width"] = {
      details = [[
This option will put the text of a node in a box of the given width
(something akin to a `{minipage}` of this width, only portable across
formats). If the node text is not as wide as ⟨dimension⟩, it will
nevertheless be put in a box of this width. If it is larger, line
breaking will be done.

By default, when this option is given, a ragged right border will be
used (`align=left`). This is sensible since, typically, these boxes are
narrow and justifying the text looks ugly. You can, however, change the
alignment using `align` or directly using commands line `\centering`.

    \tikz \draw (0,0) node[fill=yellow!80!black,text width=3cm]
      {This is a demonstration text for showing how line breaking works.};

Setting ⟨dimension⟩ to an empty string causes the automatic line
breaking to be disabled.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/text:width",
      meta = "⟨dimension⟩"
    },
    thick = {
      details = [[
Sets the line width to 0.8pt.

      \tikz \draw[thick] (0,0) -- (1cm,1.5ex);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/thick"
    },
    thin = {
      details = [[
Sets the line width to 0.4pt.

      \tikz \draw[thin] (0,0) -- (1cm,1.5ex);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/thin"
    },
    ["tight background"] = {
      details = [[
Sets the inner frame separator to 0pt. The background rectangle will
have the size of the bounding box.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/tight:background"
    },
    ["tiny circuit symbols"] = {
      details = [[
This style sets the default circuit symbol unit to `5pt`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/tiny:circuit:symbols"
    },
    ["to path"] = {
      details = [[
Whenever a `to` operation is used, the ⟨path⟩ is inserted. More
precisely, the following path is added:

> `{[every to,`⟨options⟩`] `⟨path⟩ `}`

The ⟨options⟩ are the options given to the `to` operation, the ⟨path⟩ is
the path set by this option `to path`.

Inside the ⟨path⟩, different macros are used to reference the from- and
to-coordinates. In detail, these are:

-   `\tikztostart` will expand to the from-coordinate (without the
    parentheses).

-   `\tikztotarget` will expand to the to-coordinate.

-   `\tikztonodes` will expand to the nodes between the `to` operation
    and the coordinate. Furthermore, these nodes will have the `pos`
    option set implicitly.

Let us have a look at a simple example. The standard straight line for a
`to` is achieved by the following ⟨path⟩:

> `– (\tikztotarget) \tikztonodes`

Indeed, this is the default setting for the path. When we write
`(a) to (b)`, the ⟨path⟩ will expand to `(a) – (b)`, when we write

> `(a) to[red] node {x} (b)`

the ⟨path⟩ will expand to

> `(a) – (b) node[red] {x}`

It is not possible to specify the path

> `– \tikztonodes (\tikztotarget)`

since TikZ does not allow one to have a macro after `–` that expands to
a node.

Now let us have a look at how we can modify the ⟨path⟩ sensibly. The
simplest way is to use a curve.

    \begin{tikzpicture}[to path={
        .. controls +(1,0) and +(1,0) .. (\tikztotarget) \tikztonodes}]

      \node (a) at (0,0) {a};
      \node (b) at (2,1) {b};
      \node (c) at (1,2) {c};

      \draw (a) to node {x} (b)
            (a) to          (c);
    \end{tikzpicture}

Here is another example:

    \tikzset{
      my loop/.style={to path={
        .. controls +(80:1) and +(100:1) .. (\tikztotarget) \tikztonodes}},
      my state/.style={circle,draw}}

    \begin{tikzpicture}[shorten >=2pt]
      \node [my state] (a) at (210:1) {$q_a$};
      \node [my state] (b) at (330:1) {$q_b$};

      \draw[->] (a) to           node[below]       {1} (b)
                    to [my loop] node[above right] {0} (b);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/to:path",
      meta = "⟨path⟩"
    },
    token = {
      details = [[
This style indicates that a node is a token. By default, this causes the
node to be a small black circle. Unlike places and transitions, it
*does* make sense to provide text for the token node. Such text will be
typeset in a tiny font and in white on black (naturally, you can easily
change this by setting the style `every token`).

    \begin{tikzpicture}
      \node[place,label=above:$p_1$]             (p1) {};
      \node[token] at (p1) {};

      \node[place,label=above:$p_2$,right=of p1] (p2) {};
      \node[token] at (p2) {$y$};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/token"
    },
    ["token distance"] = {
      details = [[
This specifies the distance between the centers of the tokens in the
arrangements of the option `children are tokens`.

    \begin{tikzpicture}
      \node[place,label=above:$p_3$] {}
      [children are tokens,token distance=1.1ex]
      child {node [token] {}}
      child {node [token,red] {}}
      child {node [token,blue] {}}
      child {node [token] {}};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/token:distance",
      meta = "⟨distance⟩"
    },
    tokens = {
      details = [[
This option is given to a `place` node, not to a `token` node. The
effect of this option is to add ⟨number⟩ many child nodes to the place,
each having the style `token`. Thus, the following two pieces of codes
have the same effect:

    \tikz
      \node[place] {}
      [children are tokens]
      child {node [token] {}}
      child {node [token] {}}
      child {node [token] {}};
    \tikz
      \node[place,tokens=3] {};

It is legal to say `tokens=0`, no tokens are drawn in this case. This
option does not handle ten or more tokens correctly. If you need this
many tokens, you will have to program your own code.

    \begin{tikzpicture}[every place/.style={minimum size=9mm}]

      \foreach \x/\y/\tokennumber in {0/2/1,1/2/2,2/2/3,
                                      0/1/4,1/1/5,2/1/6,
                                      0/0/7,1/0/8,2/0/9}
        \node [place,tokens=\tokennumber] at (\x,\y) {};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/tokens",
      meta = "⟨number⟩"
    },
    ["top color"] = {
      details = [[
This option sets the color to be used at the top in an `axis` shading.
When this option is given, several things happen:

1.  The `shade` option is selected.

2.  The `shading=axis` option is selected.

3.  The middle color of the axis shading is set to the average of the
    given top color ⟨color⟩ and of whatever color is currently selected
    for the bottom.

4.  The rotation angle of the shading is set to 0.

&nbsp;

    \tikz \draw[top color=red] (0,0) rectangle (2,1);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/top:color",
      meta = "⟨color⟩"
    },
    ["transform canvas"] = {
      details = [[
The ⟨options⟩ should contain coordinate transformations options like
`scale` or `xshift`. Multiple options can be given, their effects
accumulate in the usual manner. The effect of these ⟨options⟩
(immediately) changes the current canvas transformation matrix. The
coordinate transformation matrix is not changed. Tracking of the picture
size is (locally) switched off and the node coordinate will no longer be
correct.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                                    (0,0) -- (1,1) -- (1,0);
      \draw[transform canvas={scale=2},blue]   (0,0) -- (1,1) -- (1,0);
      \draw[transform canvas={rotate=180},red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/transform:canvas",
      meta = "⟨options⟩"
    },
    ["transform shape"] = {
      details = [[
Causes the current "external" transformation matrix to be applied to the
shape. For example, if you said `\tikz[scale=3]` and then say
`node[transform shape] {X}`, you will get a "huge" X in your graphic.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/transform:shape"
    },
    ["transform shape nonlinear"] = {
      details = [[
When set to true, TikZ will try to apply any current nonlinear
transformation also to nodes. Typically, for the text in nodes this is
not possible in general, in such cases a linear approximation of the
nonlinear transformation is used. For more details, see Section ??.

    \begin{tikzpicture}
       % Install a nonlinear transformation:
       \pgfsetcurvilinearbeziercurve
          {\pgfpoint{0mm}{20mm}}
          {\pgfpoint{10mm}{20mm}}
          {\pgfpoint{10mm}{10mm}}
          {\pgfpoint{20mm}{10mm}}
       \pgftransformnonlinear{\pgfpointcurvilinearbezierorthogonal\pgf@x\pgf@y}%

       % Draw something:
       \draw [help lines] (0,-30pt) grid [step=10pt] (80pt,30pt);

       \foreach \x in {0,20,...,80}
         \node [fill=red!20]  at (\x pt, -20pt) {\x};

       \foreach \x in {0,20,...,80}
         \node [fill=blue!20, transform shape nonlinear] at (\x pt, 20pt) {\x};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/transform:shape:nonlinear",
      meta = "⟨true or false⟩"
    },
    transition = {
      details = [[
This style indicates that a node is a transition. As for places, the
text of a transition should be empty and the `label` option should be
used for adding labels.

To connect a transition to places, you can use the `edge` command as in
the following example:

    \begin{tikzpicture}
      \node[place,tokens=2,label=above:$p_1$]        (p1) {};
      \node[place,label=above:$p_2\ge1$,right=of p1] (p2) {};

      \node[transition,below right=of p1,label=below:$t_1$] {}
        edge[pre]                 (p1)
        edge[post] node[auto] {2} (p2);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/transition"
    },
    ["transparency group"] = {
      details = [[
This option can be given to a `scope`. It will have the following
effect: The scope's contents is stroked / filled "ignoring any outside
transparency". This means, all previous transparency settings are
ignored (you can still set transparency inside the group, but never
mind). For instance, in the forbidden sign example, the whole sign is
first painted (conceptually) like the image on the left hand side. Note
that some pixels of the sign are painted multiple times (up to three
times), but only the last color "wins".

Then, when the scope is finished, it is painted as a whole. The *fill*
transparency settings are now applied to the resulting picture. For
instance, the pixel that has been painted three times is just red at the
end, so this red color will be blended with whatever is "behind" the
group on the page.

    \begin{tikzpicture}
      \pattern[pattern=checkerboard,pattern color=black!15](-1,-1) rectangle (3,1);
      \node at (0,0) [forbidden sign,line width=2ex,draw=red,fill=white] {Smoking};

      \begin{scope}[transparency group,opacity=.5]
        \node at (2,0) [forbidden sign,line width=2ex,draw=red,fill=white]
          {Smoking};
      \end{scope}
    \end{tikzpicture}

Note that in the example, the `opacity=.5` is not active inside the
transparency group: The group is only established at beginning of the
scope and all options given to the `{scope}` environment are set before
the group is established. To change the opacity *inside* the group, you
need to open another scope inside it or use the `opacity` key with a
command inside the group:

    \begin{tikzpicture}
      \pattern[pattern=checkerboard,pattern color=black!15](-1,-1) rectangle (3,1);
      \node at (0,0) [forbidden sign,line width=2ex,draw=red,fill=white] {Smoking};

      \begin{scope}[transparency group,opacity=.5]
        \node (s) at (2,0) [forbidden sign,line width=2ex,draw=red,fill=white]
        {Smoking};

        \draw [opacity=.5, line width=2ex, blue] (1.2,0) -- (2.8,0);
      \end{scope}
    \end{tikzpicture}

The ⟨options⟩ are a list of comma-separated options:

-   `knockout` When this option is given inside the ⟨options⟩, the group
    becomes a so-called *knockout* group. This means, essentially, that
    inside the group everything is painted as if the "opacity" of a line
    or area were just another color channel. In particular, if you paint
    a pixel with opacity $0$ inside a knockout group, this pixel becomes
    perfectly transparent immediately. In contrast, painting a pixel
    with something of opacity $0$ normally has no effect.

    Not all renderers, let alone printers, will support this. At the
    time of writing, Apple's Preview will not show the following
    correctly (you should see the text TikZ in the middle):

        \begin{tikzpicture}
          \shade [left color=red,right color=blue] (-2,-1) rectangle (2,1);
          \begin{scope}[transparency group=knockout]
            \fill [white] (-1.9,-.9) rectangle (1.9,.9);
            \node [opacity=0,font=\fontencoding{T1}\fontfamily{ptm}\fontsize{45}{45}\bfseries]
                  {Ti\emph{k}Z};
          \end{scope}
        \end{tikzpicture}

    In the example, we first draw a large shading and then, inside the
    transparency group "overwrite" most of this shading by a big white
    rectangle. The interesting part is the text of the node, which has
    opacity `0`. Normally, this would mean that nothing is shown.
    However, in a knockout group, we "paint" the text with an "opacity
    zero" color. The effect is that part of the totally opaque white
    rectangle gets overwritten by a perfectly transparent area (namely
    exactly the area taken up by the pixels of the text). When this
    whole knockout group is then placed on top of the shading, the
    shading will "shine through" at the knocked-out pixels.

-   `isolated``=false` A group can be isolated or not. By default, they
    are isolated, since this is typically what you want. For details on
    what isolated groups are, exactly, see Section 7.3.4 of the PDF
    Specification, version 1.7.

Note that when a transparency group is created, TikZ must correctly
determine the size of the material inside the group. Usually, this is no
problem, but when you use things like `overlay` or `transform canvas`,
trouble may result. In this case, please consult Section ?? on how to
sidestep this problem in such cases.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/transparency:group",
      meta = "\\oarg{options}"
    },
    transparent = {
      details = [[
Makes everything totally transparent and, hence, invisible.

    \tikz{\fill[red]             (0,0)   rectangle (1,0.5);
          \fill[transparent,red] (0.5,0) rectangle (1.5,0.25); }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/transparent"
    },
    ["trim left"] = {
      details = [[
The `trim left` key tells PGFto discard everything which is left of the
provided ⟨dimension or coordinate⟩. Here, ⟨dimension⟩ is a single $x$
coordinate of the picture and ⟨coordinate⟩ is a point with $x$ and $y$
coordinates (but only its $x$ coordinate will be used). The effect is
the same as if you issue `\hspace{-s}` where `s` is the difference of
the picture's bounding box lower left $x$ coordinate and the $x$
coordinate specified as ⟨dimension or coordinate⟩:

    Text before image.%
        \begin{tikzpicture}[trim left]
            \draw (-1,-1) grid (3,2);
            \fill (0,0) circle (5pt);
        \end{tikzpicture}%
    Text after image.

Since `trim left` uses the default `trim left=0pt`, everything left of
$x=0$ is removed from the bounding box.

The following example has once the relative long label $-1$ and once the
shorter label $1$. Horizontal alignment is established with `trim left`:

    \begin{tikzpicture}
        \draw (0,1) -- (0,0) -- (1,1) -- cycle;
        \fill (0,0) circle (2pt);
        \node[left] at (0,0) {$-1$};
    \end{tikzpicture}
    \par
    \begin{tikzpicture}
        \draw (0,1) -- (0,0) -- (1,1) -- cycle;
        \fill (0,0) circle (2pt);
        \node[left] at (0,0) {$1$};
    \end{tikzpicture}
    \par
    \begin{tikzpicture}[trim left]
        \draw (0,1) -- (0,0) -- (1,1) -- cycle;
        \fill (0,0) circle (2pt);
        \node[left] at (0,0) {$-1$};
    \end{tikzpicture}
    \par
    \begin{tikzpicture}[trim left]
        \draw (0,1) -- (0,0) -- (1,1) -- cycle;
        \fill (0,0) circle (2pt);
        \node[left] at (0,0) {$1$};
    \end{tikzpicture}

Use `trim left=default` to reset the value.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/trim:left",
      meta = "⟨dimension or coordinate or default⟩"
    },
    ["trim right"] = {
      details = [[
This key is similar to `trim left`: it discards everything which is
right of the provided ⟨dimension or coordinate⟩. As for `trim left`,
⟨dimension⟩ denotes a single $x$ coordinate of the picture and
⟨coordinate⟩ a coordinate with $x$ and $y$ value (although only its $x$
component will be used).

We use the same example from above and add `trim right`:

    Text before image.%
        \begin{tikzpicture}[trim left, trim right=2cm, baseline]
            \draw (-1,-1) grid (3,2);
            \fill (0,0) circle (5pt);
        \end{tikzpicture}%
    Text after image.

In addition to `trim left=0pt`, we also discard everything which is
right of $x$`=2cm`. Furthermore, the `baseline` key supports vertical
alignment as well (using the $y$`=0cm` baseline).

Use `trim right=default` to reset the value.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/trim:right",
      meta = "⟨dimension or coordinate or default⟩"
    },
    turn = {
      details = [[
This key can be given as an option to a ⟨coordinate⟩ as in the following
example:

    \tikz \draw (0,0) -- (1,1) -- ([turn]-45:1cm) -- ([turn]-30:1cm);

The effect of this key is to locally shift the coordinate system so that
the last point reached is at the origin and the coordinate system is
"turned" so that the $x$-axis points in the direction of a tangent
entering the last point. This means, in effect, that when you use polar
coordinates of the form ⟨relative angle⟩`:`⟨distance⟩ together with the
`turn` option, you specify a point that lies at ⟨distance⟩ from the last
point in the direction of the last tangent entering the last point, but
with a rotation of ⟨relative angle⟩.

This key also works with curves ...

    \tikz [delta angle=30, radius=1cm]
      \draw (0,0) arc [start angle=0]  -- ([turn]0:1cm)
                  arc [start angle=30] -- ([turn]0:1cm)
                  arc [start angle=60] -- ([turn]30:1cm);

    \tikz \draw (0,0) to [bend left] (2,1) -- ([turn]0:1cm);

...and with plots ...

    \tikz \draw plot coordinates {(0,0) (1,1) (2,0) (3,0) } -- ([turn]30:1cm);

Although the above examples use polar coordinates with `turn`, you can
also use any normal coordinate. For instance, `([turn]1,1)` will append
a line of length $\sqrt 2$ that is turns by $45^\circ$ relative to the
tangent to the last point.

    \tikz \draw (0.5,0.5) -| (2,1) -- ([turn]1,1)
             .. controls ([turn]0:1cm) .. ([turn]-90:1cm);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turn"
    },
    turtle = {
      details = [[
This key executes the ⟨keys⟩ with the current key path set to
`/tikz/turtle`.

    \tikz[turtle/distance=2mm]
      \draw [turtle={home,fd,rt,fd,lt,fd,lt,fd}];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle",
      meta = "⟨keys⟩"
    },
    ["turtle/back"] = {
      details = [[
This has the same effect as a `turtle/forward` for the negated
⟨distance⟩ value.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/back",
      meta = "⟨distance⟩"
    },
    ["turtle/bk"] = {
      details = [[
An abbreviation for the `back` key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/bk"
    },
    ["turtle/distance"] = {
      details = [[
The default distance by which the turtle advances.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/distance",
      meta = "⟨distance⟩"
    },
    ["turtle/fd"] = {
      details = [[
An abbreviation for the `forward` key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/fd"
    },
    ["turtle/forward"] = {
      details = [[
Makes the turtle move forward by the given ⟨distance⟩. If no ⟨distance⟩
is specified, the current value of the following key is used:

"Moving forward the turtle" actually means that, relative to the current
last point on the path, a point at the given ⟨distance⟩ in the direction
the turtle is currently heading is computed. Then, the operation
`to[turtle/how]` is used to extend the path to this point.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/forward",
      meta = "⟨distance⟩"
    },
    ["turtle/home"] = {
      details = [[
Places the turtle at the origin and lets it head upward.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/home"
    },
    ["turtle/how"] = {
      details = [[
This style can set up the `to path` used by turtles. By setting this
style you can change the to-path:

    \tikz \draw [turtle={how/.style={bend left},home,forward,right,forward}];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/how"
    },
    ["turtle/left"] = {
      details = [[
Turns the turtle left by the given angle.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/left",
      meta = "⟨angle⟩"
    },
    ["turtle/lt"] = {
      details = [[
An abbreviation for the `left` key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/lt"
    },
    ["turtle/right"] = {
      details = [[
Turns the turtle right by the given angle.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/right",
      meta = "⟨angle⟩"
    },
    ["turtle/rt"] = {
      details = [[
An abbreviation for the `right` key.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/rt"
    },
    ["ultra nearly opaque"] = {
      details = [[
    \tikz{\fill[red]                 (0,0)   rectangle (1,0.5);
          \fill[ultra nearly opaque] (0.5,0) rectangle (1.5,0.25); }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ultra:nearly:opaque"
    },
    ["ultra nearly transparent"] = {
      details = [[
Makes everything, well, ultra nearly transparent.

    \tikz{\fill[red]                      (0,0)   rectangle (1,0.5);
          \fill[ultra nearly transparent] (0.5,0) rectangle (1.5,0.25); }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ultra:nearly:transparent"
    },
    ["ultra thick"] = {
      details = [[
Sets the line width to 1.6pt.

      \tikz \draw[ultra thick] (0,0) -- (1cm,1.5ex);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ultra:thick"
    },
    ["ultra thin"] = {
      details = [[
Sets the line width to 0.1pt.

      \tikz \draw[ultra thin] (0,0) -- (1cm,1.5ex);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ultra:thin"
    },
    ["upper left"] = {
      details = [[
Works like `lower left`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/upper:left",
      meta = "⟨color⟩"
    },
    ["upper right"] = {
      details = [[
Works like `lower left`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/upper:right",
      meta = "⟨color⟩"
    },
    ["use as bounding box"] = {
      details = [[
Normally, when this option is given on a path, the bounding box of the
present path is used to determine the size of the picture and the size
of all *subsequent* paths are ignored. However, if there were previous
path operations that have already established a larger bounding box, it
will not be made smaller by this operation (consider the
`\pgfresetboundingbox` command to reset the previous bounding box).

In a sense, `use as bounding box` has the same effect as clipping all
subsequent drawing against the current path -- without actually doing
the clipping, only making PGF treat everything as if it were clipped.

The first application of this option is to have a `{tikzpicture}`
overlap with the main text:

    Left of picture\begin{tikzpicture}
      \draw[use as bounding box] (2,0) rectangle (3,1);
      \draw (1,0) -- (4,.75);
    \end{tikzpicture}right of picture.

In a second application this option can be used to get better control
over the white space around the picture:

    Left of picture
    \begin{tikzpicture}
      \useasboundingbox (0,0) rectangle (3,1);
      \fill (.75,.25) circle (.5cm);
    \end{tikzpicture}
    right of picture.

Note: If this option is used on a path inside a TeX group (scope), the
effect "lasts" only until the end of the scope. Again, this behavior is
the same as for clipping.

Consider using `\useasboundingbox` together with `\pgfresetboundingbox`
in order to replace the bounding box with a new one.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/use:as:bounding:box"
    },
    ["use path"] = {
      details = [[
Set the current path to the soft path stored in ⟨macro⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/use:path",
      meta = "⟨macro⟩"
    },
    variable = {
      details = [[
Sets the macro whose value is set to the different values when
⟨coordinate expression⟩ is evaluated.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/variable",
      meta = "⟨macro⟩"
    },
    ["very near end"] = {
      details = [[
Set to `pos=0.875`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/very:near:end"
    },
    ["very near start"] = {
      details = [[
Set to `pos=0.125`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/very:near:start"
    },
    ["very nearly opaque"] = {
      details = [[
    \tikz{\fill[red]                (0,0)   rectangle (1,0.5);
          \fill[very nearly opaque] (0.5,0) rectangle (1.5,0.25); }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/very:nearly:opaque"
    },
    ["very nearly transparent"] = {
      details = [[
    \tikz{\fill[red]                     (0,0)   rectangle (1,0.5);
          \fill[very nearly transparent] (0.5,0) rectangle (1.5,0.25); }
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/very:nearly:transparent"
    },
    ["very thick"] = {
      details = [[
Sets the line width to 1.2pt.

      \tikz \draw[very thick] (0,0) -- (1cm,1.5ex);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/very:thick"
    },
    ["very thin"] = {
      details = [[
Sets the line width to 0.2pt.

      \tikz \draw[very thin] (0,0) -- (1cm,1.5ex);
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/very:thin"
    },
    view = {
      details = [[
This is an alias for `/tikz/meet`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/view"
    },
    ["visualizer color"] = {
      details = [[
This key is used to set the color `visualizer color` to ⟨color⟩. This
color is used by visualizers to color the data they visualize, rather
than the current "standard color". The reason for not using the normal
current color is simply that it makes many internals of the data
visualization engine a bit simpler.

        data point [x=2, y=2,       set=normal]
        data point [x=0, y=1,       set=heated]
        data point [x=2, y=1,       set=heated]
        data point [x=0.5, y=1.5,   set=critical]
        data point [x=2.25, y=1.75, set=critical]
    };},
    ]
    \pgfdvdeclarestylesheet{my colors}
    {
      default style/.style={visualizer color=black},
      1/.style={visualizer color=black},
      2/.style={visualizer color=red!80!black},
      3/.style={visualizer color=blue!80!black},
    }
    \tikz \datavisualization [
      school book axes,
      visualize as line=normal,
      visualize as line=heated,
      visualize as line=critical,
      style sheet=my colors]
    data group {lines};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/visualizer:color",
      meta = "⟨color⟩"
    },
    ["week list"] = {
      details = [[
This style creates one row for each week in the range. The value of
`day xshift` is used for the distance between days in each week row, the
value of `day yshift` is used for the distance between rows. In both
cases, "distance" refers to the distance between the anchors of the
nodes of the days (or, more generally, the distance between the origins
of the little pictures created for each day).

The days inside each week are shifted such that Monday is always at the
first position (to change this, you need to copy and then modify the
code appropriately). If the date range does not start on a Monday, the
first line will not start in the first column, but rather in the column
appropriate for the first date in the range.

At the beginning of each month (except for the first month in the range)
an additional vertical space of `month yshift` is added. If this is set
to `0pt` you get a continuous list of days.

    \tikz
      \calendar [dates=2000-01-01 to 2000-02-last,week list];

    \tikz
      \calendar [dates=2000-01-01 to 2000-02-last,week list,
                 month yshift=0pt];
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/week:list"
    },
    width = {
      details = [[
Inside a `spy scope`, this is a shortcut for `minimum width`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/width",
      meta = "⟨dimension⟩"
    },
    x = {
      details = [[
If ⟨value⟩ is a dimension, the $x$-vector of PGF's $xyz$-coordinate
system is set up to point ⟨value⟩ to the right, that is, to
$(⟨value⟩,0pt)$.

    \begin{tikzpicture}
      \draw                  (0,0)   -- +(1,0);
      \draw[x=2cm,color=red] (0,0.1) -- +(1,0);
    \end{tikzpicture}

    \tikz \draw[x=1.5cm] (0,0) grid (2,2);

The last example shows that the size of steppings in grids, just like
all other dimensions, are not affected by the $x$-vector. After all, the
$x$-vector is only used to determine the coordinate of the upper right
corner of the grid.

If ⟨value⟩ is a coordinate, the $x$-vector of PGF's $xyz$-coordinate
system is set to the specified coordinate. If ⟨value⟩ contains a comma,
it must be put in braces.

    \begin{tikzpicture}
      \draw                            (0,0) -- (1,0);
      \draw[x={(2cm,0.5cm)},color=red] (0,0) -- (1,0);
    \end{tikzpicture}

You can use this, for example, to exchange the meaning of the $x$- and
$y$-coordinate.

    \begin{tikzpicture}[smooth]
      \draw plot coordinates{(1,0) (2,0.5) (3,0) (3,1)};
      \draw[x={(0cm,1cm)},y={(1cm,0cm)},color=red]
            plot coordinates{(1,0) (2,0.5) (3,0) (3,1)};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/x",
      meta = "⟨value⟩"
    },
    ["x radius"] = {
      details = [[
Sets the horizontal radius of the circle (which, when this value is
different form the vertical radius, is actually an ellipse). The ⟨value⟩
may either be a dimension or a dimensionless number. In the latter case,
the number is interpreted in the $xy$-coordinate system (if the $x$-unit
is set to, say, `2cm`, then `x radius=3` will have the same effect as
`x radius=6cm`).
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/x:radius",
      meta = "⟨value⟩"
    },
    xbar = {
      details = [[
This option works like `ybar` except that the bars are horizontal.

    \tikz \draw[pattern=north west lines] plot[xbar]
       coordinates{(1,0) (0.4,1) (1.7,2) (1.6,3)};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/xbar"
    },
    ["xbar interval"] = {
      details = [[
Works like `ybar interval`, but for horizontal bar plots.

    \begin{tikzpicture}[xbar interval,x=0.5cm,y=0.5cm]
      \draw[color=red,fill=red!80]
        plot coordinates {(3,0) (2,1) (4,1.5) (1,4) (2,6) (2,7)};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/xbar:interval"
    },
    xcomb = {
      details = [[
This option works like `ycomb` except that the bars are horizontal.

    \tikz \draw plot[xcomb,mark=x] coordinates{(1,0) (0.8,0.2) (0.6,0.4) (0.2,1)};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/xcomb"
    },
    xrange = {
      details = [[
Set the $x$-range. This makes sense only for parametric plots.

    \tikz \draw[scale=0.5,domain=-3.141:3.141,smooth,xrange=0:1]
      plot[parametric,id=parametric-example-cut] function{t*sin(t),t*cos(t)};
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/xrange",
      meta = "⟨start⟩:⟨end⟩"
    },
    xscale = {
      details = [[
Multiplies only the $x$-value of all coordinates by the given ⟨factor⟩.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                (0,0) -- (1,1) -- (1,0);
      \draw[xscale=2,blue] (0,0) -- (1,1) -- (1,0);
      \draw[xscale=-1,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/xscale",
      meta = "⟨factor⟩"
    },
    xshift = {
      details = [[
Adds ⟨dimension⟩ to the $x$ value of all coordinates.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                   (0,0) -- (1,1) -- (1,0);
      \draw[xshift=2cm,blue]  (0,0) -- (1,1) -- (1,0);
      \draw[xshift=-10pt,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/xshift",
      meta = "⟨dimension⟩"
    },
    xslant = {
      details = [[
Slants the coordinate horizontally by the given ⟨factor⟩:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                (0,0) -- (1,1) -- (1,0);
      \draw[xslant=2,blue] (0,0) -- (1,1) -- (1,0);
      \draw[xslant=-1,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/xslant",
      meta = "⟨factor⟩"
    },
    xstep = {
      details = [[
Sets the stepping in the $x$-direction.

    \begin{tikzpicture}
      \draw (0,0) grid [xstep=.5,ystep=.75] (3,2);
      \draw[ultra thick] (0,0) grid [ystep=0] (3,2);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/xstep",
      meta = "⟨dimension or number⟩"
    },
    y = {
      details = [[
Works like the `x=` option, only if ⟨value⟩ is a dimension, the
resulting vector points to $(0,⟨value⟩)$.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/y",
      meta = "⟨value⟩"
    },
    ["y radius"] = {
      details = [[
Works like the `x radius`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/y:radius",
      meta = "⟨value⟩"
    },
    ybar = {
      details = [[
This option produces fillable bar plots. It is thus very similar to
`ycomb`, but it employs rectangular shapes instead of line-to
operations. It thus allows to use any fill or pattern style.

    \tikz\draw[draw=blue,fill=blue!60!black] plot[ybar] file{plots/pgfmanual-sine.table};

    \begin{tikzpicture}[ybar]
      \draw[color=red,fill=red!80,bar width=6pt]
        plot coordinates{(0,1) (.5,1.2) (1,.6) (1.5,.7) (2,.9)};
      \draw[color=red!50,fill=red!20,bar width=4pt,bar shift=3pt]
        plot coordinates{(0,1.2) (.5,1.3) (1,.5) (1.5,.2) (2,.5)};
    \end{tikzpicture}

The use of `bar width` and `bar shift` is explained in the
`plothandlers` library documentation, section ??. Please refer to
page ??.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ybar"
    },
    ["ybar interval"] = {
      details = [[
As `/tikz/ybar`, this options produces vertical bars. However, bars are
centered at coordinate *intervals* instead of interval edges, and the
bar's width is also determined relatively to the interval's length:

    \begin{tikzpicture}[ybar interval,x=10pt]
      \draw[color=red,fill=red!80]
        plot coordinates{(0,2) (2,1.2) (3,.3) (5,1.7) (8,.9) (9,.9)};
    \end{tikzpicture}

Since there are $N$ intervals $[x_i,x_{i+1}]$ for given $N+1$
coordinates, you will always have one coordinate more than bars. The
last $y$ value will be ignored.

You can configure relative shifts and relative bar widths, which is
explained in the `plothandlers` library documentation, section ??.
Please refer to page ??.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ybar:interval"
    },
    ycomb = {
      details = [[
This option causes the `plot` operation to interpret the plotting points
differently. Instead of connecting them, for each point of the plot a
straight line is added to the path from the $x$-axis to the point,
resulting in a sort of "comb" or "bar diagram".

    \tikz\draw[ultra thick] plot[ycomb,thin,mark=*] file{plots/pgfmanual-sine.table};

    \begin{tikzpicture}[ycomb]
      \draw[color=red,line width=6pt]
        plot coordinates{(0,1) (.5,1.2) (1,.6) (1.5,.7) (2,.9)};
      \draw[color=red!50,line width=4pt,xshift=3pt]
        plot coordinates{(0,1.2) (.5,1.3) (1,.5) (1.5,.2) (2,.5)};
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ycomb"
    },
    ["year code"] = {
      details = [[
Works like `month code`, only for years.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/year:code",
      meta = "⟨code⟩"
    },
    ["year text"] = {
      details = [[
Works like `month text`, only for years.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/year:text",
      meta = "⟨text⟩"
    },
    yrange = {
      details = [[
Same as `range`.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/yrange",
      meta = "⟨start⟩:⟨end⟩"
    },
    yscale = {
      details = [[
Multiplies only the $y$-value of all coordinates by ⟨factor⟩.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/yscale",
      meta = "⟨factor⟩"
    },
    yshift = {
      details = [[
Adds ⟨dimension⟩ to the $y$ value of all coordinates.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/yshift",
      meta = "⟨dimension⟩"
    },
    yslant = {
      details = [[
Slants the coordinate vertically by the given ⟨factor⟩:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                (0,0) -- (1,1) -- (1,0);
      \draw[yslant=2,blue] (0,0) -- (1,1) -- (1,0);
      \draw[yslant=-1,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/yslant",
      meta = "⟨factor⟩"
    },
    ystep = {
      details = [[
Sets the stepping in the $y$-direction.
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/ystep",
      meta = "⟨dimension or number⟩"
    },
    z = {
      details = [[
Works like the `y=` option, but now a dimension is the point
$(⟨value⟩,⟨value⟩)$.

    \begin{tikzpicture}[z=-1cm,->,thick]
      \draw[color=red] (0,0,0) -- (1,0,0);
      \draw[color=blue] (0,0,0) -- (0,1,0);
      \draw[color=orange] (0,0,0) -- (0,0,1);
    \end{tikzpicture}
]],
      documentation = "texmf:doc/generic/pgf/pgfmanual.pdf#pgf./tikz/z",
      meta = "⟨value⟩"
    }
  }
}
